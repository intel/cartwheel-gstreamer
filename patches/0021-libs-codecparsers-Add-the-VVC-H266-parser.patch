From 97ca7ca075000938098f708c42b2d960f0aa5229 Mon Sep 17 00:00:00 2001
From: Zhong Hongcheng <spartazhc@gmail.com>
Date: Tue, 16 May 2023 20:34:03 +0800
Subject: [PATCH 1/4] libs: codecparsers: Add the VVC(H266) parser

Co-authored-by: He Junyan <junyan.he@intel.com>
---
 .../gst-libs/gst/codecparsers/gsth266parser.c | 5993 +++++++++++++++++
 .../gst-libs/gst/codecparsers/gsth266parser.h | 3336 +++++++++
 .../gst-libs/gst/codecparsers/meson.build     |    2 +
 3 files changed, 9331 insertions(+)
 create mode 100644 subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/gsth266parser.c
 create mode 100644 subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/gsth266parser.h

diff --git a/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/gsth266parser.c b/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/gsth266parser.c
new file mode 100644
index 0000000000..fc2e4823cb
--- /dev/null
+++ b/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/gsth266parser.c
@@ -0,0 +1,5993 @@
+/* Gstreamer H.266 bitstream parser
+ *
+ * Copyright (C) 2023 Intel Corporation
+ *    Author: Zhong Hongcheng <spartazhc@gmail.com>
+ *    Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:gsth266parser
+ * @title: GstH266Parser
+ * @short_description: Convenience library for h266 video bitstream parsing.
+ *
+ * To identify Nals in a bitstream and parse its headers, you should call:
+ *
+ *   * gst_h266_parser_identify_nalu() to identify the following nalu in
+ *        VVC bitstreams
+ *
+ * Then, depending on the #GstH266NalUnitType of the newly parsed #GstH266NalUnit,
+ * you should call the different functions to parse the structure:
+ *
+ *   * From #GST_H266_TRAIL_NUL to #GST_H266_NAL_SLICE_GDR:
+ *     gst_h266_parser_parse_slice_hdr()
+ *
+ *   * `GST_H266_NAL_*_SEI`: gst_h266_parser_parse_sei()
+ *
+ *   * #GST_H266_NAL_VPS: gst_h266_parser_parse_vps()
+ *
+ *   * #GST_H266_NAL_SPS: gst_h266_parser_parse_sps()
+ *
+ *   * #GST_H266_NAL_PPS: #gst_h266_parser_parse_pps()
+ *
+ *   * Any other: gst_h266_parser_parse_nal()
+ *
+ * Note: You should always call gst_h266_parser_parse_nal() if you don't
+ * actually need #GstH266NalUnitType to be parsed for your personal use, in
+ * order to guarantee that the #GstH266Parser is always up to date.
+ *
+ * For more details about the structures, look at the ITU-T H.266
+ * specifications, you can download them from:
+ *
+ *   * ITU-T H.266: http://www.itu.int/rec/T-REC-H.266
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "nalutils.h"
+#include "gsth266parser.h"
+
+#include <gst/base/gstbytereader.h>
+#include <gst/base/gstbitreader.h>
+#include <string.h>
+
+#ifndef GST_DISABLE_GST_DEBUG
+#define GST_CAT_DEFAULT gst_h266_debug_category_get()
+static GstDebugCategory *
+gst_h266_debug_category_get (void)
+{
+  static gsize cat_gonce = 0;
+
+  if (g_once_init_enter (&cat_gonce)) {
+    GstDebugCategory *cat = NULL;
+
+    GST_DEBUG_CATEGORY_INIT (cat, "codecparsers_h266", 0, "h266 parse library");
+
+    g_once_init_leave (&cat_gonce, (gsize) cat);
+  }
+  return (GstDebugCategory *) cat_gonce;
+}
+#endif /* GST_DISABLE_GST_DEBUG */
+
+const guint8 scaling_pred_all_8[8 * 8] = {
+  8, 8, 8, 8, 8, 8, 8, 8,
+  8, 8, 8, 8, 8, 8, 8, 8,
+  8, 8, 8, 8, 8, 8, 8, 8,
+  8, 8, 8, 8, 8, 8, 8, 8,
+  8, 8, 8, 8, 8, 8, 8, 8,
+  8, 8, 8, 8, 8, 8, 8, 8,
+  8, 8, 8, 8, 8, 8, 8, 8,
+  8, 8, 8, 8, 8, 8, 8, 8,
+};
+
+const guint8 scaling_pred_all_16[8 * 8] = {
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+};
+
+/* *INDENT-OFF* */
+/* Only need square matrix at most 8x8 for syntax level. */
+static const guint8 square_DiagScanOrder_x[4][8 * 8] = {
+  /* 1x1 */
+  { 0, },
+  /* 2x2 */
+  { 0,  0,  1,  1, },
+  /* 4x4 */
+  { 0,  0,  1,  0,  1,  2,  0,  1,  2,  3,  1,  2,  3,  2,  3,  3, },
+  /* 8x8 */
+  { 0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0,
+    1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3,
+    4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6,
+    7, 3, 4, 5, 6, 7, 4, 5, 6, 7, 5, 6, 7, 6, 7, 7, },
+};
+
+/* Only need square matrix at most 8x8 for syntax level. */
+static const guint8 square_DiagScanOrder_y[4][8 * 8] = {
+  /* 1x1 */
+  { 0, },
+  /* 2x2 */
+  { 0,  1,  0,  1, },
+  /* 4x4 */
+  { 0,  1,  0,  2,  1,  0,  3,  2,  1,  0,  3,  2,  1,  3,  2,  3, },
+  /* 8x8 */
+  { 0, 1, 0, 2, 1, 0, 3, 2, 1, 0, 4, 3, 2, 1, 0, 5,
+    4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1, 0, 7, 6, 5, 4,
+    3, 2, 1, 0, 7, 6, 5, 4, 3, 2, 1, 7, 6, 5, 4, 3,
+    2, 7, 6, 5, 4, 3, 7, 6, 5, 4, 7, 6, 5, 7, 6, 7, }
+};
+/* *INDENT-ON* */
+
+typedef struct
+{
+  guint par_n, par_d;
+} PAR;
+
+/* ITU-T Rec. H.273 | ISO/IEC 23091-2. Table 7 –
+ * Meaning of sample aspect ratio indicator (SampleAspectRatio) */
+static const PAR aspect_ratios[17] = {
+  {0, 0},
+  {1, 1},
+  {12, 11},
+  {10, 11},
+  {16, 11},
+  {40, 33},
+  {24, 11},
+  {20, 11},
+  {32, 11},
+  {80, 33},
+  {18, 11},
+  {15, 11},
+  {64, 33},
+  {160, 99},
+  {4, 3},
+  {3, 2},
+  {2, 1}
+};
+
+/*****  Utils ****/
+static inline gint
+floor_log2 (guint32 x)
+{
+  int result = 0;
+
+  if (x == 0) {
+    return -1;
+  }
+
+  if (x & 0xffff0000) {
+    x >>= 16;
+    result += 16;
+  }
+
+  if (x & 0xff00) {
+    x >>= 8;
+    result += 8;
+  }
+
+  if (x & 0xf0) {
+    x >>= 4;
+    result += 4;
+  }
+
+  if (x & 0xc) {
+    x >>= 2;
+    result += 2;
+  }
+
+  if (x & 0x2) {
+    x >>= 1;
+    result += 1;
+  }
+
+  return result;
+}
+
+#define EXTENDED_SAR 255
+
+static GstH266VPS *
+gst_h266_parser_get_vps (GstH266Parser * parser, guint8 id)
+{
+  GstH266VPS *vps;
+
+  vps = &parser->vps[id];
+
+  if (vps->valid)
+    return vps;
+
+  return NULL;
+}
+
+static GstH266SPS *
+gst_h266_parser_get_sps (GstH266Parser * parser, guint8 id)
+{
+  GstH266SPS *sps;
+
+  sps = &parser->sps[id];
+
+  if (sps->valid)
+    return sps;
+
+  return NULL;
+}
+
+static GstH266PPS *
+gst_h266_parser_get_pps (GstH266Parser * parser, guint8 pps_id)
+{
+  GstH266PPS *pps;
+
+  pps = &parser->pps[pps_id];
+
+  if (pps->valid)
+    return pps;
+
+  return NULL;
+}
+
+static gboolean
+gst_h266_parse_nalu_header (GstH266NalUnit * nalu)
+{
+  guint8 *data = nalu->data + nalu->offset;
+  GstBitReader br;
+
+  if (nalu->size < 2)
+    return FALSE;
+
+  gst_bit_reader_init (&br, data, nalu->size - nalu->offset);
+
+  /* skip the forbidden_zero_bit and nuh_reserved_zero_bit */
+  gst_bit_reader_skip_unchecked (&br, 2);
+
+  nalu->layer_id = gst_bit_reader_get_bits_uint8_unchecked (&br, 6);
+  nalu->type = gst_bit_reader_get_bits_uint8_unchecked (&br, 5);
+  nalu->temporal_id_plus1 = gst_bit_reader_get_bits_uint8_unchecked (&br, 3);
+  nalu->header_bytes = 2;
+
+  if (nalu->layer_id > 55) {
+    GST_WARNING ("The value of nuh_layer_id shall be in the "
+        "range of 0 to 55, inclusive");
+    return FALSE;
+  }
+
+  /* rules for base layer */
+  if (nalu->layer_id == 0) {
+    if (nalu->temporal_id_plus1 - 1 == 0 &&
+        nalu->type == GST_H266_NAL_SLICE_STSA) {
+      GST_WARNING ("When NAL unit type is equal to STSA_NUT, "
+          "TemporalId shall not be equal to 0");
+      return FALSE;
+    }
+  }
+
+  return TRUE;
+}
+
+struct h266_profile_string
+{
+  GstH266Profile profile;
+  const gchar *name;
+};
+
+static const struct h266_profile_string h266_profiles[] = {
+  /* keep in sync with definition in the header */
+  {GST_H266_PROFILE_STILL_PICTURE, "still-picture"},
+  {GST_H266_PROFILE_MAIN_10, "main-10"},
+  {GST_H266_PROFILE_MAIN_10_STILL_PICTURE, "main-10-still-picture"},
+  {GST_H266_PROFILE_MULTILAYER_MAIN_10, "multilayer-main-10"},
+  {GST_H266_PROFILE_MULTILAYER_MAIN_10_STILL_PICTURE,
+      "multilayer-main-10-still-picture"},
+  {GST_H266_PROFILE_MAIN_10_444, "main-10-444"},
+  {GST_H266_PROFILE_MAIN_10_444_STILL_PICTURE, "main-10-444-still-picture"},
+  {GST_H266_PROFILE_MULTILAYER_MAIN_10_444, "multilayer-main-10-444"},
+  {GST_H266_PROFILE_MULTILAYER_MAIN_10_444_STILL_PICTURE,
+      "multilayer-main-10-444-still-picture"},
+  {GST_H266_PROFILE_MAIN_12, "main-12"},
+  {GST_H266_PROFILE_MAIN_12_444, "main-12-444"},
+  {GST_H266_PROFILE_MAIN_16_444, "main-16-444"},
+  {GST_H266_PROFILE_MAIN_12_INTRA, "main-12-intra"},
+  {GST_H266_PROFILE_MAIN_12_444_INTRA, "main-12-444-intra"},
+  {GST_H266_PROFILE_MAIN_16_444_INTRA, "main-16-444-intra"},
+  {GST_H266_PROFILE_MAIN_12_STILL_PICTURE, "main-12-still-picture"},
+  {GST_H266_PROFILE_MAIN_12_444_STILL_PICTURE, "main-12-444-still-picture"},
+  {GST_H266_PROFILE_MAIN_16_444_STILL_PICTURE, "main-16-444-still-picture"},
+};
+
+static gboolean
+gst_h266_parse_general_constraints_info (GstH266GeneralConstraintsInfo * gci,
+    NalReader * nr)
+{
+  guint8 num_additional_bits = 0;
+  guint8 num_additional_bits_used = 0;
+
+  GST_DEBUG ("parsing \"General Constraints Info Parameters\"");
+
+  READ_UINT8 (nr, gci->present_flag, 1);
+
+  if (gci->present_flag) {
+    /* general */
+    READ_UINT8 (nr, gci->intra_only_constraint_flag, 1);
+    READ_UINT8 (nr, gci->all_layers_independent_constraint_flag, 1);
+    READ_UINT8 (nr, gci->one_au_only_constraint_flag, 1);
+    /* picture format */
+    READ_UINT8 (nr, gci->sixteen_minus_max_bitdepth_constraint_idc, 4);
+    CHECK_ALLOWED_MAX (gci->sixteen_minus_max_bitdepth_constraint_idc, 8);
+    READ_UINT8 (nr, gci->three_minus_max_chroma_format_constraint_idc, 2);
+    /* NAL unit type related */
+    READ_UINT8 (nr, gci->no_mixed_nalu_types_in_pic_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_trail_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_stsa_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_rasl_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_radl_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_idr_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_cra_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_gdr_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_aps_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_idr_rpl_constraint_flag, 1);
+    /* tile, slice, subpicture partitioning */
+    READ_UINT8 (nr, gci->one_tile_per_pic_constraint_flag, 1);
+    READ_UINT8 (nr, gci->pic_header_in_slice_header_constraint_flag, 1);
+    READ_UINT8 (nr, gci->one_slice_per_pic_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_rectangular_slice_constraint_flag, 1);
+    READ_UINT8 (nr, gci->one_slice_per_subpic_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_subpic_info_constraint_flag, 1);
+    /* CTU and block partitioning */
+    READ_UINT8 (nr, gci->three_minus_max_log2_ctu_size_constraint_idc, 2);
+    READ_UINT8 (nr, gci->no_partition_constraints_override_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_mtt_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_qtbtt_dual_tree_intra_constraint_flag, 1);
+    /* intra */
+    READ_UINT8 (nr, gci->no_palette_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_ibc_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_isp_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_mrl_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_mip_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_cclm_constraint_flag, 1);
+    /* inter */
+    READ_UINT8 (nr, gci->no_ref_pic_resampling_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_res_change_in_clvs_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_weighted_prediction_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_ref_wraparound_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_temporal_mvp_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_sbtmvp_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_amvr_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_bdof_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_smvd_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_dmvr_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_mmvd_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_affine_motion_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_prof_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_bcw_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_ciip_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_gpm_constraint_flag, 1);
+    /* transform, quantization, residual */
+    READ_UINT8 (nr, gci->no_luma_transform_size_64_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_transform_skip_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_bdpcm_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_mts_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_lfnst_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_joint_cbcr_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_sbt_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_act_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_explicit_scaling_list_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_dep_quant_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_sign_data_hiding_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_cu_qp_delta_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_chroma_qp_offset_constraint_flag, 1);
+    /* loop fitler */
+    READ_UINT8 (nr, gci->no_sao_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_alf_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_ccalf_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_lmcs_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_ladf_constraint_flag, 1);
+    READ_UINT8 (nr, gci->no_virtual_boundaries_constraint_flag, 1);
+
+    READ_UINT8 (nr, num_additional_bits, 8);
+    if (num_additional_bits > 5) {
+      READ_UINT8 (nr, gci->all_rap_pictures_constraint_flag, 1);
+      READ_UINT8 (nr, gci->no_extended_precision_processing_constraint_flag, 1);
+      READ_UINT8 (nr, gci->no_ts_residual_coding_rice_constraint_flag, 1);
+      READ_UINT8 (nr, gci->no_rrc_rice_extension_constraint_flag, 1);
+      READ_UINT8 (nr, gci->no_persistent_rice_adaptation_constraint_flag, 1);
+      READ_UINT8 (nr, gci->no_reverse_last_sig_coeff_constraint_flag, 1);
+      num_additional_bits_used = 6;
+    } else if (num_additional_bits > 0) {
+      GST_WARNING ("Invalid bitstream: gci_num_additional_bits set "
+          "to value %d (must be 0 or >= 6)\n", num_additional_bits);
+      goto error;
+    }
+
+    /* skip the reserved zero bits */
+    if (!nal_reader_skip (nr, num_additional_bits - num_additional_bits_used))
+      goto error;
+  }
+
+  while (!nal_reader_is_byte_aligned (nr)) {
+    if (!nal_reader_skip (nr, 1))
+      goto error;
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"General Constraints Info Parameters\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_profile_tier_level (GstH266ProfileTierLevel * ptl,
+    NalReader * nr, guint8 profileTierPresentFlag, guint8 MaxNumSubLayersMinus1)
+{
+  gint8 i;
+
+  GST_DEBUG ("parsing \"Profile Tier Level parameters\"");
+
+  if (profileTierPresentFlag) {
+    guint8 profile_idc;
+
+    READ_UINT8 (nr, profile_idc, 7);
+    READ_UINT8 (nr, ptl->tier_flag, 1);
+
+    ptl->profile_idc = profile_idc;
+  }
+
+  READ_UINT8 (nr, ptl->level_idc, 8);
+
+  if (ptl->profile_idc != GST_H266_PROFILE_NONE &&
+      ptl->level_idc < /* level 4 */ 64 && ptl->tier_flag) {
+    GST_WARNING ("High tier not defined for levels below 4");
+    goto error;
+  }
+
+  READ_UINT8 (nr, ptl->frame_only_constraint_flag, 1);
+  READ_UINT8 (nr, ptl->multilayer_enabled_flag, 1);
+  if ((ptl->profile_idc == GST_H266_PROFILE_MAIN_10 ||
+          ptl->profile_idc == GST_H266_PROFILE_MAIN_10_444 ||
+          ptl->profile_idc == GST_H266_PROFILE_MAIN_10_STILL_PICTURE ||
+          ptl->profile_idc == GST_H266_PROFILE_MAIN_10_444_STILL_PICTURE)
+      && ptl->multilayer_enabled_flag) {
+    GST_WARNING ("ptl_multilayer_enabled_flag shall be"
+        " equal to 0 for non-multilayer profiles");
+    goto error;
+  }
+
+  if (profileTierPresentFlag)
+    if (!gst_h266_parse_general_constraints_info
+        (&ptl->general_constraints_info, nr))
+      goto error;
+
+  for (i = MaxNumSubLayersMinus1 - 1; i >= 0; i--)
+    READ_UINT8 (nr, ptl->sublayer_level_present_flag[i], 1);
+
+  /* skip the reserved zero bits */
+  while (!nal_reader_is_byte_aligned (nr)) {
+    if (!nal_reader_skip (nr, 1))
+      goto error;
+  }
+
+  for (i = MaxNumSubLayersMinus1 - 1; i >= 0; i--)
+    if (ptl->sublayer_level_present_flag[i])
+      READ_UINT8 (nr, ptl->sublayer_level_idc[i], 8);
+
+  if (profileTierPresentFlag) {
+    READ_UINT8 (nr, ptl->num_sub_profiles, 8);
+    for (i = 0; i < ptl->num_sub_profiles; i++) {
+      guint32 sub_profile_idc;
+
+      READ_UINT32 (nr, sub_profile_idc, 32);
+      ptl->sub_profile_idc[i] = sub_profile_idc;
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"Profile Tier Level Parameters\"");
+  return FALSE;
+}
+
+static void
+gst_h266_vui_parameters_set_default (GstH266VUIParams * vui)
+{
+  GST_DEBUG ("setting \"VUI parameters set default\"");
+
+  /* Annex D.8 */
+  vui->progressive_source_flag = 0;
+  vui->interlaced_source_flag = 0;
+  vui->non_packed_constraint_flag = 0;
+  vui->non_projected_constraint_flag = 0;
+  vui->aspect_ratio_constant_flag = 0;
+  vui->aspect_ratio_idc = 0;
+  vui->overscan_info_present_flag = 0;
+  vui->colour_primaries = 2;
+  vui->transfer_characteristics = 2;
+  vui->matrix_coeffs = 2;
+  vui->full_range_flag = 0;
+  vui->chroma_sample_loc_type_frame = 6;
+  vui->chroma_sample_loc_type_top_field = 6;
+  vui->chroma_sample_loc_type_bottom_field = 6;
+}
+
+static gboolean
+gst_h266_parse_vui_parameters (GstH266VUIParams * vui, NalReader * nr)
+{
+  GST_DEBUG ("parsing \"VUI parameters\"");
+
+  READ_UINT8 (nr, vui->progressive_source_flag, 1);
+  READ_UINT8 (nr, vui->interlaced_source_flag, 1);
+  READ_UINT8 (nr, vui->non_packed_constraint_flag, 1);
+  READ_UINT8 (nr, vui->non_projected_constraint_flag, 1);
+
+  READ_UINT8 (nr, vui->aspect_ratio_info_present_flag, 1);
+  if (vui->aspect_ratio_info_present_flag) {
+    READ_UINT8 (nr, vui->aspect_ratio_constant_flag, 1);
+    READ_UINT8 (nr, vui->aspect_ratio_idc, 8);
+    if (vui->aspect_ratio_idc == EXTENDED_SAR) {
+      READ_UINT16 (nr, vui->sar_width, 16);
+      READ_UINT16 (nr, vui->sar_height, 16);
+      vui->par_n = vui->sar_width;
+      vui->par_d = vui->sar_height;
+    } else {
+      vui->par_n = aspect_ratios[vui->aspect_ratio_idc].par_n;
+      vui->par_d = aspect_ratios[vui->aspect_ratio_idc].par_d;
+    }
+  } else {
+    vui->aspect_ratio_constant_flag = 0;
+    vui->aspect_ratio_idc = 0;
+  }
+
+  READ_UINT8 (nr, vui->overscan_info_present_flag, 1);
+  if (vui->overscan_info_present_flag)
+    READ_UINT8 (nr, vui->overscan_appropriate_flag, 1);
+
+  READ_UINT8 (nr, vui->colour_description_present_flag, 1);
+  if (vui->colour_description_present_flag) {
+    READ_UINT8 (nr, vui->colour_primaries, 8);
+    READ_UINT8 (nr, vui->transfer_characteristics, 8);
+    READ_UINT8 (nr, vui->matrix_coeffs, 8);
+    READ_UINT8 (nr, vui->full_range_flag, 1);
+  } else {
+    vui->colour_primaries = 2;
+    vui->transfer_characteristics = 2;
+    vui->matrix_coeffs = 2;
+    vui->full_range_flag = 0;
+  }
+
+  READ_UINT8 (nr, vui->chroma_loc_info_present_flag, 1);
+  if (vui->chroma_loc_info_present_flag) {
+    if (vui->progressive_source_flag && !vui->interlaced_source_flag) {
+      READ_UE_MAX (nr, vui->chroma_sample_loc_type_frame, 6);
+    } else {
+      READ_UE_MAX (nr, vui->chroma_sample_loc_type_top_field, 6);
+      READ_UE_MAX (nr, vui->chroma_sample_loc_type_bottom_field, 6);
+    }
+  } else {
+    vui->chroma_sample_loc_type_frame = 6;
+    vui->chroma_sample_loc_type_top_field = vui->chroma_sample_loc_type_frame;
+    vui->chroma_sample_loc_type_bottom_field =
+        vui->chroma_sample_loc_type_frame;
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"VUI parameters\"");
+  return FALSE;
+}
+
+static gboolean
+nal_reader_has_more_data_in_payload (NalReader * nr,
+    guint32 payload_start_pos_bit, guint32 payloadSize)
+{
+  if (nal_reader_is_byte_aligned (nr) &&
+      (nal_reader_get_pos (nr) >= (payload_start_pos_bit + 8 * payloadSize)))
+    return FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+gst_h266_parse_vui_payload (GstH266VUIParams * vui, NalReader * nr,
+    guint16 vui_payload_size)
+{
+  guint32 payload_start_pos;
+
+  GST_DEBUG ("parsing \"VUI payload\"");
+
+  payload_start_pos = nal_reader_get_pos (nr);
+
+  if (!gst_h266_parse_vui_parameters (vui, nr))
+    goto error;
+
+  if (nal_reader_has_more_data_in_payload (nr, payload_start_pos,
+          vui_payload_size)) {
+    if (!nal_reader_skip (nr, 1))
+      goto error;
+    while (!nal_reader_is_byte_aligned (nr)) {
+      if (!nal_reader_skip (nr, 1))
+        goto error;
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"VUI payload\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_dpb_parameters (GstH266DPBParameters * dpb,
+    NalReader * nr, guint8 MaxSubLayersMinus1, guint8 subLayerInfoFlag)
+{
+  gint i;
+
+  GST_DEBUG ("parsing \"DPB Parameters\"");
+
+  for (i = (subLayerInfoFlag ? 0 : MaxSubLayersMinus1);
+      i <= MaxSubLayersMinus1; i++) {
+    READ_UE_MAX (nr, dpb->max_dec_pic_buffering_minus1[i],
+        GST_H266_MAX_DPB_SIZE - 1);
+    READ_UE_MAX (nr, dpb->max_num_reorder_pics[i],
+        dpb->max_dec_pic_buffering_minus1[i]);
+    READ_UE_MAX (nr, dpb->max_latency_increase_plus1[i], G_MAXINT32 - 1);
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"DPB Parameters\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_ref_pic_list_struct (GstH266RefPicListStruct * rpls, NalReader * nr,
+    guint8 list_idx, guint8 rpls_idx, const GstH266SPS * sps)
+{
+  gint i;
+
+  GST_DEBUG ("parsing \"ref_pic_list_struct\"");
+
+  memset (rpls, 0, sizeof (*rpls));
+
+  READ_UE_MAX (nr, rpls->num_ref_entries, GST_H266_MAX_REF_ENTRIES);
+
+  if (sps->long_term_ref_pics_flag &&
+      rpls_idx < sps->num_ref_pic_lists[list_idx] &&
+      rpls->num_ref_entries > 0) {
+    READ_UINT8 (nr, rpls->ltrp_in_header_flag, 1);
+  } else if (sps->long_term_ref_pics_flag)
+    rpls->ltrp_in_header_flag = 1;
+
+  for (i = 0; i < rpls->num_ref_entries; i++) {
+    if (sps->inter_layer_prediction_enabled_flag) {
+      READ_UINT8 (nr, rpls->inter_layer_ref_pic_flag[i], 1);
+    } else
+      rpls->inter_layer_ref_pic_flag[i] = 0;
+
+    if (rpls->inter_layer_ref_pic_flag[i]) {
+      rpls->num_inter_layer_pic++;
+      continue;
+    }
+
+    if (sps->long_term_ref_pics_flag) {
+      READ_UINT8 (nr, rpls->st_ref_pic_flag[i], 1);
+    } else
+      rpls->st_ref_pic_flag[i] = 1;
+
+    if (rpls->st_ref_pic_flag[i]) {
+      gint abs_delta_poc_st;
+
+      READ_UE_MAX (nr, rpls->abs_delta_poc_st[i], G_MAXUINT16 - 1);
+
+      if ((sps->weighted_pred_flag || sps->weighted_bipred_flag) && i != 0)
+        abs_delta_poc_st = rpls->abs_delta_poc_st[i];
+      else
+        abs_delta_poc_st = rpls->abs_delta_poc_st[i] + 1;
+
+      if (abs_delta_poc_st > 0) {
+        READ_UINT8 (nr, rpls->strp_entry_sign_flag[i], 1);
+      }
+
+      rpls->delta_poc_val_st[i] =
+          (1 - 2 * rpls->strp_entry_sign_flag[i]) * abs_delta_poc_st;
+
+      rpls->num_short_term_pic++;
+    } else {
+      if (!rpls->ltrp_in_header_flag) {
+        READ_UINT8 (nr, rpls->rpls_poc_lsb_lt[i],
+            sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+      }
+
+      rpls->num_long_term_pic++;
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"ref_pic_list_struct \"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_ref_pic_lists (GstH266RefPicLists * rpls, NalReader * nr,
+    const GstH266SPS * sps, const GstH266PPS * pps)
+{
+  const GstH266RefPicListStruct *ref_list;
+  gint i, j, num_ltrp_entries;
+
+  GST_DEBUG ("parsing \"ref_pic_lists\"");
+
+  for (i = 0; i < 2; i++) {
+    if (sps->num_ref_pic_lists[i] == 0) {
+      rpls->rpl_sps_flag[i] = 0;
+    } else if (i == 0 || (i == 1 && pps->rpl1_idx_present_flag)) {
+      READ_UINT8 (nr, rpls->rpl_sps_flag[i], 1);
+    } else {
+      /* Only the case of (i == 1 && !pps->rpl1_idx_present_flag)
+         comes to here. */
+      rpls->rpl_sps_flag[1] = rpls->rpl_sps_flag[0];
+    }
+
+    if (rpls->rpl_sps_flag[i]) {
+      g_assert (sps->num_ref_pic_lists[i] > 0);
+
+      if (sps->num_ref_pic_lists[i] == 1) {
+        rpls->rpl_idx[i] = 0;
+      } else if (i == 0 || (i == 1 && pps->rpl1_idx_present_flag)) {
+        READ_UINT8 (nr, rpls->rpl_idx[i],
+            gst_util_ceil_log2 (sps->num_ref_pic_lists[i]));
+        CHECK_ALLOWED_MAX (rpls->rpl_idx[i], sps->num_ref_pic_lists[i] - 1);
+      } else {
+        /* Only the case of (i == 1 && !pps->rpl1_idx_present_flag)
+           comes to here. */
+        rpls->rpl_idx[1] = rpls->rpl_idx[0];
+      }
+
+      memcpy (&rpls->rpl_ref_list[i],
+          &sps->ref_pic_list_struct[i][rpls->rpl_idx[i]],
+          sizeof (rpls->rpl_ref_list[i]));
+    } else {
+      gst_h266_ref_pic_list_struct (&rpls->rpl_ref_list[i], nr,
+          i, sps->num_ref_pic_lists[i], sps);
+    }
+    ref_list = &rpls->rpl_ref_list[i];
+
+    num_ltrp_entries = 0;
+    for (j = 0; j < ref_list->num_ref_entries; j++) {
+      if (ref_list->inter_layer_ref_pic_flag[j]
+          || ref_list->st_ref_pic_flag[j])
+        continue;
+
+      if (ref_list->ltrp_in_header_flag)
+        READ_UINT16 (nr, rpls->poc_lsb_lt[i][j],
+            sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+
+      READ_UINT8 (nr, rpls->delta_poc_msb_cycle_present_flag[i][j], 1);
+      if (rpls->delta_poc_msb_cycle_present_flag[i][j])
+        READ_UE_MAX (nr, rpls->delta_poc_msb_cycle_lt[i][j],
+            1 << (32 - sps->log2_max_pic_order_cnt_lsb_minus4 - 4));
+
+      num_ltrp_entries++;
+    }
+
+    g_assert (num_ltrp_entries == ref_list->num_long_term_pic);
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"ref_pic_lists \"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_general_timing_hrd_parameters (GstH266GeneralHRDParameters * hrd,
+    NalReader * nr)
+{
+  GST_DEBUG ("parsing \"General timing HRD Parameters\"");
+
+  READ_UINT32 (nr, hrd->num_units_in_tick, 32);
+  READ_UINT32 (nr, hrd->time_scale, 32);
+
+  READ_UINT8 (nr, hrd->general_nal_hrd_params_present_flag, 1);
+  READ_UINT8 (nr, hrd->general_vcl_hrd_params_present_flag, 1);
+  if (hrd->general_nal_hrd_params_present_flag
+      || hrd->general_vcl_hrd_params_present_flag) {
+    READ_UINT8 (nr, hrd->general_same_pic_timing_in_all_ols_flag, 1);
+    READ_UINT8 (nr, hrd->general_du_hrd_params_present_flag, 1);
+    if (hrd->general_du_hrd_params_present_flag)
+      READ_UINT8 (nr, hrd->tick_divisor_minus2, 8);
+
+    READ_UINT8 (nr, hrd->bit_rate_scale, 4);
+    READ_UINT8 (nr, hrd->cpb_size_scale, 4);
+    if (hrd->general_du_hrd_params_present_flag)
+      READ_UINT8 (nr, hrd->cpb_size_du_scale, 4);
+
+    READ_UE_MAX (nr, hrd->hrd_cpb_cnt_minus1, 31);
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"General timing HRD Parameters\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_sublayer_hrd_parameters (GstH266SubLayerHRDParameters * sub_hrd,
+    NalReader * nr, guint8 subLayerId,
+    const GstH266GeneralHRDParameters * general)
+{
+  guint i;
+
+  GST_DEBUG ("parsing \"SubLayer HRD Parameters\"");
+
+  for (i = 0; i <= general->hrd_cpb_cnt_minus1; i++) {
+    READ_UE_MAX (nr, sub_hrd->bit_rate_value_minus1[i], G_MAXUINT32 - 1);
+    READ_UE_MAX (nr, sub_hrd->cpb_size_value_minus1[i], G_MAXUINT32 - 1);
+
+    sub_hrd->bit_rate[i] = (sub_hrd->bit_rate_value_minus1[i] + 1) *
+        (2 << (6 + general->bit_rate_scale));
+    sub_hrd->cpb_size[i] = (sub_hrd->cpb_size_value_minus1[i] + 1) *
+        (2 << (4 + general->cpb_size_scale));
+
+    if (general->general_du_hrd_params_present_flag) {
+      READ_UE_MAX (nr, sub_hrd->cpb_size_du_value_minus1[i], G_MAXUINT32 - 1);
+      READ_UE_MAX (nr, sub_hrd->bit_rate_du_value_minus1[i], G_MAXUINT32 - 1);
+    }
+    READ_UINT8 (nr, sub_hrd->cbr_flag[i], 1);
+  }
+
+  for (i = 1; i <= general->hrd_cpb_cnt_minus1; i++) {
+    if (sub_hrd->bit_rate[i] <= sub_hrd->bit_rate[i - 1]) {
+      GST_WARNING ("bit_rate_value_minus1[i][j] shall be greater than "
+          "bit_rate_value_minus1[i][j-1], i=%u, j=%u", subLayerId, i);
+      goto error;
+    }
+    if (sub_hrd->cpb_size[i] <= sub_hrd->cpb_size[i - 1]) {
+      GST_WARNING ("cpb_size_value_minus1[i][j] shall be less than or equal "
+          "to cpb_size_value_minus1[i][j-1], i=%u, j=%u", subLayerId, i);
+      goto error;
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"SubLayer HRD Parameters\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_ols_timing_hrd_parameters (GstH266OLSHRDParameters * olsHrd,
+    NalReader * nr, const GstH266GeneralHRDParameters * general,
+    guint8 firstSubLayer, guint8 MaxSubLayersVal)
+{
+  guint i, j;
+
+  GST_DEBUG ("parsing \"ols timing HRD Parameters\"");
+
+  for (i = firstSubLayer; i <= MaxSubLayersVal; i++) {
+    READ_UINT8 (nr, olsHrd->fixed_pic_rate_general_flag[i], 1);
+    if (!olsHrd->fixed_pic_rate_general_flag[i]) {
+      READ_UINT8 (nr, olsHrd->fixed_pic_rate_within_cvs_flag[i], 1);
+    } else
+      olsHrd->fixed_pic_rate_within_cvs_flag[i] = 1;
+
+    if (olsHrd->fixed_pic_rate_within_cvs_flag[i]) {
+      READ_UE_MAX (nr, olsHrd->elemental_duration_in_tc_minus1[i], 2047);
+      olsHrd->low_delay_hrd_flag[i] = 0;
+    } else if ((general->general_nal_hrd_params_present_flag ||
+            general->general_vcl_hrd_params_present_flag)
+        && general->hrd_cpb_cnt_minus1 == 0) {
+      READ_UINT8 (nr, olsHrd->low_delay_hrd_flag[i], 1);
+    } else {
+      olsHrd->low_delay_hrd_flag[i] = 0;
+    }
+
+    if (general->general_nal_hrd_params_present_flag) {
+      if (!gst_h266_parse_sublayer_hrd_parameters
+          (&olsHrd->nal_sub_layer_hrd_parameters[i], nr, i, general))
+        goto error;
+    }
+
+    if (general->general_vcl_hrd_params_present_flag) {
+      if (!gst_h266_parse_sublayer_hrd_parameters
+          (&olsHrd->vcl_sub_layer_hrd_parameters[i], nr, i, general))
+        goto error;
+    }
+  }
+
+  for (i = 0; i < firstSubLayer; i++) {
+    GstH266SubLayerHRDParameters *sub_hrd, *max_sub_hrd;
+
+    sub_hrd = &olsHrd->nal_sub_layer_hrd_parameters[i];
+    max_sub_hrd = &olsHrd->nal_sub_layer_hrd_parameters[MaxSubLayersVal];
+
+    if (general->general_nal_hrd_params_present_flag) {
+      for (j = 0; j <= general->hrd_cpb_cnt_minus1; j++) {
+        sub_hrd->bit_rate_value_minus1[j] =
+            max_sub_hrd->bit_rate_value_minus1[j];
+
+        if (general->general_du_hrd_params_present_flag) {
+          sub_hrd->cpb_size_du_value_minus1[j] =
+              max_sub_hrd->cpb_size_du_value_minus1[j];
+          sub_hrd->bit_rate_du_value_minus1[j] =
+              max_sub_hrd->bit_rate_du_value_minus1[j];
+        }
+
+        sub_hrd->cbr_flag[j] = max_sub_hrd->cbr_flag[j];
+      }
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"ols timing HRD Parameters\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_alf (GstH266ALF * alf, NalReader * nr,
+    guint8 aps_chroma_present_flag)
+{
+  gint j, k;
+  gint filtIdx, sfIdx, altIdx;
+
+  GST_DEBUG ("parsing \"ALF\"");
+
+  READ_UINT8 (nr, alf->luma_filter_signal_flag, 1);
+  if (aps_chroma_present_flag) {
+    READ_UINT8 (nr, alf->chroma_filter_signal_flag, 1);
+    READ_UINT8 (nr, alf->cc_cb_filter_signal_flag, 1);
+    READ_UINT8 (nr, alf->cc_cr_filter_signal_flag, 1);
+  }
+  if (alf->luma_filter_signal_flag == 0 &&
+      alf->chroma_filter_signal_flag == 0 &&
+      alf->cc_cb_filter_signal_flag == 0 &&
+      alf->cc_cr_filter_signal_flag == 0) {
+    GST_WARNING ("At least one of the values of alf_luma_filter_signal_flag, "
+        "alf_chroma_filter_signal_flag, alf_cc_cb_filter_signal_flag, and "
+        "alf_cc_cr_filter_signal_flag shall be equal to 1");
+    goto error;
+  }
+
+  if (alf->luma_filter_signal_flag) {
+    READ_UINT8 (nr, alf->luma_clip_flag, 1);
+    READ_UE_MAX (nr, alf->luma_num_filters_signalled_minus1,
+        GST_H266_NUM_ALF_FILTERS - 1);
+
+    if (alf->luma_num_filters_signalled_minus1 > 0) {
+      for (filtIdx = 0; filtIdx < GST_H266_NUM_ALF_FILTERS; filtIdx++) {
+        guint length =
+            gst_util_ceil_log2 (alf->luma_num_filters_signalled_minus1 + 1);
+
+        READ_UINT8 (nr, alf->luma_coeff_delta_idx[filtIdx], length);
+        CHECK_ALLOWED_MAX (alf->luma_coeff_delta_idx[filtIdx],
+            alf->luma_num_filters_signalled_minus1 + 1);
+      }
+    }
+
+    for (sfIdx = 0; sfIdx <= alf->luma_num_filters_signalled_minus1; sfIdx++) {
+      for (j = 0; j < 12; j++) {
+        READ_UE_MAX (nr, alf->luma_coeff_abs[sfIdx][j], 128);
+        if (alf->luma_coeff_abs[sfIdx][j])
+          READ_UINT8 (nr, alf->luma_coeff_sign[sfIdx][j], 1);
+      }
+    }
+
+    if (alf->luma_clip_flag) {
+      for (sfIdx = 0; sfIdx <= alf->luma_num_filters_signalled_minus1; sfIdx++) {
+        for (j = 0; j < 12; j++)
+          READ_UINT8 (nr, alf->luma_clip_idx[sfIdx][j], 2);
+      }
+    }
+  }
+
+  if (alf->chroma_filter_signal_flag) {
+    READ_UINT8 (nr, alf->chroma_clip_flag, 1);
+    READ_UE_MAX (nr, alf->chroma_num_alt_filters_minus1, 7);
+    for (altIdx = 0; altIdx <= alf->chroma_num_alt_filters_minus1; altIdx++) {
+      for (j = 0; j < 6; j++) {
+        READ_UE_MAX (nr, alf->chroma_coeff_abs[altIdx][j], 128);
+        if (alf->chroma_coeff_abs[altIdx][j] > 0)
+          READ_UINT8 (nr, alf->chroma_coeff_sign[altIdx][j], 1);
+      }
+
+      if (alf->chroma_clip_flag)
+        for (j = 0; j < 6; j++)
+          READ_UINT8 (nr, alf->chroma_clip_idx[altIdx][j], 2);
+    }
+  }
+
+  if (alf->cc_cb_filter_signal_flag) {
+    READ_UE_MAX (nr, alf->cc_cb_filters_signalled_minus1, 3);
+    for (k = 0; k < alf->cc_cb_filters_signalled_minus1 + 1; k++) {
+      for (j = 0; j < 7; j++) {
+        READ_UINT8 (nr, alf->cc_cb_mapped_coeff_abs[k][j], 3);
+        if (alf->cc_cb_mapped_coeff_abs[k][j])
+          READ_UINT8 (nr, alf->cc_cb_coeff_sign[k][j], 1);
+      }
+    }
+  }
+
+  if (alf->cc_cr_filter_signal_flag) {
+    READ_UE_MAX (nr, alf->cc_cr_filters_signalled_minus1, 3);
+    for (k = 0; k < alf->cc_cr_filters_signalled_minus1 + 1; k++) {
+      for (j = 0; j < 7; j++) {
+        READ_UINT8 (nr, alf->cc_cr_mapped_coeff_abs[k][j], 3);
+        if (alf->cc_cr_mapped_coeff_abs[k][j])
+          READ_UINT8 (nr, alf->cc_cr_coeff_sign[k][j], 1);
+      }
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"ALF\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_lmcs (GstH266LMCS * lmcs, NalReader * nr,
+    guint8 aps_chroma_present_flag)
+{
+  gint i, LmcsMaxBinIdx;
+
+  GST_DEBUG ("parsing \"LMCS\"");
+
+  READ_UE_MAX (nr, lmcs->min_bin_idx, 15);
+  READ_UE_MAX (nr, lmcs->delta_max_bin_idx, 15);
+  LmcsMaxBinIdx = 15 - lmcs->delta_max_bin_idx;
+  if (LmcsMaxBinIdx < lmcs->min_bin_idx) {
+    GST_WARNING ("The value of LmcsMaxBinIdx(%d) shall be "
+        ">= lmcs_min_bin_idx(%d)", LmcsMaxBinIdx, lmcs->min_bin_idx);
+    goto error;
+  }
+
+  READ_UE_MAX (nr, lmcs->delta_cw_prec_minus1, 14);
+  for (i = lmcs->min_bin_idx; i <= LmcsMaxBinIdx; i++) {
+    READ_UINT8 (nr, lmcs->delta_abs_cw[i], lmcs->delta_cw_prec_minus1 + 1);
+    if (lmcs->delta_abs_cw[i] > 0)
+      READ_UINT8 (nr, lmcs->delta_sign_cw_flag[i], 1);
+  }
+
+  if (aps_chroma_present_flag) {
+    READ_UINT8 (nr, lmcs->delta_abs_crs, 3);
+    if (lmcs->delta_abs_crs > 0)
+      READ_UINT8 (nr, lmcs->delta_sign_crs_flag, 1);
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"LMCS\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_scaling_list (GstH266ScalingList * scaling_list, NalReader * nr,
+    guint8 aps_chroma_present_flag)
+{
+  guint ScalingList[8 * 8];
+  const guint8 *scalingMatrixPred;
+  gint dc;
+  gint i, x, y;
+  gint id, nextCoef, matrixSize, maxIdDelta;
+  guint refId, log2_size;
+
+  GST_DEBUG ("parsing \"Scaling List\"");
+
+  for (id = 0; id < 28; id++) {
+    matrixSize = id < 2 ? 2 : (id < 8 ? 4 : 8);
+    log2_size = id < 2 ? 1 : (id < 8 ? 2 : 3);
+    maxIdDelta = (id < 2) ? id : ((id < 8) ? (id - 2) : (id - 8));
+    dc = 0;
+    memset (ScalingList, 0, sizeof (ScalingList));
+
+    scaling_list->copy_mode_flag[id] = 1;
+    scaling_list->pred_mode_flag[id] = 0;
+    scaling_list->pred_id_delta[id] = 0;
+
+    if (aps_chroma_present_flag || id % 3 == 2 || id == 27) {
+      READ_UINT8 (nr, scaling_list->copy_mode_flag[id], 1);
+      if (!scaling_list->copy_mode_flag[id])
+        READ_UINT8 (nr, scaling_list->pred_mode_flag[id], 1);
+
+      if ((scaling_list->copy_mode_flag[id] || scaling_list->pred_mode_flag[id])
+          && id != 0 && id != 2 && id != 8)
+        READ_UE_MAX (nr, scaling_list->pred_id_delta[id], maxIdDelta);
+
+      if (!scaling_list->copy_mode_flag[id]) {
+        nextCoef = 0;
+
+        if (id > 13) {
+          READ_SE_ALLOWED (nr, scaling_list->dc_coef[id - 14], -128, 127);
+          nextCoef = scaling_list->dc_coef[id - 14];
+          dc = scaling_list->dc_coef[id - 14];
+        }
+
+        for (i = 0; i < matrixSize * matrixSize; i++) {
+          x = square_DiagScanOrder_x[3][i];
+          y = square_DiagScanOrder_y[3][i];
+
+          if (!(id >= 25 && x >= 4 && y >= 4)) {
+            READ_SE_ALLOWED (nr, scaling_list->delta_coef[id][i], -128, 127);
+            nextCoef += scaling_list->delta_coef[id][i];
+          }
+
+          ScalingList[i] = nextCoef;
+        }
+      }
+    }
+
+    /* DC */
+    if (id > 13) {
+      if (!scaling_list->copy_mode_flag[id]
+          && !scaling_list->pred_mode_flag[id]) {
+        scaling_list->scaling_list_DC[id - 14] = 8;
+      } else if (!scaling_list->pred_id_delta[id]) {
+        scaling_list->scaling_list_DC[id - 14] = 16;
+      } else {
+        if (id < scaling_list->pred_id_delta[id]) {
+          GST_WARNING ("Wrong pred_id_delta for scaling list");
+          goto error;
+        }
+        refId = id - scaling_list->pred_id_delta[id];
+
+        if (refId >= 14) {
+          dc += scaling_list->scaling_list_DC[refId - 14];
+        } else {
+          dc += scaling_list->scaling_list[refId][0];
+        }
+
+        scaling_list->scaling_list_DC[id - 14] = dc & 255;
+      }
+    }
+
+    /* AC */
+    if (!scaling_list->copy_mode_flag[id] && !scaling_list->pred_mode_flag[id]) {
+      scalingMatrixPred = scaling_pred_all_8;
+    } else if (!scaling_list->pred_id_delta[id]) {
+      scalingMatrixPred = scaling_pred_all_16;
+    } else {
+      if (id < scaling_list->pred_id_delta[id]) {
+        GST_WARNING ("Wrong pred_id_delta for scaling list");
+        goto error;
+      }
+      refId = id - scaling_list->pred_id_delta[id];
+      scalingMatrixPred = scaling_list->scaling_list[refId];
+    }
+
+    for (i = 0; i < matrixSize * matrixSize; i++) {
+      guint offset;
+
+      x = square_DiagScanOrder_x[log2_size][i];
+      y = square_DiagScanOrder_y[log2_size][i];
+      offset = y * matrixSize + x;
+      if (offset > matrixSize * matrixSize) {
+        GST_WARNING ("Wrong matrix coeff array index:%d", offset);
+        goto error;
+      }
+
+      scaling_list->scaling_list[id][offset] =
+          (scalingMatrixPred[offset] + ScalingList[i]) & 255;
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"Scaling List\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_range_extension (GstH266SPSRangeExtensionParams * range_params,
+    NalReader * nr, guint8 transform_skip_enabled_flag)
+{
+  GST_DEBUG ("parsing \"Range Extension\"");
+
+  READ_UINT8 (nr, range_params->extended_precision_flag, 1);
+
+  if (transform_skip_enabled_flag)
+    READ_UINT8 (nr,
+        range_params->ts_residual_coding_rice_present_in_sh_flag, 1);
+
+  READ_UINT8 (nr, range_params->rrc_rice_extension_flag, 1);
+  READ_UINT8 (nr, range_params->persistent_rice_adaptation_enabled_flag, 1);
+  READ_UINT8 (nr, range_params->reverse_last_sig_coeff_enabled_flag, 1);
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"Range Extension\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parse_chroma_qp_table (GstH266SPS * sps, NalReader * nr)
+{
+  guint numQpTables;
+  guint num_points_in_qp_table;
+  gint qp_in[GST_H266_MAX_POINTS_IN_QP_TABLE + 1];
+  gint qp_out[GST_H266_MAX_POINTS_IN_QP_TABLE + 1];
+  guint delta_qp_in[GST_H266_MAX_POINTS_IN_QP_TABLE];
+  gint qp_bd_offset = 6 * sps->bitdepth_minus8;
+  gint i, j, k, m, index;
+
+  GST_DEBUG ("parsing \"Chroma QP Table\"");
+
+  READ_UINT8 (nr, sps->joint_cbcr_enabled_flag, 1);
+  READ_UINT8 (nr, sps->same_qp_table_for_chroma_flag, 1);
+
+  numQpTables = sps->same_qp_table_for_chroma_flag ?
+      1 : (sps->joint_cbcr_enabled_flag ? 3 : 2);
+
+  for (i = 0; i < numQpTables; i++) {
+    gint QpBdOffset = 6 * sps->bitdepth_minus8;
+
+    READ_SE_ALLOWED (nr, sps->qp_table_start_minus26[i], -26 - QpBdOffset, 36);
+
+    READ_UE_MAX (nr, sps->num_points_in_qp_table_minus1[i],
+        36 - sps->qp_table_start_minus26[i]);
+    num_points_in_qp_table = sps->num_points_in_qp_table_minus1[i] + 1;
+    if (num_points_in_qp_table > GST_H266_MAX_POINTS_IN_QP_TABLE) {
+      GST_WARNING ("num_points_in_qp_table %d out of range",
+          num_points_in_qp_table);
+      goto error;
+    }
+
+    qp_out[0] = qp_in[0] = sps->qp_table_start_minus26[i] + 26;
+    for (j = 0; j < num_points_in_qp_table; j++) {
+      READ_UE_MAX (nr, sps->delta_qp_in_val_minus1[i][j], 128);
+      READ_UE_MAX (nr, sps->delta_qp_diff_val[i][j], 128);
+
+      delta_qp_in[j] = sps->delta_qp_in_val_minus1[i][j] + 1;
+      qp_in[j + 1] = qp_in[j] + delta_qp_in[j];
+      qp_out[j + 1] = qp_out[j] +
+          (sps->delta_qp_in_val_minus1[i][j] ^ sps->delta_qp_diff_val[i][j]);
+    }
+
+    index = qp_in[0] + qp_bd_offset;
+    if (index < 0 || index >= GST_H266_MAX_POINTS_IN_QP_TABLE) {
+      GST_WARNING ("Invalid qp index %d", index);
+      goto error;
+    }
+    sps->chroma_qp_table[i][index] = qp_out[0];
+
+    k = qp_in[0] - 1 + qp_bd_offset;
+    if (k < 0 || k >= GST_H266_MAX_POINTS_IN_QP_TABLE) {
+      GST_WARNING ("Invalid qp index %d", k);
+      goto error;
+    }
+    for (; k >= 0; k--) {
+      sps->chroma_qp_table[i][k] =
+          MAX (sps->chroma_qp_table[i][k + 1] - 1, -qp_bd_offset);
+      sps->chroma_qp_table[i][k] = MIN (sps->chroma_qp_table[i][k], 63);
+    }
+
+    for (j = 0; j < num_points_in_qp_table; j++) {
+      gint sh = delta_qp_in[j] >> 1;
+
+      index = qp_in[j] + 1 + qp_bd_offset;
+      if (index < 0 || index >= GST_H266_MAX_POINTS_IN_QP_TABLE) {
+        GST_WARNING ("Invalid qp index %d", index);
+        goto error;
+      }
+      index = qp_in[j + 1] + qp_bd_offset;
+      if (index < 0 || index >= GST_H266_MAX_POINTS_IN_QP_TABLE) {
+        GST_WARNING ("Invalid qp index %d", index);
+        goto error;
+      }
+
+      for (k = qp_in[j] + 1 + qp_bd_offset, m = 1;
+          k <= qp_in[j + 1] + qp_bd_offset; k++, m++) {
+        index = qp_in[j] + qp_bd_offset;
+        if (index < 0 || index >= GST_H266_MAX_POINTS_IN_QP_TABLE) {
+          GST_WARNING ("Invalid qp index %d", index);
+          goto error;
+        }
+
+        sps->chroma_qp_table[i][k] = sps->chroma_qp_table[i][index] +
+            ((qp_out[j + 1] - qp_out[j]) * m + sh) / delta_qp_in[j];
+      }
+    }
+
+    k = qp_in[num_points_in_qp_table] + 1 + qp_bd_offset;
+    if (k < 1 || k >= GST_H266_MAX_POINTS_IN_QP_TABLE) {
+      GST_WARNING ("Invalid qp index %d", k);
+      goto error;
+    }
+    for (; k <= 63 + qp_bd_offset; k++) {
+      sps->chroma_qp_table[i][k] =
+          MAX (sps->chroma_qp_table[i][k - 1] + 1, -qp_bd_offset);
+      sps->chroma_qp_table[i][k] = MIN (sps->chroma_qp_table[i][k], 63);
+    }
+  }
+
+  if (sps->same_qp_table_for_chroma_flag) {
+    memcpy (&sps->chroma_qp_table[1], &sps->chroma_qp_table[0],
+        sizeof (sps->chroma_qp_table[0]));
+    memcpy (&sps->chroma_qp_table[2], &sps->chroma_qp_table[0],
+        sizeof (sps->chroma_qp_table[0]));
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"Chroma QP Table\"");
+  return FALSE;
+}
+
+static GstH266ParserResult
+gst_h266_parser_parse_buffering_period (GstH266BufferingPeriod * bp,
+    NalReader * nr)
+{
+  guint i, j;
+
+  GST_DEBUG ("parsing \"Buffering period\"");
+
+  READ_UINT8 (nr, bp->nal_hrd_params_present_flag, 1);
+  READ_UINT8 (nr, bp->vcl_hrd_params_present_flag, 1);
+  READ_UINT8 (nr, bp->cpb_initial_removal_delay_length_minus1, 5);
+  READ_UINT8 (nr, bp->cpb_removal_delay_length_minus1, 5);
+  READ_UINT8 (nr, bp->dpb_output_delay_length_minus1, 5);
+
+  READ_UINT8 (nr, bp->du_hrd_params_present_flag, 1);
+  if (bp->du_hrd_params_present_flag) {
+    READ_UINT8 (nr, bp->du_cpb_removal_delay_increment_length_minus1, 5);
+    READ_UINT8 (nr, bp->dpb_output_delay_du_length_minus1, 5);
+    READ_UINT8 (nr, bp->du_cpb_params_in_pic_timing_sei_flag, 1);
+    READ_UINT8 (nr, bp->du_dpb_params_in_pic_timing_sei_flag, 1);
+  }
+
+  READ_UINT8 (nr, bp->concatenation_flag, 1);
+
+  READ_UINT8 (nr, bp->additional_concatenation_info_present_flag, 1);
+  if (bp->additional_concatenation_info_present_flag)
+    READ_UINT8 (nr, bp->max_initial_removal_delay_for_concatenation,
+        bp->cpb_removal_delay_length_minus1 + 1);
+
+  READ_UINT8 (nr, bp->cpb_removal_delay_delta_minus1,
+      bp->cpb_removal_delay_length_minus1 + 1);
+
+  READ_UINT8 (nr, bp->max_sublayers_minus1, 3);
+  if (bp->max_sublayers_minus1 > 0)
+    READ_UINT8 (nr, bp->cpb_removal_delay_deltas_present_flag, 1);
+
+  if (bp->cpb_removal_delay_deltas_present_flag) {
+    READ_UE_MAX (nr, bp->num_cpb_removal_delay_deltas_minus1, 15);
+    for (i = 0; i <= bp->num_cpb_removal_delay_deltas_minus1; i++)
+      READ_UINT8 (nr, bp->cpb_removal_delay_delta_val[i], 1);
+  }
+
+  READ_UE_MAX (nr, bp->cpb_cnt_minus1, 31);
+
+  if (bp->max_sublayers_minus1 > 0)
+    READ_UINT8 (nr, bp->sublayer_initial_cpb_removal_delay_present_flag, 1);
+
+  for (i = (bp->sublayer_initial_cpb_removal_delay_present_flag ?
+          0 : bp->max_sublayers_minus1); i <= bp->max_sublayers_minus1; i++) {
+    if (bp->nal_hrd_params_present_flag) {
+      for (j = 0; j < bp->cpb_cnt_minus1 + 1; j++) {
+        /* shall be 0 < x <= 90000 * (CpbSize[i][j] / BitRate[i][j]) */
+        READ_UINT8 (nr, bp->nal_initial_cpb_removal_delay[i][j],
+            bp->cpb_initial_removal_delay_length_minus1 + 1);
+        READ_UINT8 (nr, bp->nal_initial_cpb_removal_offset[i][j],
+            bp->cpb_initial_removal_delay_length_minus1 + 1);
+        if (bp->du_hrd_params_present_flag) {
+          READ_UINT8 (nr, bp->nal_initial_alt_cpb_removal_delay[i][j],
+              bp->cpb_initial_removal_delay_length_minus1 + 1);
+          READ_UINT8 (nr, bp->nal_initial_alt_cpb_removal_offset[i][j],
+              bp->cpb_initial_removal_delay_length_minus1 + 1);
+        }
+      }
+    }
+
+    if (bp->vcl_hrd_params_present_flag) {
+      for (j = 0; j < bp->cpb_cnt_minus1 + 1; j++) {
+        READ_UINT8 (nr, bp->vcl_initial_cpb_removal_delay[i][j],
+            bp->cpb_initial_removal_delay_length_minus1 + 1);
+        READ_UINT8 (nr, bp->vcl_initial_cpb_removal_offset[i][j],
+            bp->cpb_initial_removal_delay_length_minus1 + 1);
+        if (bp->du_hrd_params_present_flag) {
+          READ_UINT8 (nr, bp->vcl_initial_alt_cpb_removal_delay[i][j],
+              bp->cpb_initial_removal_delay_length_minus1 + 1);
+          READ_UINT8 (nr, bp->vcl_initial_alt_cpb_removal_offset[i][j],
+              bp->cpb_initial_removal_delay_length_minus1 + 1);
+        }
+      }
+    }
+  }
+
+  if (bp->max_sublayers_minus1 > 0)
+    READ_UINT8 (nr, bp->sublayer_dpb_output_offsets_present_flag, 1);
+  if (bp->sublayer_dpb_output_offsets_present_flag) {
+    for (i = 0; i < bp->max_sublayers_minus1; i++)
+      READ_UE (nr, bp->dpb_output_tid_offset[i]);
+  }
+
+  READ_UINT8 (nr, bp->alt_cpb_params_present_flag, 1);
+  if (bp->alt_cpb_params_present_flag)
+    READ_UINT8 (nr, bp->use_alt_cpb_params_flag, 1);
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Buffering period\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+static GstH266ParserResult
+gst_h266_parser_parse_pic_timing (GstH266PicTiming * pt,
+    NalReader * nr, const GstH266BufferingPeriod bp, guint8 TemporalId)
+{
+  guint i, j;
+
+  GST_DEBUG ("parsing \"Picture timing\"");
+
+  READ_UINT8 (nr, pt->cpb_removal_delay_minus1[bp.max_sublayers_minus1],
+      bp.cpb_removal_delay_length_minus1 + 1);
+  pt->sublayer_delays_present_flag[bp.max_sublayers_minus1] = 1;
+
+  for (i = TemporalId; i < bp.max_sublayers_minus1; i++) {
+    READ_UINT8 (nr, pt->sublayer_delays_present_flag[i], 1);
+    if (pt->sublayer_delays_present_flag[i]) {
+      if (bp.cpb_removal_delay_deltas_present_flag)
+        READ_UINT8 (nr, pt->cpb_removal_delay_delta_enabled_flag[i], 1);
+
+      if (pt->cpb_removal_delay_delta_enabled_flag[i]) {
+        if (bp.num_cpb_removal_delay_deltas_minus1 > 0)
+          READ_UINT8 (nr, pt->cpb_removal_delay_delta_idx[i],
+              gst_util_ceil_log2 (bp.num_cpb_removal_delay_deltas_minus1 + 1));
+      } else {
+        READ_UINT8 (nr, pt->cpb_removal_delay_minus1[i],
+            bp.cpb_removal_delay_length_minus1 + 1);
+      }
+    }
+  }
+
+  READ_UINT8 (nr, pt->dpb_output_delay, bp.dpb_output_delay_length_minus1 + 1);
+
+  if (bp.alt_cpb_params_present_flag) {
+    READ_UINT8 (nr, pt->cpb_alt_timing_info_present_flag, 1);
+    if (pt->cpb_alt_timing_info_present_flag) {
+      if (bp.nal_hrd_params_present_flag) {
+        for (i = (bp.sublayer_initial_cpb_removal_delay_present_flag ? 0 :
+                bp.max_sublayers_minus1); i <= bp.max_sublayers_minus1; i++) {
+          for (j = 0; j < bp.cpb_cnt_minus1 + 1; j++) {
+            READ_UINT8 (nr, pt->nal_cpb_alt_initial_removal_delay_delta[i][j],
+                bp.cpb_initial_removal_delay_length_minus1 + 1);
+            READ_UINT8 (nr, pt->nal_cpb_alt_initial_removal_offset_delta[i][j],
+                bp.cpb_initial_removal_delay_length_minus1 + 1);
+          }
+
+          READ_UINT8 (nr, pt->nal_cpb_delay_offset[i],
+              bp.cpb_removal_delay_length_minus1 + 1);
+          READ_UINT8 (nr, pt->nal_dpb_delay_offset[i],
+              bp.cpb_removal_delay_length_minus1 + 1);
+        }
+      }
+
+      if (bp.vcl_hrd_params_present_flag) {
+        for (i = (bp.sublayer_initial_cpb_removal_delay_present_flag ? 0 :
+                bp.max_sublayers_minus1); i <= bp.max_sublayers_minus1; i++) {
+          for (j = 0; j < bp.cpb_cnt_minus1 + 1; j++) {
+            READ_UINT8 (nr, pt->vcl_cpb_alt_initial_removal_delay_delta[i][j],
+                bp.cpb_initial_removal_delay_length_minus1 + 1);
+            READ_UINT8 (nr, pt->vcl_cpb_alt_initial_removal_offset_delta[i][j],
+                bp.cpb_initial_removal_delay_length_minus1 + 1);
+          }
+
+          READ_UINT8 (nr, pt->vcl_cpb_delay_offset[i],
+              bp.cpb_removal_delay_length_minus1 + 1);
+          READ_UINT8 (nr, pt->vcl_dpb_delay_offset[i],
+              bp.cpb_removal_delay_length_minus1 + 1);
+        }
+      }
+    }
+  }
+
+  if (bp.du_hrd_params_present_flag && bp.du_dpb_params_in_pic_timing_sei_flag)
+    READ_UINT8 (nr, pt->dpb_output_du_delay,
+        bp.dpb_output_delay_du_length_minus1 + 1);
+
+  if (bp.du_hrd_params_present_flag && bp.du_cpb_params_in_pic_timing_sei_flag) {
+    READ_UE (nr, pt->num_decoding_units_minus1);
+    if (pt->num_decoding_units_minus1 > 0) {
+      READ_UINT8 (nr, pt->du_common_cpb_removal_delay_flag, 1);
+      if (pt->du_common_cpb_removal_delay_flag) {
+        for (i = TemporalId; i <= bp.max_sublayers_minus1; i++) {
+          if (pt->sublayer_delays_present_flag[i]) {
+            READ_UINT8 (nr, pt->du_common_cpb_removal_delay_increment_minus1[i],
+                bp.du_cpb_removal_delay_increment_length_minus1 + 1);
+          } else {
+            pt->du_common_cpb_removal_delay_increment_minus1[i] =
+                pt->du_common_cpb_removal_delay_increment_minus1
+                [bp.max_sublayers_minus1];
+          }
+        }
+      }
+
+      for (i = 0; i <= pt->num_decoding_units_minus1; i++) {
+        READ_UE (nr, pt->num_nalus_in_du_minus1[i]);
+
+        if (!pt->du_common_cpb_removal_delay_flag &&
+            i < pt->num_decoding_units_minus1)
+          for (j = TemporalId; j <= bp.max_sublayers_minus1; j++) {
+            if (pt->sublayer_delays_present_flag[j]) {
+              READ_UINT8 (nr, pt->du_cpb_removal_delay_increment_minus1[i][j],
+                  bp.du_cpb_removal_delay_increment_length_minus1 + 1);
+            } else {
+              pt->du_cpb_removal_delay_increment_minus1[i][j] =
+                  pt->du_cpb_removal_delay_increment_minus1[i]
+                  [bp.max_sublayers_minus1];
+            }
+
+            for (j = 0; j < TemporalId; j++)
+              pt->du_cpb_removal_delay_increment_minus1[i][j] =
+                  pt->du_cpb_removal_delay_increment_minus1[i]
+                  [bp.max_sublayers_minus1];
+          }
+      }
+    }
+
+    if (bp.additional_concatenation_info_present_flag)
+      READ_UINT8 (nr, pt->delay_for_concatenation_ensured_flag, 1);
+
+    READ_UINT8 (nr, pt->display_elemental_periods_minus1, 8);
+  }
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Picture timing\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+static GstH266ParserResult
+gst_h266_parser_parse_du_info (GstH266DUInfo * dui, NalReader * nr,
+    const GstH266BufferingPeriod bp, guint8 TemporalId)
+{
+  guint i;
+
+  GST_DEBUG ("parsing \"DU info\"");
+
+  READ_UE (nr, dui->decoding_unit_idx);
+
+  if (!bp.du_cpb_params_in_pic_timing_sei_flag) {
+    for (i = TemporalId; i <= bp.max_sublayers_minus1; i++) {
+      if (i < bp.max_sublayers_minus1)
+        READ_UINT8 (nr, dui->sublayer_delays_present_flag[i], 1);
+
+      if (dui->sublayer_delays_present_flag[i])
+        READ_UINT8 (nr, dui->du_cpb_removal_delay_increment[i],
+            bp.du_cpb_removal_delay_increment_length_minus1 + 1);
+    }
+  }
+
+  if (!bp.du_cpb_params_in_pic_timing_sei_flag)
+    dui->sublayer_delays_present_flag[bp.max_sublayers_minus1] = 1;
+
+  for (i = 0; i <= bp.max_sublayers_minus1; i++) {
+    if (i < bp.max_sublayers_minus1)
+      dui->du_cpb_removal_delay_increment[i] =
+          dui->du_cpb_removal_delay_increment[bp.max_sublayers_minus1];
+  }
+
+  if (!bp.du_dpb_params_in_pic_timing_sei_flag)
+    READ_UINT8 (nr, dui->dpb_output_du_delay_present_flag, 1);
+  if (dui->dpb_output_du_delay_present_flag)
+    READ_UINT8 (nr, dui->dpb_output_du_delay,
+        bp.dpb_output_delay_du_length_minus1 + 1);
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"DU info\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+static GstH266ParserResult
+gst_h266_parser_parse_scalable_nesting (GstH266ScalableNesting * sn,
+    NalReader * nr)
+{
+  guint i;
+
+  GST_DEBUG ("parsing \"Scalable nesting\"");
+  /* check: max values here are not right */
+
+  READ_UINT8 (nr, sn->ols_flag, 1);
+  READ_UINT8 (nr, sn->subpic_flag, 1);
+  if (sn->ols_flag) {
+    READ_UE_MAX (nr, sn->num_olss_minus1, GST_H266_MAX_TOTAL_NUM_OLSS - 1);
+    for (i = 0; i <= sn->num_olss_minus1; i++)
+      READ_UE_MAX (nr, sn->ols_idx_delta_minus1[i],
+          GST_H266_MAX_TOTAL_NUM_OLSS - 2);
+  } else {
+    READ_UINT8 (nr, sn->all_layers_flag, 1);
+    if (!sn->all_layers_flag) {
+      READ_UE_MAX (nr, sn->num_layers_minus1, GST_H266_MAX_LAYERS);
+      for (i = 1; i <= sn->num_layers_minus1; i++)
+        READ_UINT8 (nr, sn->layer_id[i], 6);
+    }
+  }
+
+  if (sn->subpic_flag) {
+    READ_UE_MAX (nr, sn->num_subpics_minus1, GST_H266_MAX_SLICES_PER_AU - 1);
+    READ_UE_MAX (nr, sn->subpic_id_len_minus1, 15);
+    for (i = 0; i <= sn->num_subpics_minus1; i++)
+      READ_UINT8 (nr, sn->subpic_id[i], sn->subpic_id_len_minus1 + 1);
+  }
+
+  READ_UE_MAX (nr, sn->num_seis_minus1, 63);
+
+  while (!nal_reader_is_byte_aligned (nr))
+    if (!nal_reader_skip (nr, 1))
+      goto error;
+  /* not implemented yet
+     for( i = 0; i <= sn->num_seis_minus1; i++ )
+     sei_message()
+   */
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Scalable nesting\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+static GstH266ParserResult
+gst_h266_parser_parse_subpic_level_info (GstH266SubPicLevelInfo * sli,
+    NalReader * nr)
+{
+  guint i, j, k;
+
+  GST_DEBUG ("parsing \"Subpic level info\"");
+
+  READ_UINT8 (nr, sli->num_ref_levels_minus1, 3);
+  READ_UINT8 (nr, sli->cbr_constraint_flag, 1);
+
+  READ_UINT8 (nr, sli->explicit_fraction_present_flag, 1);
+  if (sli->explicit_fraction_present_flag)
+    READ_UE_MAX (nr, sli->num_subpics_minus1, GST_H266_MAX_SLICES_PER_AU - 1);
+
+  READ_UINT8 (nr, sli->max_sublayers_minus1, 3);
+  READ_UINT8 (nr, sli->sublayer_info_present_flag, 1);
+
+  while (!nal_reader_is_byte_aligned (nr))
+    if (!nal_reader_skip (nr, 1))
+      goto error;
+
+  for (k = sli->sublayer_info_present_flag ? 0 : sli->max_sublayers_minus1;
+      k <= sli->max_sublayers_minus1; k++) {
+    for (i = 0; i <= sli->num_ref_levels_minus1; i++) {
+      READ_UINT8 (nr, sli->non_subpic_layers_fraction[i][k], 8);
+      READ_UINT8 (nr, sli->ref_level_idc[i][k], 8);
+
+      if (sli->explicit_fraction_present_flag) {
+        for (j = 0; j <= sli->num_subpics_minus1; j++)
+          READ_UINT8 (nr, sli->ref_level_fraction_minus1[i][j][k], 8);
+      }
+    }
+  }
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Subpic level info\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+static GstH266ParserResult
+gst_h266_parser_parse_frame_field_info (GstH266FrameFieldInfo * ffi,
+    NalReader * nr)
+{
+  GST_DEBUG ("parsing \"Frame field info\"");
+
+  READ_UINT8 (nr, ffi->field_pic_flag, 1);
+  if (ffi->field_pic_flag) {
+    READ_UINT8 (nr, ffi->bottom_field_flag, 1);
+    READ_UINT8 (nr, ffi->pairing_indicated_flag, 1);
+    if (ffi->pairing_indicated_flag)
+      READ_UINT8 (nr, ffi->paired_with_next_field_flag, 1);
+  } else {
+    READ_UINT8 (nr, ffi->display_fields_from_frame_flag, 1);
+    if (ffi->display_fields_from_frame_flag)
+      READ_UINT8 (nr, ffi->top_field_first_flag, 1);
+
+    READ_UINT8 (nr, ffi->display_elemental_periods_minus1, 8);
+  }
+
+  READ_UINT8 (nr, ffi->source_scan_type, 2);
+  READ_UINT8 (nr, ffi->duplicate_flag, 1);
+
+  ffi->valid = TRUE;
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Frame field info\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+/**
+ * gst_h266_parser_new:
+ *
+ * Creates a new #GstH266Parser. It should be freed with
+ * gst_h266_parser_free after use.
+ *
+ * Returns: a new #GstH266Parser
+ */
+GstH266Parser *
+gst_h266_parser_new (void)
+{
+  GstH266Parser *parser;
+
+  parser = g_new0 (GstH266Parser, 1);
+
+  return parser;
+}
+
+/**
+ * gst_h266_parser_free:
+ * @parser: the #GstH266Parser to free
+ *
+ * Frees @parser and sets it to %NULL
+ */
+void
+gst_h266_parser_free (GstH266Parser * parser)
+{
+  g_slice_free (GstH266Parser, parser);
+  parser = NULL;
+}
+
+/**
+ * gst_h266_parser_identify_nalu_unchecked:
+ * @parser: a #GstH266Parser
+ * @data: The data to parse
+ * @offset: the offset from which to parse @data
+ * @size: the size of @data
+ * @nalu: The #GstH266NalUnit where to store parsed nal headers
+ *
+ * Parses @data and fills @nalu from the next nalu data from @data.
+ *
+ * This differs from @gst_h266_parser_identify_nalu in that it doesn't
+ * check whether the packet is complete or not.
+ *
+ * Note: Only use this function if you already know the provided @data
+ * is a complete NALU, else use @gst_h266_parser_identify_nalu.
+ *
+ * Returns: a #GstH266ParserResult
+ */
+GstH266ParserResult
+gst_h266_parser_identify_nalu_unchecked (GstH266Parser * parser,
+    const guint8 * data, guint offset, gsize size, GstH266NalUnit * nalu)
+{
+  gint off1;
+
+  memset (nalu, 0, sizeof (*nalu));
+
+  if (size < offset + 4) {
+    GST_DEBUG ("Can't parse, buffer has too small size %" G_GSIZE_FORMAT
+        ", offset %u", size, offset);
+    return GST_H266_PARSER_ERROR;
+  }
+
+  off1 = scan_for_start_codes (data + offset, size - offset);
+
+  if (off1 < 0) {
+    GST_DEBUG ("No start code prefix in this buffer");
+    return GST_H266_PARSER_NO_NAL;
+  }
+
+  nalu->sc_offset = offset + off1;
+
+  /* The scanner ensures one byte passed the start code but to
+   * identify an VVC NAL, we need 2. */
+  if (size - nalu->sc_offset - 3 < 2) {
+    GST_DEBUG ("Not enough bytes after start code to identify");
+    return GST_H266_PARSER_NO_NAL;
+  }
+
+  /* sc might have 2 or 3 0-bytes */
+  if (nalu->sc_offset > 0 && data[nalu->sc_offset - 1] == 00)
+    nalu->sc_offset--;
+
+  nalu->offset = offset + off1 + 3;
+  nalu->data = (guint8 *) data;
+  nalu->size = size - nalu->offset;
+
+  if (!gst_h266_parse_nalu_header (nalu)) {
+    GST_WARNING ("error parsing \"NAL unit header\"");
+    nalu->size = 0;
+    return GST_H266_PARSER_BROKEN_DATA;
+  }
+
+  nalu->valid = TRUE;
+
+  if (nalu->type == GST_H266_NAL_EOS || nalu->type == GST_H266_NAL_EOB) {
+    GST_DEBUG ("end-of-seq or end-of-stream nal found");
+    nalu->size = 2;
+    return GST_H266_PARSER_OK;
+  }
+
+  return GST_H266_PARSER_OK;
+}
+
+/**
+ * gst_h266_parser_identify_nalu:
+ * @parser: a #GstH266Parser
+ * @data: The data to parse
+ * @offset: the offset from which to parse @data
+ * @size: the size of @data
+ * @nalu: The #GstH266NalUnit where to store parsed nal headers
+ *
+ * Parses @data and fills @nalu from the next nalu data from @data
+ *
+ * Returns: a #GstH266ParserResult
+ */
+GstH266ParserResult
+gst_h266_parser_identify_nalu (GstH266Parser * parser,
+    const guint8 * data, guint offset, gsize size, GstH266NalUnit * nalu)
+{
+  GstH266ParserResult res;
+  gint off2;
+
+  res = gst_h266_parser_identify_nalu_unchecked (parser, data,
+      offset, size, nalu);
+
+  if (res != GST_H266_PARSER_OK)
+    goto beach;
+
+  /* The two NALs are exactly 2 bytes size and are placed at the end of an AU,
+   * there is no need to wait for the following */
+  if (nalu->type == GST_H266_NAL_EOS || nalu->type == GST_H266_NAL_EOB)
+    goto beach;
+
+  off2 = scan_for_start_codes (data + nalu->offset, size - nalu->offset);
+  if (off2 < 0) {
+    GST_DEBUG ("Nal start %d, No end found", nalu->offset);
+    return GST_H266_PARSER_NO_NAL_END;
+  }
+
+  /* Callers assumes that enough data will available to identify the next NAL,
+   * but scan_for_start_codes() only ensure 1 extra byte is available. Ensure
+   * we have the required two header bytes (3 bytes start code and 2 byte
+   * header). */
+  if (size - (nalu->offset + off2) < 5) {
+    GST_DEBUG ("Not enough bytes identify the next NAL.");
+    return GST_H266_PARSER_NO_NAL_END;
+  }
+
+  /* Mini performance improvement:
+   * We could have a way to store how many 0s were skipped to avoid
+   * parsing them again on the next NAL */
+  while (off2 > 0 && data[nalu->offset + off2 - 1] == 00)
+    off2--;
+
+  nalu->size = off2;
+  if (nalu->size < 3)
+    return GST_H266_PARSER_BROKEN_DATA;
+
+  GST_DEBUG ("Complete nal found. Off: %d, Size: %d", nalu->offset, nalu->size);
+
+beach:
+  return res;
+}
+
+GstH266ParserResult
+gst_h266_parser_identify_nalu_vvc (GstH266Parser * parser,
+    const guint8 * data, guint offset, gsize size, guint8 nal_length_size,
+    GstH266NalUnit * nalu)
+{
+  GstBitReader br;
+
+  memset (nalu, 0, sizeof (*nalu));
+
+  /* Would overflow guint below otherwise: the callers needs to ensure that
+   * this never happens */
+  if (offset > G_MAXUINT32 - nal_length_size) {
+    GST_WARNING ("offset + nal_length_size overflow");
+    nalu->size = 0;
+    return GST_H266_PARSER_BROKEN_DATA;
+  }
+
+  if (size < offset + nal_length_size) {
+    GST_DEBUG ("Can't parse, buffer has too small size %" G_GSIZE_FORMAT
+        ", offset %u", size, offset);
+    return GST_H266_PARSER_ERROR;
+  }
+
+  size = size - offset;
+  gst_bit_reader_init (&br, data + offset, size);
+
+  nalu->size = gst_bit_reader_get_bits_uint32_unchecked (&br,
+      nal_length_size * 8);
+  nalu->sc_offset = offset;
+  nalu->offset = offset + nal_length_size;
+
+  if (nalu->size > G_MAXUINT32 - nal_length_size) {
+    GST_WARNING ("NALU size + nal_length_size overflow");
+    nalu->size = 0;
+    return GST_H266_PARSER_BROKEN_DATA;
+  }
+
+  if (size < (gsize) nalu->size + nal_length_size) {
+    nalu->size = 0;
+
+    return GST_H266_PARSER_NO_NAL_END;
+  }
+
+  nalu->data = (guint8 *) data;
+
+  if (!gst_h266_parse_nalu_header (nalu)) {
+    GST_WARNING ("error parsing \"NAL unit header\"");
+    nalu->size = 0;
+    return GST_H266_PARSER_BROKEN_DATA;
+  }
+
+  if (nalu->size < 2)
+    return GST_H266_PARSER_BROKEN_DATA;
+
+  nalu->valid = TRUE;
+
+  return GST_H266_PARSER_OK;
+}
+
+/**
+ * gst_h266_parser_parse_nal:
+ * @parser: a #GstH266Parser
+ * @nalu: The #GstH266NalUnit to parse
+ *
+ * This function should be called in the case one doesn't need to
+ * parse a specific structure. It is necessary to do so to make
+ * sure @parser is up to date.
+ *
+ * Returns: a #GstH266ParserResult
+ */
+GstH266ParserResult
+gst_h266_parser_parse_nal (GstH266Parser * parser, GstH266NalUnit * nalu)
+{
+  GstH266VPS vps;
+  GstH266SPS sps;
+  GstH266PPS pps;
+  GstH266APS aps;
+
+  switch (nalu->type) {
+    case GST_H266_NAL_VPS:
+      return gst_h266_parser_parse_vps (parser, nalu, &vps);
+      break;
+    case GST_H266_NAL_SPS:
+      return gst_h266_parser_parse_sps (parser, nalu, &sps, FALSE);
+      break;
+    case GST_H266_NAL_PPS:
+      return gst_h266_parser_parse_pps (parser, nalu, &pps);
+      break;
+    case GST_H266_NAL_PREFIX_APS:
+    case GST_H266_NAL_SUFFIX_APS:
+      return gst_h266_parser_parse_aps (parser, nalu, &aps);
+      break;
+    default:
+      break;
+  }
+
+  return GST_H266_PARSER_OK;
+}
+
+/**
+ * gst_h266_parser_parse_vps:
+ * @parser: a #GstH266Parser
+ * @nalu: The #GST_H266_NAL_VPS #GstH266NalUnit to parse
+ * @vps: The #GstH266VPS to fill.
+ *
+ * Parses @data, and fills the @vps structure.
+ *
+ * Returns: a #GstH266ParserResult
+ */
+GstH266ParserResult
+gst_h266_parser_parse_vps (GstH266Parser * parser, GstH266NalUnit * nalu,
+    GstH266VPS * vps)
+{
+  GstH266ParserResult res = gst_h266_parse_vps (nalu, vps);
+
+  if (res == GST_H266_PARSER_OK) {
+    GST_DEBUG ("adding video parameter set with id: %d to array", vps->vps_id);
+
+    if (parser->active_vps && parser->active_vps->vps_id == vps->vps_id)
+      parser->active_vps = NULL;
+
+    parser->vps[vps->vps_id] = *vps;
+    parser->last_vps = &parser->vps[vps->vps_id];
+  }
+
+  return res;
+}
+
+static gboolean
+gst_h266_parser_derive_output_layer_sets (GstH266VPS * vps)
+{
+  guint8 dependency_flag[GST_H266_MAX_LAYERS][GST_H266_MAX_LAYERS];
+  guint reference_layer_idx[GST_H266_MAX_LAYERS][GST_H266_MAX_LAYERS];
+  guint layer_included_in_ols_flag[GST_H266_MAX_TOTAL_NUM_OLSS]
+      [GST_H266_MAX_LAYERS];
+  guint num_ref_layers[GST_H266_MAX_LAYERS];
+  guint8 output_layer_idx[GST_H266_MAX_TOTAL_NUM_OLSS][GST_H266_MAX_LAYERS];
+  guint8 layer_used_as_ref_layer_flag[GST_H266_MAX_LAYERS];
+  guint8 layer_used_as_output_layer_flag[GST_H266_MAX_LAYERS];
+  guint i, j, m, r;
+  gint k;
+
+  GST_DEBUG ("deriving output layer sets");
+
+  if (vps->max_layers_minus1 == 0) {
+    g_assert (vps->total_num_olss == 1);
+    vps->num_multi_layer_olss = 0;
+    return TRUE;
+  }
+
+  memset (dependency_flag, 0, sizeof (dependency_flag));
+  memset (reference_layer_idx, 0, sizeof (reference_layer_idx));
+  memset (layer_included_in_ols_flag, 0, sizeof (layer_included_in_ols_flag));
+  memset (num_ref_layers, 0, sizeof (num_ref_layers));
+  memset (output_layer_idx, 0, sizeof (output_layer_idx));
+  memset (layer_used_as_ref_layer_flag,
+      0, sizeof (layer_used_as_ref_layer_flag));
+  memset (layer_used_as_output_layer_flag,
+      0, sizeof (layer_used_as_output_layer_flag));
+
+  /* 7.4.3.3 vps_direct_ref_layer_flag section */
+  for (i = 0; i <= vps->max_layers_minus1; i++) {
+    for (j = 0; j <= vps->max_layers_minus1; j++) {
+      dependency_flag[i][j] = vps->direct_ref_layer_flag[i][j];
+
+      for (k = 0; k < i; k++) {
+        if (vps->direct_ref_layer_flag[i][k] && dependency_flag[k][j])
+          dependency_flag[i][j] = 1;
+      }
+
+      if (vps->direct_ref_layer_flag[i][j])
+        layer_used_as_ref_layer_flag[j] = 1;
+    }
+  }
+
+  for (i = 0; i <= vps->max_layers_minus1; i++) {
+    for (j = 0, r = 0; j <= vps->max_layers_minus1; j++) {
+      if (dependency_flag[i][j])
+        reference_layer_idx[i][r++] = j;
+    }
+
+    num_ref_layers[i] = r;
+  }
+
+  /* 7.4.3.3 vps_ols_output_layer_flag section */
+  vps->num_output_layers_in_ols[0] = 1;
+  vps->num_sub_layers_in_layer_in_ols[0][0] =
+      vps->ptl_max_tid[vps->ols_ptl_idx[0]] + 1;
+
+  layer_used_as_output_layer_flag[0] = 1;
+  for (i = 1; i <= vps->max_layers_minus1; i++) {
+    if (vps->each_layer_is_an_ols_flag || vps->ols_mode_idc < 2)
+      layer_used_as_output_layer_flag[i] = 1;
+    else
+      layer_used_as_output_layer_flag[i] = 0;
+  }
+
+  for (i = 1; i < vps->total_num_olss; i++) {
+    if (vps->each_layer_is_an_ols_flag || vps->ols_mode_idc == 0) {
+      vps->num_output_layers_in_ols[i] = 1;
+      vps->output_layer_id_in_ols[i][0] = vps->layer_id[i];
+
+      if (vps->each_layer_is_an_ols_flag) {
+        vps->num_sub_layers_in_layer_in_ols[i][0] =
+            vps->ptl_max_tid[vps->ols_ptl_idx[i]] + 1;
+      } else {
+        vps->num_sub_layers_in_layer_in_ols[i][i] =
+            vps->ptl_max_tid[vps->ols_ptl_idx[i]] + 1;
+
+        for (k = i - 1; k >= 0; k--) {
+          vps->num_sub_layers_in_layer_in_ols[i][k] = 0;
+
+          for (m = k + 1; m <= i; m++) {
+            guint8 max_sublayer_needed =
+                MIN (vps->num_sub_layers_in_layer_in_ols[i][m],
+                vps->max_tid_il_ref_pics_plus1[m][k]);
+
+            if (vps->direct_ref_layer_flag[m][k] &&
+                vps->num_sub_layers_in_layer_in_ols[i][k] < max_sublayer_needed)
+              vps->num_sub_layers_in_layer_in_ols[i][k] = max_sublayer_needed;
+          }
+        }
+      }
+    } else if (vps->ols_mode_idc == 1) {
+      vps->num_output_layers_in_ols[i] = i + 1;
+
+      for (j = 0; j < vps->num_output_layers_in_ols[i]; j++) {
+        vps->output_layer_id_in_ols[i][j] = vps->layer_id[j];
+        vps->num_sub_layers_in_layer_in_ols[i][j] =
+            vps->ptl_max_tid[vps->ols_ptl_idx[i]] + 1;
+      }
+    } else if (vps->ols_mode_idc == 2) {
+      gint8 highest_included_layer = 0;
+
+      for (j = 0; j <= vps->max_layers_minus1; j++)
+        vps->num_sub_layers_in_layer_in_ols[i][j] = 0;
+
+      j = 0;
+      for (k = 0; k <= vps->max_layers_minus1; k++) {
+        if (vps->ols_output_layer_flag[i][k]) {
+          layer_included_in_ols_flag[i][k] = 1;
+          highest_included_layer = k;
+          layer_used_as_output_layer_flag[k] = 1;
+          output_layer_idx[i][j] = k;
+          vps->output_layer_id_in_ols[i][j] = vps->layer_id[j];
+          j++;
+          vps->num_sub_layers_in_layer_in_ols[i][k] =
+              vps->ptl_max_tid[vps->ols_ptl_idx[i]] + 1;
+        }
+      }
+
+      vps->num_output_layers_in_ols[i] = j;
+      for (j = 0; j < vps->num_output_layers_in_ols[i]; j++) {
+        gint idx = output_layer_idx[i][j];
+
+        for (k = 0; k < num_ref_layers[idx]; k++)
+          layer_included_in_ols_flag[i][reference_layer_idx[idx][k]] = 1;
+      }
+
+      for (k = highest_included_layer - 1; k >= 0; k--) {
+        if (layer_included_in_ols_flag[i][k]
+            && !vps->ols_output_layer_flag[i][k]) {
+          for (m = k + 1; m <= highest_included_layer; m++) {
+            guint max_sublayer_needed =
+                MIN (vps->num_sub_layers_in_layer_in_ols[i][m],
+                vps->max_tid_il_ref_pics_plus1[m][k]);
+
+            if (vps->direct_ref_layer_flag[m][k] &&
+                layer_included_in_ols_flag[i][m] &&
+                vps->num_sub_layers_in_layer_in_ols[i][k] < max_sublayer_needed)
+              vps->num_sub_layers_in_layer_in_ols[i][k] = max_sublayer_needed;
+          }
+        }
+      }
+    }
+  }
+
+  for (i = 0; i <= vps->max_layers_minus1; i++) {
+    if (layer_used_as_ref_layer_flag[i] == 0 &&
+        layer_used_as_output_layer_flag[i] == 0) {
+      GST_WARNING ("There shall be no layer that is neither an output"
+          " layer nor a direct reference layer");
+      return FALSE;
+    }
+  }
+
+  vps->num_layers_in_ols[0] = 1;
+  vps->layer_id_in_ols[0][0] = vps->layer_id[0];
+  vps->num_multi_layer_olss = 0;
+  for (i = 1; i < vps->total_num_olss; i++) {
+    if (vps->each_layer_is_an_ols_flag) {
+      vps->num_layers_in_ols[i] = 1;
+      vps->layer_id_in_ols[i][0] = vps->layer_id[i];
+    } else if (vps->ols_mode_idc == 0 || vps->ols_mode_idc == 1) {
+      vps->num_layers_in_ols[i] = i + 1;
+
+      for (j = 0; j < vps->num_layers_in_ols[i]; j++)
+        vps->layer_id_in_ols[i][j] = vps->layer_id[j];
+    } else if (vps->ols_mode_idc == 2) {
+      j = 0;
+      for (k = 0; k <= vps->max_layers_minus1; k++) {
+        if (layer_included_in_ols_flag[i][k]) {
+          vps->layer_id_in_ols[i][j] = vps->layer_id[k];
+          j++;
+        }
+      }
+      vps->num_layers_in_ols[i] = j;
+    }
+
+    if (vps->num_layers_in_ols[i] > 1) {
+      vps->multi_layer_ols_idx[i] = vps->num_multi_layer_olss;
+      vps->num_multi_layer_olss++;
+    }
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_h266_parser_check_vps (GstH266VPS * vps)
+{
+  guint index;
+  guint olsIdx, olsTimingHrdIdx, olsPtlIdx, olsDpbParamsIdx;
+
+  for (index = 0; index < vps->num_multi_layer_olss; index++) {
+    olsIdx = vps->multi_layer_ols_idx[index];
+    olsTimingHrdIdx = vps->ols_timing_hrd_idx[index];
+    olsPtlIdx = vps->ols_ptl_idx[olsIdx];
+
+    if (vps->hrd_max_tid[olsTimingHrdIdx] < vps->ptl_max_tid[olsPtlIdx]) {
+      GST_WARNING ("The value of vps_hrd_max_tid[vps_ols_timing_hrd_idx[m]] "
+          "shall be greater than or equal to "
+          "vps_ptl_max_tid[vps_ols_ptl_idx[n]] for each m-th multi-layer "
+          "OLS for m from 0 to NumMultiLayerOlss - 1, inclusive, and n "
+          "being the OLS index of the m-th multi-layer OLS among all OLSs.");
+      return FALSE;
+    }
+
+    olsDpbParamsIdx = vps->ols_dpb_params_idx[olsIdx];
+    if (vps->dpb_max_tid[olsDpbParamsIdx] < vps->ptl_max_tid[olsPtlIdx]) {
+      GST_WARNING ("The value of vps_dpb_max_tid[vps_ols_dpb_params_idx[m]] "
+          "shall be greater than or equal to "
+          "vps_ptl_max_tid[vps_ols_ptl_idx[n]] for each m-th multi-layer "
+          "OLS for m from 0 to NumMultiLayerOlss - 1, inclusive, and n "
+          "being the OLS index of the m-th multi-layer OLS among all OLSs.");
+      return FALSE;
+    }
+  }
+
+  return TRUE;
+}
+
+/**
+ * gst_h266_parse_vps:
+ * @nalu: The #GST_H266_NAL_VPS #GstH266NalUnit to parse
+ * @vps: The #GstH266VPS to fill.
+ *
+ * Parses @data, and fills the @vps structure.
+ *
+ * Returns: a #GstH266ParserResult
+ *
+ * Since: 1.24
+ */
+GstH266ParserResult
+gst_h266_parse_vps (GstH266NalUnit * nalu, GstH266VPS * vps)
+{
+  NalReader nr;
+  gint i, j;
+  gboolean isPTLReferred[GST_H266_MAX_PTLS];
+
+  GST_DEBUG ("parsing \"Video parameter set\"");
+
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+
+  memset (vps, 0, sizeof (*vps));
+  memset (isPTLReferred, 0, sizeof (isPTLReferred));
+
+  READ_UINT8 (&nr, vps->vps_id, 4);
+  if (vps->vps_id == 0) {
+    GST_WARNING ("vps_id equal to zero is reserved and shall"
+        " not be used in a bitstream");
+    goto error;
+  }
+
+  READ_UINT8 (&nr, vps->max_layers_minus1, 6);
+  if (vps->max_layers_minus1 == 0)
+    vps->each_layer_is_an_ols_flag = 1;
+
+  READ_UINT8 (&nr, vps->max_sublayers_minus1, 3);
+  CHECK_ALLOWED_MAX (vps->max_sublayers_minus1, GST_H266_MAX_SUBLAYERS - 1);
+  if (vps->max_layers_minus1 > 0 && vps->max_sublayers_minus1 > 0) {
+    READ_UINT8 (&nr, vps->default_ptl_dpb_hrd_max_tid_flag, 1);
+  } else
+    vps->default_ptl_dpb_hrd_max_tid_flag = 1;
+
+  if (vps->max_layers_minus1 > 0) {
+    READ_UINT8 (&nr, vps->all_independent_layers_flag, 1);
+    if (vps->all_independent_layers_flag == 0)
+      vps->each_layer_is_an_ols_flag = 0;
+  } else
+    vps->all_independent_layers_flag = 1;
+
+  for (i = 0; i <= vps->max_layers_minus1; i++) {
+    READ_UINT8 (&nr, vps->layer_id[i], 6);
+    /* 7.4.3.2: For any two non-negative integer values of m and n,
+       when m is less than n, the value of vps_layer_id[ m ] shall be
+       less than vps_layer_id[ n ]. */
+    if (i > 0 && vps->layer_id[i] <= vps->layer_id[i - 1]) {
+      GST_WARNING ("vps_layer_id[%d](%d) should > vps_layer_id[%d](%d).\n",
+          i, vps->layer_id[i], i - 1, vps->layer_id[i - 1]);
+      goto error;
+    }
+
+    if (i > 0 && !vps->all_independent_layers_flag) {
+      guint count = 0;
+
+      READ_UINT8 (&nr, vps->independent_layer_flag[i], 1);
+      if (!vps->independent_layer_flag[i]) {
+        READ_UINT8 (&nr, vps->max_tid_ref_present_flag[i], 1);
+
+        for (j = 0; j < i; j++) {
+          READ_UINT8 (&nr, vps->direct_ref_layer_flag[i][j], 1);
+          if (vps->direct_ref_layer_flag[i][j])
+            count++;
+
+          if (vps->max_tid_ref_present_flag[i]
+              && vps->direct_ref_layer_flag[i][j]) {
+            READ_UINT8 (&nr, vps->max_tid_il_ref_pics_plus1[i][j], 3);
+          } else {
+            vps->max_tid_il_ref_pics_plus1[i][j] =
+                vps->max_sublayers_minus1 + 1;
+          }
+        }
+
+        if (count == 0) {
+          GST_WARNING ("There has to be at least one value of j such "
+              "that the value of vps_direct_dependency_flag[%d][j] is "
+              "equal to 1, when vps_independent_layer_flag[%d] is equal "
+              "to 0", i, i);
+          goto error;
+        }
+      }
+    } else {
+      vps->independent_layer_flag[i] = 1;
+    }
+  }
+
+  if (vps->max_layers_minus1 > 0) {
+    if (vps->all_independent_layers_flag)
+      READ_UINT8 (&nr, vps->each_layer_is_an_ols_flag, 1);
+
+    if (!vps->each_layer_is_an_ols_flag) {
+      if (!vps->all_independent_layers_flag) {
+        READ_UINT8 (&nr, vps->ols_mode_idc, 2);
+        CHECK_ALLOWED (vps->ols_mode_idc, 0, 2);
+      } else
+        vps->ols_mode_idc = 2;
+
+      if (vps->ols_mode_idc == 2) {
+        READ_UINT8 (&nr, vps->num_output_layer_sets_minus2, 8);
+        for (i = 1; i <= vps->num_output_layer_sets_minus2 + 1; i++)
+          for (j = 0; j <= vps->max_layers_minus1; j++)
+            READ_UINT8 (&nr, vps->ols_output_layer_flag[i][j], 1);
+      }
+    }
+
+    if (vps->each_layer_is_an_ols_flag ||
+        vps->ols_mode_idc == 0 || vps->ols_mode_idc == 1) {
+      vps->total_num_olss = vps->max_layers_minus1 + 1;
+    } else if (vps->ols_mode_idc == 2) {
+      vps->total_num_olss = vps->num_output_layer_sets_minus2 + 2;
+    } else {
+      g_assert_not_reached ();
+    }
+
+    READ_UINT8 (&nr, vps->num_ptls_minus1, 8);
+    CHECK_ALLOWED_MAX (vps->num_ptls_minus1, vps->total_num_olss - 1);
+  } else {
+    vps->each_layer_is_an_ols_flag = 1;
+    vps->num_ptls_minus1 = 0;
+    vps->total_num_olss = 1;
+  }
+
+  if (!gst_h266_parser_derive_output_layer_sets (vps)) {
+    GST_WARNING ("Fail to derive vps layer sets parameters");
+    goto error;
+  }
+
+  if (vps->num_ptls_minus1 + 1 > vps->total_num_olss) {
+    GST_WARNING ("The value of vps_num_ptls_minus1 shall"
+        " be less than TotalNumOlss");
+    goto error;
+  }
+
+  for (i = 0; i <= vps->num_ptls_minus1; i++) {
+    if (i > 0) {
+      READ_UINT8 (&nr, vps->pt_present_flag[i], 1);
+    } else
+      vps->pt_present_flag[i] = 1;
+
+    if (!vps->default_ptl_dpb_hrd_max_tid_flag) {
+      READ_UINT8 (&nr, vps->ptl_max_tid[i], 3);
+      CHECK_ALLOWED_MAX (vps->ptl_max_tid[i], vps->max_sublayers_minus1);
+    } else
+      vps->ptl_max_tid[i] = vps->max_sublayers_minus1;
+  }
+
+  while (!nal_reader_is_byte_aligned (&nr))
+    if (!nal_reader_skip (&nr, 1))
+      goto error;
+
+  for (i = 0; i <= vps->num_ptls_minus1; i++) {
+    if (i == 0 && !vps->pt_present_flag[i]) {
+      GST_WARNING ("Profile/Tier should always be present for the first entry");
+      goto error;
+    }
+
+    if (!gst_h266_parse_profile_tier_level (&vps->profile_tier_level[i], &nr,
+            vps->pt_present_flag[i], vps->ptl_max_tid[i]))
+      goto error;
+  }
+
+  for (i = 0; i < vps->total_num_olss; i++) {
+    if (vps->num_ptls_minus1 > 0 &&
+        vps->num_ptls_minus1 + 1 != vps->total_num_olss) {
+      READ_UINT8 (&nr, vps->ols_ptl_idx[i], 8);
+    } else if (vps->num_ptls_minus1 + 1 == vps->total_num_olss)
+      vps->ols_ptl_idx[i] = i;
+    else
+      vps->ols_ptl_idx[i] = 0;
+
+    isPTLReferred[vps->ols_ptl_idx[i]] = TRUE;
+  }
+
+  for (i = 0; i <= vps->num_ptls_minus1; i++) {
+    if (!isPTLReferred[i]) {
+      GST_WARNING ("Each profile_tier_level() syntax structure in the "
+          "VPS shall be referred to by at least one value of "
+          "vps_ols_ptl_idx[i] for i in the range of 0 to TotalNumOlss ? 1, "
+          "inclusive.");
+      goto error;
+    }
+  }
+
+  if (!vps->each_layer_is_an_ols_flag) {
+    READ_UE_MAX (&nr, vps->num_dpb_params_minus1,
+        vps->num_multi_layer_olss - 1);
+
+    if (vps->max_sublayers_minus1 > 0)
+      READ_UINT8 (&nr, vps->sublayer_dpb_params_present_flag, 1);
+
+    for (i = 0; i <= vps->num_dpb_params_minus1; i++) {
+      if (!vps->default_ptl_dpb_hrd_max_tid_flag) {
+        READ_UINT8 (&nr, vps->dpb_max_tid[i], 3);
+        CHECK_ALLOWED_MAX (vps->dpb_max_tid[i], vps->max_sublayers_minus1);
+      } else
+        vps->dpb_max_tid[i] = vps->max_sublayers_minus1;
+
+      if (!gst_h266_parse_dpb_parameters (&vps->dpb[i], &nr,
+              vps->dpb_max_tid[i], vps->sublayer_dpb_params_present_flag))
+        goto error;
+
+      for (j = (vps->sublayer_dpb_params_present_flag ?
+              vps->dpb_max_tid[i] : 0); j < vps->dpb_max_tid[i]; j++) {
+        /* When dpb_max_dec_pic_buffering_minus1[i] is not present for i in
+           the range of 0 to maxSubLayersMinus1 - 1, inclusive, due to
+           subLayerInfoFlag being equal to 0, it is inferred to be equal to
+           dpb_max_dec_pic_buffering_minus1[maxSubLayersMinus1]. */
+        vps->dpb[i].max_dec_pic_buffering_minus1[j] =
+            vps->dpb[i].max_dec_pic_buffering_minus1[vps->dpb_max_tid[i]];
+
+        /* When dpb_max_num_reorder_pics[i] is not present for i in
+           the range of 0 to maxSubLayersMinus1 - 1, inclusive, due to
+           subLayerInfoFlag being equal to 0, it is inferred to be equal
+           to dpb_max_num_reorder_pics[maxSubLayersMinus1]. */
+        vps->dpb[i].max_num_reorder_pics[j] =
+            vps->dpb[i].max_num_reorder_pics[vps->dpb_max_tid[i]];
+
+        /* When dpb_max_latency_increase_plus1[i] is not present for i in
+           the range of 0 to maxSubLayersMinus1 - 1, inclusive, due to
+           subLayerInfoFlag being equal to 0, it is inferred to be equal to
+           dpb_max_latency_increase_plus1[maxSubLayersMinus1]. */
+        vps->dpb[i].max_latency_increase_plus1[j] =
+            vps->dpb[i].max_latency_increase_plus1[vps->dpb_max_tid[i]];
+      }
+    }
+
+    for (i = 0; i < vps->num_multi_layer_olss; i++) {
+      READ_UE_MAX (&nr, vps->ols_dpb_pic_width[i], G_MAXUINT16);
+      READ_UE_MAX (&nr, vps->ols_dpb_pic_height[i], G_MAXUINT16);
+      READ_UINT8 (&nr, vps->ols_dpb_chroma_format[i], 2);
+      READ_UE_MAX (&nr, vps->ols_dpb_bitdepth_minus8[i], 2);
+
+      if (vps->num_dpb_params_minus1 > 0
+          && vps->num_dpb_params_minus1 + 1 != vps->num_multi_layer_olss) {
+        READ_UE_MAX (&nr, vps->ols_dpb_params_idx[i],
+            vps->num_dpb_params_minus1);
+      } else if (vps->num_dpb_params_minus1 == 0)
+        vps->ols_dpb_params_idx[i] = 0;
+      else
+        vps->ols_dpb_params_idx[i] = i;
+    }
+  }
+
+  if (!vps->each_layer_is_an_ols_flag)
+    READ_UINT8 (&nr, vps->timing_hrd_params_present_flag, 1);
+
+  if (vps->timing_hrd_params_present_flag) {
+    gboolean is_dpb_param_referred[GST_H266_MAX_TOTAL_NUM_OLSS];
+
+    memset (is_dpb_param_referred, 0, sizeof (is_dpb_param_referred));
+
+    if (!gst_h266_parse_general_timing_hrd_parameters
+        (&vps->general_hrd_params, &nr))
+      goto error;
+
+    if (vps->max_sublayers_minus1 > 0) {
+      READ_UINT8 (&nr, vps->sublayer_cpb_params_present_flag, 1);
+    } else
+      vps->sublayer_cpb_params_present_flag = 0;
+
+    READ_UE_MAX (&nr, vps->num_ols_timing_hrd_params_minus1,
+        vps->num_multi_layer_olss - 1);
+    for (i = 0; i <= vps->num_ols_timing_hrd_params_minus1; i++) {
+      guint firstSubLayer;
+
+      if (!vps->default_ptl_dpb_hrd_max_tid_flag) {
+        READ_UINT8 (&nr, vps->hrd_max_tid[i], 3);
+        CHECK_ALLOWED_MAX (vps->hrd_max_tid[i], vps->max_sublayers_minus1);
+      } else
+        vps->hrd_max_tid[i] = vps->max_sublayers_minus1;
+
+      firstSubLayer =
+          vps->sublayer_cpb_params_present_flag ? 0 : vps->hrd_max_tid[i];
+
+      if (!gst_h266_parse_ols_timing_hrd_parameters (&vps->ols_hrd_params[i],
+              &nr, &vps->general_hrd_params, firstSubLayer,
+              vps->hrd_max_tid[i]))
+        goto error;
+    }
+    for (i = vps->num_ols_timing_hrd_params_minus1 + 1;
+        i < vps->total_num_olss; i++) {
+      vps->hrd_max_tid[i] = vps->max_sublayers_minus1;
+    }
+
+    for (i = 0; i < vps->num_multi_layer_olss; i++) {
+      if (vps->num_ols_timing_hrd_params_minus1 > 0 &&
+          vps->num_ols_timing_hrd_params_minus1 + 1 !=
+          vps->num_multi_layer_olss) {
+        READ_UE_MAX (&nr, vps->ols_timing_hrd_idx[i],
+            vps->num_ols_timing_hrd_params_minus1);
+      } else if (vps->num_ols_timing_hrd_params_minus1 == 0) {
+        vps->ols_timing_hrd_idx[i] = 0;
+      } else {
+        vps->ols_timing_hrd_idx[i] = i;
+      }
+
+      is_dpb_param_referred[vps->ols_timing_hrd_idx[i]] = TRUE;
+    }
+
+    for (i = 0; i <= vps->num_ols_timing_hrd_params_minus1; i++) {
+      if (!is_dpb_param_referred[i]) {
+        GST_WARNING ("Each vps_ols_timing_hrd_parameters( ) syntax structure "
+            "in the VPS shall be referred to by at least one value of "
+            "vps_ols_timing_hrd_idx[i] for i in the range of 1 to "
+            "NumMultiLayerOlss - 1, inclusive");
+        goto error;
+      }
+    }
+
+  } else {
+    for (int i = 0; i < vps->total_num_olss; i++)
+      vps->hrd_max_tid[i] = vps->max_sublayers_minus1;
+  }
+
+  READ_UINT8 (&nr, vps->extension_flag, 1);
+  if (vps->extension_flag) {
+    GST_WARNING ("extension_flag is not supported in current version VPS.");
+    goto error;
+  }
+
+  if (!gst_h266_parser_check_vps (vps))
+    goto error;
+
+  vps->valid = TRUE;
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Video parameter set\"");
+  vps->valid = FALSE;
+  return GST_H266_PARSER_ERROR;
+}
+
+/**
+ * gst_h266_parser_parse_sps:
+ * @parser: a #GstH266Parser
+ * @nalu: The #GST_H266_NAL_SPS #GstH266NalUnit to parse
+ * @sps: The #GstH266SPS to fill.
+ * @parse_vui_params: Whether to parse the vui_params or not
+ *
+ * Parses @data, and fills the @sps structure.
+ *
+ * Returns: a #GstH266ParserResult
+ *
+ * Since: 1.24
+ */
+GstH266ParserResult
+gst_h266_parser_parse_sps (GstH266Parser * parser, GstH266NalUnit * nalu,
+    GstH266SPS * sps, gboolean parse_vui_params)
+{
+  GstH266ParserResult res =
+      gst_h266_parse_sps (parser, nalu, sps, parse_vui_params);
+
+  if (res == GST_H266_PARSER_OK) {
+    GST_DEBUG ("adding sequence parameter set with id: %d to array",
+        sps->sps_id);
+
+    if (parser->active_sps && parser->active_sps->sps_id == sps->sps_id)
+      parser->active_sps = NULL;
+
+    parser->sps[sps->sps_id] = *sps;
+    parser->last_sps = &parser->sps[sps->sps_id];
+  }
+
+  return res;
+}
+
+/**
+ * gst_h266_parse_sps:
+ * parser: The #GstH266Parser
+ * @nalu: The #GST_H266_NAL_SPS #GstH266NalUnit to parse
+ * @sps: The #GstH266SPS to fill.
+ * @parse_vui_params: Whether to parse the vui_params or not
+ *
+ * Parses @data, and fills the @sps structure.
+ *
+ * Returns: a #GstH266ParserResult
+ *
+ * Since: 1.24
+ */
+GstH266ParserResult
+gst_h266_parse_sps (GstH266Parser * parser, GstH266NalUnit * nalu,
+    GstH266SPS * sps, gboolean parse_vui_params)
+{
+  NalReader nr;
+  GstH266VPS *vps;
+  GstH266ProfileTierLevel *ptl;
+  guint i, j;
+  guint8 ctbLog2SizeY;
+  guint minQT[3] = { 0, 0, 0 };
+  guint maxBTSize[3] = { 0, 0, 0 };
+  guint maxTTSize[3] = { 0, 0, 0 };
+  guint minCbLog2SizeY, minCuSize, MaxNumMergeCand,
+      minQtLog2SizeIntraY, minQtLog2SizeInterY;
+  guint8 sub_width_c, sub_height_c;
+  const guint8 h266_sub_width_c[] = { 1, 2, 2, 1 };
+  const guint8 h266_sub_height_c[] = { 1, 2, 1, 1 };
+
+  GST_DEBUG ("parsing \"Sequence parameter set\"");
+
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+
+  memset (sps, 0, sizeof (*sps));
+  sps->nuh_layer_id = nalu->layer_id;
+
+  READ_UINT8 (&nr, sps->sps_id, 4);
+  READ_UINT8 (&nr, sps->vps_id, 4);
+
+  /* 7.4.3.4: When sps_video_parameter_set_id is equal to 0, SPS
+     does not refer to a VPS.
+     We just make vps[0] as the default vps with default flags,
+     and let the SPS refer to it when vps_id is 0. */
+  if (sps->vps_id == 0) {
+    memset (&parser->vps[0], 0, sizeof (*vps));
+    parser->vps[0].vps_id = 0;
+
+    parser->vps[0].max_layers_minus1 = 0;
+    /* 7.4.3.4:
+       The value of GeneralLayerIdx[nuh_layer_id] is set equal to 0.
+       The value of vps_independent_layer_flag[GeneralLayerIdx[nuh_layer_id]]
+       is inferred to be equal to 1.
+       The value of TotalNumOlss is set equal to 1,
+       the value of NumLayersInOls[0] is set equal to 1, and value of
+       vps_layer_id[0] is inferred to be equal to the value of nuh_layer_id
+       of all the VCL NAL units, and the value of LayerIdInOls[0][0]
+       is set equal to vps_layer_id[0]. */
+    parser->vps[0].independent_layer_flag[0] = 1;
+    parser->vps[0].total_num_olss = 1;
+    parser->vps[0].num_layers_in_ols[0] = 1;
+    parser->vps[0].layer_id[0] = sps->nuh_layer_id;
+    parser->vps[0].layer_id_in_ols[0][0] = parser->vps[0].layer_id[0];
+    parser->vps[0].valid = TRUE;
+
+    vps = &parser->vps[0];
+  } else {
+    vps = gst_h266_parser_get_vps (parser, sps->vps_id);
+    if (!vps) {
+      GST_DEBUG ("couldn't find associated video parameter set with id: %d",
+          sps->vps_id);
+    }
+  }
+  sps->vps = vps;
+
+  READ_UINT8 (&nr, sps->max_sublayers_minus1, 3);
+  CHECK_ALLOWED_MAX (sps->max_sublayers_minus1, GST_H266_MAX_SUBLAYERS - 1);
+
+  READ_UINT8 (&nr, sps->chroma_format_idc, 2);
+
+  READ_UINT8 (&nr, sps->log2_ctu_size_minus5, 2);
+  CHECK_ALLOWED_MAX (sps->log2_ctu_size_minus5, 2);
+  ctbLog2SizeY = sps->log2_ctu_size_minus5 + 5;
+  sps->ctu_size = 1 << ctbLog2SizeY;
+
+  READ_UINT8 (&nr, sps->ptl_dpb_hrd_params_present_flag, 1);
+  if (!sps->vps_id && !sps->ptl_dpb_hrd_params_present_flag) {
+    GST_WARNING ("When vps_id is equal to 0, the value of "
+        "ptl_dpb_hrd_params_present_flag shall be equal to 1");
+    goto error;
+  }
+
+  if (sps->ptl_dpb_hrd_params_present_flag) {
+    if (!gst_h266_parse_profile_tier_level (&sps->profile_tier_level, &nr,
+            1, sps->max_sublayers_minus1))
+      goto error;
+  }
+
+  ptl = &sps->profile_tier_level;
+
+  READ_UINT8 (&nr, sps->gdr_enabled_flag, 1);
+  if (ptl->general_constraints_info.no_gdr_constraint_flag
+      && sps->gdr_enabled_flag) {
+    GST_WARNING ("When gci_no_gdr_constraint_flag equal to 1 , "
+        "the value of gdr_enabled_flag shall be equal to 0");
+    goto error;
+  }
+
+  READ_UINT8 (&nr, sps->ref_pic_resampling_enabled_flag, 1);
+  if (ptl->general_constraints_info.no_ref_pic_resampling_constraint_flag
+      && sps->ref_pic_resampling_enabled_flag) {
+    GST_WARNING ("When gci_no_ref_pic_resampling_constraint_flag is "
+        "equal to 1, ref_pic_resampling_enabled_flag shall be equal to 0");
+    goto error;
+  }
+
+  if (sps->ref_pic_resampling_enabled_flag)
+    READ_UINT8 (&nr, sps->res_change_in_clvs_allowed_flag, 1);
+
+  if (ptl->general_constraints_info.no_res_change_in_clvs_constraint_flag
+      && sps->res_change_in_clvs_allowed_flag) {
+    GST_WARNING ("When no_res_change_in_clvs_constraint_flag is equal "
+        "to 1, res_change_in_clvs_allowed_flag shall be equal to 0");
+    goto error;
+  }
+
+  READ_UE_MAX (&nr, sps->pic_width_max_in_luma_samples, GST_H266_MAX_WIDTH);
+  READ_UE_MAX (&nr, sps->pic_height_max_in_luma_samples, GST_H266_MAX_HEIGHT);
+  sub_width_c = h266_sub_width_c[sps->chroma_format_idc];
+  sub_height_c = h266_sub_height_c[sps->chroma_format_idc];
+
+  READ_UINT8 (&nr, sps->conformance_window_flag, 1);
+  if (sps->conformance_window_flag) {
+    guint width, height;
+
+    width = sps->pic_width_max_in_luma_samples / sub_width_c;
+    height = sps->pic_height_max_in_luma_samples / sub_height_c;
+
+    READ_UE_MAX (&nr, sps->conf_win_left_offset, width);
+    READ_UE_MAX (&nr, sps->conf_win_right_offset, width);
+    READ_UE_MAX (&nr, sps->conf_win_top_offset, height);
+    READ_UE_MAX (&nr, sps->conf_win_bottom_offset, height);
+
+    if (sub_width_c * (sps->conf_win_left_offset +
+            sps->conf_win_right_offset) >= sps->pic_width_max_in_luma_samples
+        || sub_height_c * (sps->conf_win_top_offset +
+            sps->conf_win_bottom_offset) >=
+        sps->pic_height_max_in_luma_samples) {
+      GST_WARNING ("Invalid sps conformance window: (%u, %u, %u, %u), "
+          "resolution is %ux%u, sub WxH is %ux%u.\n", sps->conf_win_left_offset,
+          sps->conf_win_right_offset, sps->conf_win_top_offset,
+          sps->conf_win_bottom_offset, sps->pic_width_max_in_luma_samples,
+          sps->pic_height_max_in_luma_samples, sub_width_c, sub_height_c);
+      goto error;
+    }
+  }
+
+  READ_UINT8 (&nr, sps->subpic_info_present_flag, 1);
+  if (ptl->general_constraints_info.no_subpic_info_constraint_flag
+      && sps->subpic_info_present_flag) {
+    GST_WARNING ("When gci_no_subpic_info_constraint_flag is equal to 1, "
+        "the value of subpic_info_present_flag shall be equal to 0");
+    goto error;
+  }
+
+  if (sps->subpic_info_present_flag) {
+    guint32 maxPicWidthInCtus =
+        ((sps->pic_width_max_in_luma_samples - 1) / sps->ctu_size) + 1;
+    guint32 maxPicHeightInCtus =
+        ((sps->pic_height_max_in_luma_samples - 1) / sps->ctu_size) + 1;
+
+    READ_UE_MAX (&nr, sps->num_subpics_minus1, GST_H266_MAX_SLICES_PER_AU - 1);
+    if (sps->num_subpics_minus1 == 0) {
+      sps->subpic_ctu_top_left_x[0] = 0;
+      sps->subpic_ctu_top_left_y[0] = 0;
+      sps->subpic_width_minus1[0] = maxPicWidthInCtus;
+      sps->subpic_height_minus1[0] = maxPicHeightInCtus;
+      sps->independent_subpics_flag = 1;
+      sps->subpic_same_size_flag = 0;
+      sps->subpic_treated_as_pic_flag[0] = 1;
+      sps->loop_filter_across_subpic_enabled_flag[0] = 0;
+    } else {
+      guint32 tmpWidthVal, tmpHeightVal, numSubpicCols;
+
+      READ_UINT8 (&nr, sps->independent_subpics_flag, 1);
+      READ_UINT8 (&nr, sps->subpic_same_size_flag, 1);
+
+      tmpWidthVal = maxPicWidthInCtus;
+      tmpHeightVal = maxPicHeightInCtus;
+      numSubpicCols = 1;
+      for (i = 0; i <= sps->num_subpics_minus1; i++) {
+        if (!sps->subpic_same_size_flag || i == 0) {
+          if (i > 0 && sps->pic_width_max_in_luma_samples > sps->ctu_size) {
+            READ_UINT16 (&nr, sps->subpic_ctu_top_left_x[i],
+                gst_util_ceil_log2 (tmpWidthVal));
+          } else
+            sps->subpic_ctu_top_left_x[i] = 0;
+
+          if (i > 0 && sps->pic_height_max_in_luma_samples > sps->ctu_size) {
+            READ_UINT16 (&nr, sps->subpic_ctu_top_left_y[i],
+                gst_util_ceil_log2 (tmpHeightVal));
+          } else
+            sps->subpic_ctu_top_left_y[i] = 0;
+
+          if (i < sps->num_subpics_minus1
+              && sps->pic_width_max_in_luma_samples > sps->ctu_size) {
+            READ_UINT16 (&nr, sps->subpic_width_minus1[i],
+                gst_util_ceil_log2 (tmpWidthVal));
+          } else
+            sps->subpic_width_minus1[i] =
+                tmpWidthVal - sps->subpic_ctu_top_left_x[i] - 1;
+
+          if (i < sps->num_subpics_minus1
+              && sps->pic_height_max_in_luma_samples > sps->ctu_size) {
+            READ_UINT16 (&nr, sps->subpic_height_minus1[i],
+                gst_util_ceil_log2 (tmpHeightVal));
+          } else
+            sps->subpic_height_minus1[i] =
+                tmpHeightVal - sps->subpic_ctu_top_left_y[i] - 1;
+
+          if (sps->subpic_same_size_flag) {
+            numSubpicCols = tmpWidthVal / (sps->subpic_width_minus1[0] + 1);
+            if (!(tmpWidthVal % (sps->subpic_width_minus1[0] + 1) == 0)) {
+              GST_WARNING ("subpic_width_minus1[0] is invalid.");
+              goto error;
+            }
+            if (!(tmpHeightVal % (sps->subpic_height_minus1[0] + 1) == 0)) {
+              GST_WARNING ("subpic_height_minus1[0] is invalid.");
+              goto error;
+            }
+            if (!(numSubpicCols * (tmpHeightVal /
+                        (sps->subpic_height_minus1[0] + 1)) ==
+                    (sps->num_subpics_minus1 + 1))) {
+              GST_WARNING ("when subpic_same_size_flag is equal to, "
+                  "num_subpics_minus1 is invalid");
+              goto error;
+            }
+          }
+        } else {
+          numSubpicCols = tmpWidthVal / (sps->subpic_width_minus1[0] + 1);
+
+          sps->subpic_ctu_top_left_x[i] =
+              (i % numSubpicCols) * (sps->subpic_width_minus1[0] + 1);
+          sps->subpic_ctu_top_left_y[i] =
+              (i / numSubpicCols) * (sps->subpic_height_minus1[0] + 1);
+          sps->subpic_width_minus1[i] = sps->subpic_width_minus1[0];
+          sps->subpic_height_minus1[i] = sps->subpic_height_minus1[0];
+        }
+
+        if (!sps->independent_subpics_flag) {
+          READ_UINT8 (&nr, sps->subpic_treated_as_pic_flag[i], 1);
+          READ_UINT8 (&nr, sps->loop_filter_across_subpic_enabled_flag[i], 1);
+        } else {
+          sps->subpic_treated_as_pic_flag[i] = 1;
+          sps->loop_filter_across_subpic_enabled_flag[i] = 0;
+        }
+      }
+    }
+
+    READ_UE_MAX (&nr, sps->subpic_id_len_minus1, 15);
+    if ((1 << (sps->subpic_id_len_minus1 + 1)) < sps->num_subpics_minus1 + 1) {
+      GST_WARNING ("Invalid subpic_id_len_minus1(%d) value",
+          sps->subpic_id_len_minus1);
+      goto error;
+    }
+
+    READ_UINT8 (&nr, sps->subpic_id_mapping_explicitly_signalled_flag, 1);
+    if (sps->subpic_id_mapping_explicitly_signalled_flag) {
+      READ_UINT8 (&nr, sps->subpic_id_mapping_present_flag, 1);
+      if (sps->subpic_id_mapping_present_flag)
+        for (i = 0; i <= sps->num_subpics_minus1; i++)
+          READ_UINT32 (&nr, sps->subpic_id[i], sps->subpic_id_len_minus1 + 1);
+    }
+  } else {
+    sps->subpic_id_mapping_explicitly_signalled_flag = 0;
+    sps->num_subpics_minus1 = 0;
+    sps->independent_subpics_flag = 1;
+    sps->subpic_ctu_top_left_x[0] = 0;
+    sps->subpic_ctu_top_left_y[0] = 0;
+    sps->subpic_width_minus1[0] =
+        (sps->pic_width_max_in_luma_samples + sps->ctu_size - 1) >>
+        floor_log2 (sps->ctu_size);
+    sps->subpic_height_minus1[0] =
+        (sps->pic_height_max_in_luma_samples + sps->ctu_size - 1) >>
+        floor_log2 (sps->ctu_size);
+  }
+
+  if (!sps->subpic_id_mapping_explicitly_signalled_flag ||
+      !sps->subpic_id_mapping_present_flag)
+    for (i = 0; i <= sps->num_subpics_minus1; i++)
+      sps->subpic_id[i] = i;
+
+  READ_UE_MAX (&nr, sps->bitdepth_minus8, 8);
+
+  READ_UINT8 (&nr, sps->entropy_coding_sync_enabled_flag, 1);
+  READ_UINT8 (&nr, sps->entry_point_offsets_present_flag, 1);
+
+  READ_UINT8 (&nr, sps->log2_max_pic_order_cnt_lsb_minus4, 4);
+  CHECK_ALLOWED_MAX (sps->log2_max_pic_order_cnt_lsb_minus4, 12);
+
+  READ_UINT8 (&nr, sps->poc_msb_cycle_flag, 1);
+  if (sps->poc_msb_cycle_flag)
+    READ_UE_MAX (&nr, sps->poc_msb_cycle_len_minus1,
+        32 - sps->log2_max_pic_order_cnt_lsb_minus4 - 5);
+
+  READ_UINT8 (&nr, sps->num_extra_ph_bytes, 2);
+  CHECK_ALLOWED_MAX (sps->num_extra_ph_bytes, 2);
+  for (i = 0; i < (sps->num_extra_ph_bytes * 8); i++)
+    READ_UINT8 (&nr, sps->extra_ph_bit_present_flag[i], 1);
+
+  READ_UINT8 (&nr, sps->num_extra_sh_bytes, 2);
+  CHECK_ALLOWED_MAX (sps->num_extra_sh_bytes, 2);
+  for (i = 0; i < (sps->num_extra_sh_bytes * 8); i++)
+    READ_UINT8 (&nr, sps->extra_sh_bit_present_flag[i], 1);
+
+  if (sps->ptl_dpb_hrd_params_present_flag) {
+    if (sps->max_sublayers_minus1 > 0)
+      READ_UINT8 (&nr, sps->sublayer_dpb_params_flag, 1);
+
+    if (!gst_h266_parse_dpb_parameters (&sps->dpb, &nr,
+            sps->max_sublayers_minus1, sps->sublayer_dpb_params_flag))
+      goto error;
+  }
+
+  READ_UE_MAX (&nr, sps->log2_min_luma_coding_block_size_minus2, MIN (4,
+          sps->log2_ctu_size_minus5 + 3));
+  minCbLog2SizeY = sps->log2_min_luma_coding_block_size_minus2 + 2;
+  CHECK_ALLOWED_MAX (minCbLog2SizeY, MIN (6, ctbLog2SizeY));
+  minCuSize = 1 << minCbLog2SizeY;
+  if (sps->pic_width_max_in_luma_samples % MAX (8, minCuSize) != 0) {
+    GST_WARNING ("Coded frame width must be a multiple of "
+        "Max(8, the minimum unit size)");
+    goto error;
+  }
+  if (sps->pic_height_max_in_luma_samples % MAX (8, minCuSize) != 0) {
+    GST_WARNING ("Coded frame height must be a multiple of "
+        "Max(8, the minimum unit size)");
+    goto error;
+  }
+
+  READ_UINT8 (&nr, sps->partition_constraints_override_enabled_flag, 1);
+
+  READ_UE_MAX (&nr, sps->log2_diff_min_qt_min_cb_intra_slice_luma, MIN (6,
+          ctbLog2SizeY) - minCbLog2SizeY);
+  minQtLog2SizeIntraY =
+      sps->log2_diff_min_qt_min_cb_intra_slice_luma + minCbLog2SizeY;
+  minQT[0] = 1 << minQtLog2SizeIntraY;
+  CHECK_ALLOWED_MAX (minQT[0], 64);
+  CHECK_ALLOWED_MAX (minQT[0], 1 << ctbLog2SizeY);
+
+  READ_UE_MAX (&nr, sps->max_mtt_hierarchy_depth_intra_slice_luma,
+      2 * (ctbLog2SizeY - minCbLog2SizeY));
+  maxTTSize[0] = maxBTSize[0] = minQT[0];
+  if (sps->max_mtt_hierarchy_depth_intra_slice_luma != 0) {
+    READ_UE_MAX (&nr, sps->log2_diff_max_bt_min_qt_intra_slice_luma,
+        ctbLog2SizeY - minQtLog2SizeIntraY);
+    maxBTSize[0] <<= sps->log2_diff_max_bt_min_qt_intra_slice_luma;
+
+    READ_UE_MAX (&nr, sps->log2_diff_max_tt_min_qt_intra_slice_luma, MIN (6,
+            ctbLog2SizeY) - minQtLog2SizeIntraY);
+    maxTTSize[0] <<= sps->log2_diff_max_tt_min_qt_intra_slice_luma;
+  }
+
+  if (sps->chroma_format_idc != 0)
+    READ_UINT8 (&nr, sps->qtbtt_dual_tree_intra_flag, 1);
+
+  if (sps->qtbtt_dual_tree_intra_flag) {
+    READ_UE_MAX (&nr, sps->log2_diff_min_qt_min_cb_intra_slice_chroma, MIN (6,
+            ctbLog2SizeY) - minCbLog2SizeY);
+    minQT[2] =
+        1 << (sps->log2_diff_min_qt_min_cb_intra_slice_chroma + minCbLog2SizeY);
+
+    READ_UE_MAX (&nr, sps->max_mtt_hierarchy_depth_intra_slice_chroma,
+        2 * (ctbLog2SizeY - minCbLog2SizeY));
+    maxTTSize[2] = maxBTSize[2] = minQT[2];
+    if (sps->max_mtt_hierarchy_depth_intra_slice_chroma != 0) {
+      guint minQtLog2SizeIntraC =
+          sps->log2_diff_min_qt_min_cb_intra_slice_chroma + minCbLog2SizeY;
+
+      READ_UE_MAX (&nr, sps->log2_diff_max_bt_min_qt_intra_slice_chroma,
+          MIN (6, ctbLog2SizeY) - minQtLog2SizeIntraC);
+      maxBTSize[2] <<= sps->log2_diff_max_bt_min_qt_intra_slice_chroma;
+
+      READ_UE_MAX (&nr, sps->log2_diff_max_tt_min_qt_intra_slice_chroma,
+          MIN (6, ctbLog2SizeY) - minQtLog2SizeIntraC);
+      maxTTSize[2] <<= sps->log2_diff_max_tt_min_qt_intra_slice_chroma;
+    }
+  }
+
+  READ_UE_MAX (&nr, sps->log2_diff_min_qt_min_cb_inter_slice, MIN (6,
+          ctbLog2SizeY) - minCbLog2SizeY);
+  minQtLog2SizeInterY =
+      sps->log2_diff_min_qt_min_cb_inter_slice + minCbLog2SizeY;
+  minQT[1] = 1 << minQtLog2SizeInterY;
+
+  READ_UE_MAX (&nr, sps->max_mtt_hierarchy_depth_inter_slice,
+      2 * (ctbLog2SizeY - minCbLog2SizeY));
+  maxTTSize[1] = maxBTSize[1] = minQT[1];
+  if (sps->max_mtt_hierarchy_depth_inter_slice != 0) {
+    READ_UE_MAX (&nr, sps->log2_diff_max_bt_min_qt_inter_slice,
+        ctbLog2SizeY - minQtLog2SizeInterY);
+    maxBTSize[1] <<= sps->log2_diff_max_bt_min_qt_inter_slice;
+
+    READ_UE_MAX (&nr, sps->log2_diff_max_tt_min_qt_inter_slice,
+        MIN (6, ctbLog2SizeY) - minQtLog2SizeInterY);
+    maxTTSize[1] <<= sps->log2_diff_max_bt_min_qt_inter_slice;
+  }
+
+  if (sps->ctu_size > 32)
+    READ_UINT8 (&nr, sps->max_luma_transform_size_64_flag, 1);
+
+  READ_UINT8 (&nr, sps->transform_skip_enabled_flag, 1);
+  if (sps->transform_skip_enabled_flag) {
+    READ_UE_MAX (&nr, sps->log2_transform_skip_max_size_minus2, 3);
+    READ_UINT8 (&nr, sps->bdpcm_enabled_flag, 1);
+  }
+
+  READ_UINT8 (&nr, sps->mts_enabled_flag, 1);
+  if (sps->mts_enabled_flag) {
+    READ_UINT8 (&nr, sps->explicit_mts_intra_enabled_flag, 1);
+    READ_UINT8 (&nr, sps->explicit_mts_inter_enabled_flag, 1);
+  }
+
+  READ_UINT8 (&nr, sps->lfnst_enabled_flag, 1);
+
+  if (sps->chroma_format_idc != 0) {
+    if (!gst_h266_parse_chroma_qp_table (sps, &nr))
+      goto error;
+  } else {
+    sps->joint_cbcr_enabled_flag = 0;
+    sps->same_qp_table_for_chroma_flag = 0;
+  }
+
+  READ_UINT8 (&nr, sps->sao_enabled_flag, 1);
+
+  READ_UINT8 (&nr, sps->alf_enabled_flag, 1);
+  if (sps->alf_enabled_flag && sps->chroma_format_idc != 0) {
+    READ_UINT8 (&nr, sps->ccalf_enabled_flag, 1);
+  } else
+    sps->ccalf_enabled_flag = 0;
+
+  READ_UINT8 (&nr, sps->lmcs_enabled_flag, 1);
+  READ_UINT8 (&nr, sps->weighted_pred_flag, 1);
+  READ_UINT8 (&nr, sps->weighted_bipred_flag, 1);
+  READ_UINT8 (&nr, sps->long_term_ref_pics_flag, 1);
+
+  if (sps->vps_id > 0) {
+    READ_UINT8 (&nr, sps->inter_layer_prediction_enabled_flag, 1);
+  } else
+    sps->inter_layer_prediction_enabled_flag = 0;
+
+  READ_UINT8 (&nr, sps->idr_rpl_present_flag, 1);
+  if (ptl->general_constraints_info.no_idr_constraint_flag &&
+      sps->idr_rpl_present_flag) {
+    GST_WARNING ("When gci_no_idr_rpl_constraint_flag equal to 1, "
+        "the value of sps_idr_rpl_present_flag shall be equal to 0.");
+    goto error;
+  }
+
+  READ_UINT8 (&nr, sps->rpl1_same_as_rpl0_flag, 1);
+  for (i = 0; i < (sps->rpl1_same_as_rpl0_flag ? 1 : 2); i++) {
+    READ_UE_MAX (&nr, sps->num_ref_pic_lists[i], GST_H266_MAX_REF_PIC_LISTS);
+    for (j = 0; j < sps->num_ref_pic_lists[i]; j++)
+      gst_h266_ref_pic_list_struct (&sps->ref_pic_list_struct[i][j], &nr,
+          i, j, sps);
+  }
+
+  if (sps->rpl1_same_as_rpl0_flag) {
+    sps->num_ref_pic_lists[1] = sps->num_ref_pic_lists[0];
+    memcpy (&sps->ref_pic_list_struct[1], &sps->ref_pic_list_struct[0],
+        sizeof (sps->ref_pic_list_struct[0]));
+  }
+
+  READ_UINT8 (&nr, sps->ref_wraparound_enabled_flag, 1);
+  if (sps->ref_wraparound_enabled_flag) {
+    for (i = 0; i <= sps->num_subpics_minus1; i++) {
+      if (sps->subpic_treated_as_pic_flag[i] &&
+          (sps->subpic_width_minus1[i] + 1 !=
+              (sps->pic_width_max_in_luma_samples + sps->ctu_size - 1) /
+              sps->ctu_size)) {
+        GST_WARNING ("sps_ref_wraparound_enabled_flag cannot be equal "
+            "to 1 when there is at least one subpicture with "
+            "SubPicTreatedAsPicFlag equal to 1 and the subpicture's width "
+            "is not equal to picture's width");
+        goto error;
+      }
+    }
+  }
+
+  READ_UINT8 (&nr, sps->temporal_mvp_enabled_flag, 1);
+  if (sps->temporal_mvp_enabled_flag)
+    READ_UINT8 (&nr, sps->sbtmvp_enabled_flag, 1);
+
+  READ_UINT8 (&nr, sps->amvr_enabled_flag, 1);
+
+  READ_UINT8 (&nr, sps->bdof_enabled_flag, 1);
+  if (sps->bdof_enabled_flag)
+    READ_UINT8 (&nr, sps->bdof_control_present_in_ph_flag, 1);
+
+  READ_UINT8 (&nr, sps->smvd_enabled_flag, 1);
+
+  READ_UINT8 (&nr, sps->dmvr_enabled_flag, 1);
+  if (sps->dmvr_enabled_flag)
+    READ_UINT8 (&nr, sps->dmvr_control_present_in_ph_flag, 1);
+
+  READ_UINT8 (&nr, sps->mmvd_enabled_flag, 1);
+  if (sps->mmvd_enabled_flag)
+    READ_UINT8 (&nr, sps->mmvd_fullpel_only_enabled_flag, 1);
+
+  READ_UE_MAX (&nr, sps->six_minus_max_num_merge_cand, 5);
+  MaxNumMergeCand = 6 - sps->six_minus_max_num_merge_cand;
+
+  READ_UINT8 (&nr, sps->sbt_enabled_flag, 1);
+
+  READ_UINT8 (&nr, sps->affine_enabled_flag, 1);
+  if (sps->affine_enabled_flag) {
+    READ_UE_MAX (&nr, sps->five_minus_max_num_subblock_merge_cand,
+        5 - sps->sbtmvp_enabled_flag);
+    READ_UINT8 (&nr, sps->sps_6param_affine_enabled_flag, 1);
+    if (sps->amvr_enabled_flag)
+      READ_UINT8 (&nr, sps->affine_amvr_enabled_flag, 1);
+
+    READ_UINT8 (&nr, sps->affine_prof_enabled_flag, 1);
+    if (sps->affine_prof_enabled_flag)
+      READ_UINT8 (&nr, sps->prof_control_present_in_ph_flag, 1);
+  }
+
+  READ_UINT8 (&nr, sps->bcw_enabled_flag, 1);
+  READ_UINT8 (&nr, sps->ciip_enabled_flag, 1);
+
+  if (MaxNumMergeCand >= 2) {
+    READ_UINT8 (&nr, sps->gpm_enabled_flag, 1);
+    if (sps->gpm_enabled_flag && MaxNumMergeCand >= 3)
+      READ_UE_MAX (&nr, sps->max_num_merge_cand_minus_max_num_gpm_cand,
+          MaxNumMergeCand - 2);
+  }
+
+  READ_UE_MAX (&nr, sps->log2_parallel_merge_level_minus2, ctbLog2SizeY - 2);
+
+  READ_UINT8 (&nr, sps->isp_enabled_flag, 1);
+  READ_UINT8 (&nr, sps->mrl_enabled_flag, 1);
+  READ_UINT8 (&nr, sps->mip_enabled_flag, 1);
+
+  if (sps->chroma_format_idc != 0)
+    READ_UINT8 (&nr, sps->cclm_enabled_flag, 1);
+
+  if (sps->chroma_format_idc == 1) {
+    READ_UINT8 (&nr, sps->chroma_horizontal_collocated_flag, 1);
+    READ_UINT8 (&nr, sps->chroma_vertical_collocated_flag, 1);
+  } else {
+    sps->chroma_horizontal_collocated_flag = 1;
+    sps->chroma_vertical_collocated_flag = 1;
+  }
+
+  READ_UINT8 (&nr, sps->palette_enabled_flag, 1);
+  if ((ptl->profile_idc == GST_H266_PROFILE_MAIN_12 ||
+          ptl->profile_idc == GST_H266_PROFILE_MAIN_12_INTRA ||
+          ptl->profile_idc == GST_H266_PROFILE_MAIN_12_STILL_PICTURE) &&
+      sps->palette_enabled_flag) {
+    GST_WARNING ("sps_palette_enabled_flag shall be equal to 0 "
+        "for Main 12 (420) profiles");
+    goto error;
+  }
+
+  if (sps->chroma_format_idc == 3 && !sps->max_luma_transform_size_64_flag)
+    READ_UINT8 (&nr, sps->act_enabled_flag, 1);
+
+  if (sps->transform_skip_enabled_flag || sps->palette_enabled_flag)
+    READ_UE_MAX (&nr, sps->min_qp_prime_ts, 8);
+
+  READ_UINT8 (&nr, sps->ibc_enabled_flag, 1);
+  if (sps->ibc_enabled_flag)
+    READ_UE_MAX (&nr, sps->six_minus_max_num_ibc_merge_cand, 5);
+
+  READ_UINT8 (&nr, sps->ladf_enabled_flag, 1);
+  if (sps->ladf_enabled_flag) {
+    READ_UINT8 (&nr, sps->num_ladf_intervals_minus2, 2);
+    READ_SE_ALLOWED (&nr, sps->ladf_lowest_interval_qp_offset, -63, 63);
+    for (i = 0; i < sps->num_ladf_intervals_minus2 + 1; i++) {
+      READ_SE_ALLOWED (&nr, sps->ladf_qp_offset[i], -63, 63);
+      READ_UE_MAX (&nr, sps->ladf_delta_threshold_minus1[i],
+          (2 << (8 + sps->bitdepth_minus8)) - 3);
+    }
+  }
+
+  READ_UINT8 (&nr, sps->explicit_scaling_list_enabled_flag, 1);
+  if (sps->lfnst_enabled_flag && sps->explicit_scaling_list_enabled_flag)
+    READ_UINT8 (&nr, sps->scaling_matrix_for_lfnst_disabled_flag, 1);
+
+  if (sps->act_enabled_flag && sps->explicit_scaling_list_enabled_flag)
+    READ_UINT8 (&nr,
+        sps->scaling_matrix_for_alternative_colour_space_disabled_flag, 1);
+
+  if (sps->scaling_matrix_for_alternative_colour_space_disabled_flag)
+    READ_UINT8 (&nr, sps->scaling_matrix_designated_colour_space_flag, 1);
+
+  READ_UINT8 (&nr, sps->dep_quant_enabled_flag, 1);
+  READ_UINT8 (&nr, sps->sign_data_hiding_enabled_flag, 1);
+
+  READ_UINT8 (&nr, sps->virtual_boundaries_enabled_flag, 1);
+  if (ptl->general_constraints_info.no_virtual_boundaries_constraint_flag &&
+      sps->virtual_boundaries_enabled_flag) {
+    GST_WARNING ("When gci_no_virtual_boundaries_constraint_flag is "
+        "equal to 1, sps_virtual_boundaries_enabled_flag shall be "
+        "equal to 0");
+    goto error;
+  }
+
+  if (sps->virtual_boundaries_enabled_flag) {
+    READ_UINT8 (&nr, sps->virtual_boundaries_present_flag, 1);
+    if (sps->virtual_boundaries_present_flag) {
+      READ_UE (&nr, sps->num_ver_virtual_boundaries);
+      if (sps->pic_width_max_in_luma_samples <= 8 &&
+          sps->num_ver_virtual_boundaries != 0) {
+        GST_WARNING ("SPS: When picture width is less than or equal to 8, "
+            "the number of vertical virtual boundaries shall be equal to 0");
+        goto error;
+      }
+      if (sps->num_ver_virtual_boundaries > 3) {
+        GST_WARNING ("SPS: The number of vertical virtual boundaries "
+            "shall be in the range of 0 to 3");
+        goto error;
+      }
+
+      for (i = 0; i < sps->num_ver_virtual_boundaries; i++)
+        READ_UE_MAX (&nr, sps->virtual_boundary_pos_x_minus1[i],
+            (sps->pic_width_max_in_luma_samples + 7) / 8 - 2);
+
+      READ_UE (&nr, sps->num_hor_virtual_boundaries);
+      if (sps->pic_height_max_in_luma_samples <= 8 &&
+          sps->num_hor_virtual_boundaries != 0) {
+        GST_WARNING ("SPS: When picture height is less than or equal to 8, "
+            "the number of horizontal virtual boundaries shall be equal to 0");
+        goto error;
+      }
+      if (sps->num_hor_virtual_boundaries > 3) {
+        GST_WARNING ("SPS: The number of horizontal virtual boundaries "
+            "shall be in the range of 0 to 3");
+        goto error;
+      }
+
+      for (i = 0; i < sps->num_hor_virtual_boundaries; i++)
+        READ_UE_MAX (&nr, sps->virtual_boundary_pos_y_minus1[i],
+            (sps->pic_height_max_in_luma_samples + 7) / 8 - 2);
+    }
+  }
+
+  if (sps->ptl_dpb_hrd_params_present_flag) {
+    READ_UINT8 (&nr, sps->timing_hrd_params_present_flag, 1);
+
+    if (sps->timing_hrd_params_present_flag) {
+      guint8 firstSubLayer;
+
+      gst_h266_parse_general_timing_hrd_parameters (&sps->general_hrd_params,
+          &nr);
+
+      if (sps->max_sublayers_minus1 > 0)
+        READ_UINT8 (&nr, sps->sublayer_cpb_params_present_flag, 1);
+
+      firstSubLayer =
+          sps->sublayer_cpb_params_present_flag ? 0 : sps->max_sublayers_minus1;
+      gst_h266_parse_ols_timing_hrd_parameters (&sps->ols_hrd_params, &nr,
+          &sps->general_hrd_params, firstSubLayer, sps->max_sublayers_minus1);
+    }
+  }
+
+  READ_UINT8 (&nr, sps->field_seq_flag, 1);
+
+  READ_UINT8 (&nr, sps->vui_parameters_present_flag, 1);
+  if (sps->vui_parameters_present_flag) {
+    READ_UE_MAX (&nr, sps->vui_payload_size_minus1, 1023);
+
+    while (!nal_reader_is_byte_aligned (&nr))
+      if (!nal_reader_skip (&nr, 1))
+        goto error;
+
+    if (!gst_h266_parse_vui_payload (&sps->vui_params, &nr,
+            sps->vui_payload_size_minus1 + 1))
+      goto error;
+  } else {
+    gst_h266_vui_parameters_set_default (&sps->vui_params);
+  }
+
+  READ_UINT8 (&nr, sps->extension_flag, 1);
+  if (sps->extension_flag) {
+    READ_UINT8 (&nr, sps->range_extension_flag, 1);
+
+    for (i = 0; i < 7; i++) {
+      READ_UINT8 (&nr, sps->extension_7_flags[i], 1);
+      if (sps->extension_7_flags[i]) {
+        GST_WARNING ("The value of sps_extension_7bits shall be equal "
+            "to 0 in bitstreams conforming to this version of this document");
+        goto error;
+      }
+    }
+
+    if (sps->range_extension_flag) {
+      if (sps->bitdepth_minus8 + 8 <= 10) {
+        GST_WARNING ("The value of sps_range_extension_flag shall be 0 "
+            "when BitDepth is less than or equal to 10.");
+        goto error;
+      }
+
+      if (!gst_h266_parse_range_extension (&sps->range_params,
+              &nr, sps->transform_skip_enabled_flag))
+        goto error;
+    }
+  }
+
+  sps->max_width = sps->pic_width_max_in_luma_samples;
+  sps->max_height = sps->pic_height_max_in_luma_samples;
+  if (sps->conformance_window_flag) {
+    sps->crop_rect_width = sps->max_width -
+        (sps->conf_win_left_offset + sps->conf_win_right_offset) * sub_width_c;
+    sps->crop_rect_height = sps->max_height -
+        (sps->conf_win_top_offset + sps->conf_win_bottom_offset) * sub_height_c;
+    sps->crop_rect_x = sps->conf_win_left_offset * sub_width_c;
+    sps->crop_rect_y = sps->conf_win_top_offset * sub_height_c;
+
+    GST_LOG ("crop_rectangle x=%u y=%u width=%u, height=%u", sps->crop_rect_x,
+        sps->crop_rect_y, sps->crop_rect_width, sps->crop_rect_height);
+  }
+
+  /* calculate fps_num fps_den */
+  sps->fps_num = 0;
+  sps->fps_den = 1;
+  if (sps->ptl_dpb_hrd_params_present_flag
+      && sps->timing_hrd_params_present_flag) {
+    sps->fps_num = sps->general_hrd_params.time_scale;
+    sps->fps_den = sps->general_hrd_params.num_units_in_tick;
+    GST_LOG ("framerate %d/%d in SPS", sps->fps_num, sps->fps_den);
+  } else if (vps && vps->timing_hrd_params_present_flag) {
+    sps->fps_num = vps->general_hrd_params.time_scale;
+    sps->fps_den = vps->general_hrd_params.num_units_in_tick;
+    GST_LOG ("framerate %d/%d in VPS", sps->fps_num, sps->fps_den);
+  } else {
+    GST_LOG ("unknown framerate");
+  }
+
+  sps->valid = TRUE;
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Sequence parameter set\"");
+  sps->valid = FALSE;
+  return GST_H266_PARSER_ERROR;
+}
+
+static gboolean
+gst_h266_parser_parse_tile_info (GstH266SPS * sps,
+    GstH266PPS * pps, NalReader * nr)
+{
+  guint exp_tile_width = 0, exp_tile_height = 0;
+  guint unified_size, remaining_size;
+  gint i;
+
+  GST_DEBUG ("parsing \"Tile Info\"");
+
+  READ_UE_MAX (nr, pps->num_exp_tile_columns_minus1,
+      MIN (pps->pic_width_in_ctbs_y - 1, GST_H266_MAX_TILE_COLUMNS - 1));
+  READ_UE_MAX (nr, pps->num_exp_tile_rows_minus1,
+      MIN (pps->pic_height_in_ctbs_y - 1, GST_H266_MAX_TILE_ROWS - 1));
+
+  for (i = 0; i <= pps->num_exp_tile_columns_minus1; i++) {
+    READ_UE_MAX (nr, pps->tile_column_width_minus1[i],
+        pps->pic_width_in_ctbs_y - exp_tile_width - 1);
+    exp_tile_width += pps->tile_column_width_minus1[i] + 1;
+  }
+
+  remaining_size = pps->pic_width_in_ctbs_y - exp_tile_width;
+  unified_size = (i == 0 ? pps->pic_width_in_ctbs_y :
+      (pps->tile_column_width_minus1[i - 1] + 1));
+
+  pps->num_tile_columns =
+      i + ((remaining_size + unified_size - 1) / unified_size);
+  if (pps->num_tile_columns > GST_H266_MAX_TILE_COLUMNS) {
+    GST_WARNING ("NumTileColumns(%d) large than max tile columns %d.\n",
+        pps->num_tile_columns, GST_H266_MAX_TILE_COLUMNS);
+    goto error;
+  }
+
+  while (remaining_size > unified_size) {
+    pps->tile_column_width_minus1[i] = unified_size - 1;
+    remaining_size -= unified_size;
+    i++;
+  }
+  if (remaining_size > 0)
+    pps->tile_column_width_minus1[i] = remaining_size - 1;
+
+  for (i = 0; i <= pps->num_exp_tile_rows_minus1; i++) {
+    READ_UE_MAX (nr, pps->tile_row_height_minus1[i],
+        pps->pic_height_in_ctbs_y - exp_tile_height - 1);
+    exp_tile_height += pps->tile_row_height_minus1[i] + 1;
+  }
+
+  remaining_size = pps->pic_height_in_ctbs_y - exp_tile_height;
+  unified_size = (i == 0 ? pps->pic_height_in_ctbs_y :
+      (pps->tile_row_height_minus1[i - 1] + 1));
+
+  pps->num_tile_rows = i + ((remaining_size + unified_size - 1) / unified_size);
+  if (pps->num_tile_rows > GST_H266_MAX_TILE_ROWS) {
+    GST_WARNING ("NumTileRows(%d) large than max tile rows %d.\n",
+        pps->num_tile_rows, GST_H266_MAX_TILE_ROWS);
+    goto error;
+  }
+
+  while (remaining_size > unified_size) {
+    pps->tile_row_height_minus1[i] = unified_size - 1;
+    remaining_size -= unified_size;
+    i++;
+  }
+  if (remaining_size > 0)
+    pps->tile_row_height_minus1[i] = remaining_size - 1;
+
+  pps->num_tiles_in_pic = pps->num_tile_columns * pps->num_tile_rows;
+  if (pps->num_tiles_in_pic > GST_H266_MAX_TILES_PER_AU) {
+    GST_WARNING ("NumTilesInPic(%d) large than max tiles per AU %d.\n",
+        pps->num_tiles_in_pic, GST_H266_MAX_TILES_PER_AU);
+    goto error;
+  }
+
+  if (pps->num_tiles_in_pic > 1) {
+    READ_UINT8 (nr, pps->loop_filter_across_tiles_enabled_flag, 1);
+    READ_UINT8 (nr, pps->rect_slice_flag, 1);
+  } else {
+    pps->loop_filter_across_tiles_enabled_flag = 0;
+    pps->rect_slice_flag = 1;
+  }
+
+  pps->tile_col_bd_val[0] = 0;
+  for (i = 0; i < pps->num_tile_columns; i++) {
+    pps->tile_col_bd_val[i + 1] =
+        pps->tile_col_bd_val[i] + pps->tile_column_width_minus1[i] + 1;
+  }
+  pps->tile_row_bd_val[0] = 0;
+  for (i = 0; i < pps->num_tile_rows; i++) {
+    pps->tile_row_bd_val[i + 1] =
+        pps->tile_row_bd_val[i] + pps->tile_row_height_minus1[i] + 1;
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"Tile Info\"");
+  return FALSE;
+}
+
+static gboolean
+gst_h266_parser_parse_picture_partition (GstH266SPS * sps,
+    GstH266PPS * pps, NalReader * nr)
+{
+  guint16 tile_idx, tile_x, tile_y, ctu_x, ctu_y;
+  gint i, j;
+
+  GST_DEBUG ("parsing \"Picture Partition\"");
+
+  READ_UINT8 (nr, pps->log2_ctu_size_minus5, 2);
+  if (pps->log2_ctu_size_minus5 != sps->log2_ctu_size_minus5) {
+    GST_WARNING ("pps_log2_ctu_size_minus5 shall be equal "
+        "to sps_log2_ctu_size_minus5");
+    goto error;
+  }
+
+  if (!gst_h266_parser_parse_tile_info (sps, pps, nr))
+    goto error;
+
+  if (pps->rect_slice_flag) {
+    READ_UINT8 (nr, pps->single_slice_per_subpic_flag, 1);
+  } else {
+    pps->single_slice_per_subpic_flag = 0;
+  }
+
+  if (pps->rect_slice_flag) {
+    if (!pps->single_slice_per_subpic_flag) {
+      tile_idx = 0;
+
+      READ_UE_MAX (nr, pps->num_slices_in_pic_minus1,
+          GST_H266_MAX_SLICES_PER_AU - 1);
+      if (pps->num_slices_in_pic_minus1 > 1) {
+        READ_UINT8 (nr, pps->tile_idx_delta_present_flag, 1);
+      } else {
+        pps->tile_idx_delta_present_flag = 0;
+      }
+
+      /* Handle the last one after this loop */
+      for (i = 0; i < pps->num_slices_in_pic_minus1; i++) {
+        pps->slice_top_left_tile_idx[i] = tile_idx;
+        tile_x = tile_idx % pps->num_tile_columns;
+        tile_y = tile_idx / pps->num_tile_columns;
+
+        if (tile_x != pps->num_tile_columns - 1) {
+          READ_UE_MAX (nr, pps->slice_width_in_tiles_minus1[i],
+              pps->num_tile_columns - 1);
+        } else {
+          pps->slice_width_in_tiles_minus1[i] = 0;
+        }
+
+        if (tile_y != pps->num_tile_rows - 1 &&
+            (pps->tile_idx_delta_present_flag || tile_x == 0)) {
+          READ_UE_MAX (nr, pps->slice_height_in_tiles_minus1[i],
+              pps->num_tile_rows - 1);
+        } else {
+          if (tile_y == pps->num_tile_rows - 1) {
+            pps->slice_height_in_tiles_minus1[i] = 0;
+          } else {
+            /* tile_x != 0, so i should be > 0 when we get here. */
+            pps->slice_height_in_tiles_minus1[i] =
+                pps->slice_height_in_tiles_minus1[i - 1];
+          }
+        }
+
+        ctu_x = pps->tile_col_bd_val[tile_x];
+        ctu_y = pps->tile_row_bd_val[tile_y];
+
+        /* slice is no bigger than tile */
+        if (pps->slice_width_in_tiles_minus1[i] == 0 &&
+            pps->slice_height_in_tiles_minus1[i] == 0 &&
+            pps->tile_row_height_minus1[tile_y] > 0) {
+          gint num_slices_in_tile, uniform_slice_height,
+              remaining_height_in_ctbs_y;
+          gint k;
+
+          remaining_height_in_ctbs_y = pps->tile_row_height_minus1[tile_y] + 1;
+
+          READ_UE_MAX (nr, pps->num_exp_slices_in_tile[i],
+              pps->tile_row_height_minus1[tile_y]);
+
+          /* slice is equal to tile */
+          if (pps->num_exp_slices_in_tile[i] == 0) {
+            num_slices_in_tile = 1;
+            pps->slice_top_left_ctu_x[i] = ctu_x;
+            pps->slice_top_left_ctu_y[i] = ctu_y;
+            pps->slice_height_in_ctus[i] =
+                pps->tile_row_height_minus1[tile_y] + 1;
+          } else {              /* tile contains multi slices */
+            guint16 slice_height_in_ctus;
+
+            for (j = 0; j < pps->num_exp_slices_in_tile[i]; j++) {
+              READ_UE_MAX (nr, pps->exp_slice_height_in_ctus_minus1[i][j],
+                  pps->tile_row_height_minus1[tile_y]);
+
+              slice_height_in_ctus =
+                  pps->exp_slice_height_in_ctus_minus1[i][j] + 1;
+              pps->slice_height_in_ctus[i + j] = slice_height_in_ctus;
+
+              pps->slice_top_left_ctu_x[i + j] = ctu_x;
+              pps->slice_top_left_ctu_y[i + j] = ctu_y;
+
+              ctu_y += slice_height_in_ctus;
+              remaining_height_in_ctbs_y -= slice_height_in_ctus;
+            }
+
+            uniform_slice_height =
+                1 + pps->exp_slice_height_in_ctus_minus1[i][j - 1];
+
+            /* Assign the remaining CTBs to slices */
+            while (remaining_height_in_ctbs_y > uniform_slice_height) {
+              if (i + j > pps->num_slices_in_pic_minus1) {
+                GST_WARNING ("Too may slices %d", i + j + 1);
+                goto error;
+              }
+
+              pps->slice_height_in_ctus[i + j] = uniform_slice_height;
+
+              pps->slice_top_left_ctu_x[i + j] = ctu_x;
+              pps->slice_top_left_ctu_y[i + j] = ctu_y;
+
+              ctu_y += uniform_slice_height;
+              remaining_height_in_ctbs_y -= uniform_slice_height;
+              j++;
+            }
+
+            if (remaining_height_in_ctbs_y > 0) {
+              if (i + j > pps->num_slices_in_pic_minus1) {
+                GST_WARNING ("Too may slices %d", i + j + 1);
+                goto error;
+              }
+
+              pps->slice_height_in_ctus[i + j] = remaining_height_in_ctbs_y;
+              pps->slice_top_left_ctu_x[i + j] = ctu_x;
+              pps->slice_top_left_ctu_y[i + j] = ctu_y;
+              j++;
+            }
+
+            num_slices_in_tile = j;
+          }
+
+          /* slice_top_left_tile_idx[0] already set */
+          for (k = 1; k < num_slices_in_tile; k++)
+            pps->slice_top_left_tile_idx[i + k] = tile_idx;
+
+          i += num_slices_in_tile - 1;
+        } else {                /* Slice may contain multi tiles. */
+          guint16 height = 0;
+
+          pps->num_exp_slices_in_tile[i] = 0;
+
+          for (j = 0; j <= pps->slice_height_in_tiles_minus1[i]; j++)
+            height += pps->tile_row_height_minus1[tile_y + j] + 1;
+          pps->slice_height_in_ctus[i] = height;
+
+          pps->slice_top_left_ctu_x[i] = ctu_x;
+          pps->slice_top_left_ctu_y[i] = ctu_y;
+        }
+
+        if (i < pps->num_slices_in_pic_minus1) {
+          if (pps->tile_idx_delta_present_flag) {
+            gint num_tiles_in_pic = pps->num_tiles_in_pic;
+
+            READ_SE_ALLOWED (nr, pps->tile_idx_delta_val[i],
+                -num_tiles_in_pic + 1, num_tiles_in_pic - 1);
+            if (pps->tile_idx_delta_val[i] == 0) {
+              /* When present, the value of pps_tile_idx_delta_val[i]
+                 shall not be equal to 0. */
+              GST_WARNING ("pps->tile_idx_delta_val[i] shall not be"
+                  " equal to 0.\n");
+              goto error;
+            }
+
+            tile_idx += pps->tile_idx_delta_val[i];
+          } else {
+            pps->tile_idx_delta_val[i] = 0;
+
+            tile_idx += pps->slice_width_in_tiles_minus1[i] + 1;
+            if (tile_idx % pps->num_tile_columns == 0) {
+              tile_idx += pps->slice_height_in_tiles_minus1[i] *
+                  pps->num_tile_columns;
+            }
+          }
+        }
+      }
+
+      if (i > pps->num_slices_in_pic_minus1 + 1) {
+        GST_WARNING ("wrong slice num %d, bigger than total slice num %d",
+            i, pps->num_slices_in_pic_minus1 + 1);
+        goto error;
+      } else if (i == pps->num_slices_in_pic_minus1) {
+        /* Assign the left to the last slice if not explicitly assigned. */
+        guint16 height = 0;
+
+        pps->slice_top_left_tile_idx[i] = tile_idx;
+
+        tile_x = tile_idx % pps->num_tile_columns;
+        tile_y = tile_idx / pps->num_tile_columns;
+        ctu_x = 0, ctu_y = 0;
+        for (j = 0; j < tile_x; j++)
+          ctu_x += pps->tile_column_width_minus1[j] + 1;
+        for (j = 0; j < tile_y; j++)
+          ctu_y += pps->tile_row_height_minus1[j] + 1;
+
+        pps->slice_top_left_ctu_x[i] = ctu_x;
+        pps->slice_top_left_ctu_y[i] = ctu_y;
+
+        pps->slice_width_in_tiles_minus1[i] =
+            pps->num_tile_columns - tile_x - 1;
+        pps->slice_height_in_tiles_minus1[i] = pps->num_tile_rows - tile_y - 1;
+
+        for (j = 0; j <= pps->slice_height_in_tiles_minus1[i]; j++)
+          height += pps->tile_row_height_minus1[tile_y + j] + 1;
+        pps->slice_height_in_ctus[i] = height;
+
+        pps->num_exp_slices_in_tile[i] = 0;
+      }
+
+      /* calculate NumSlicesInSubpic */
+      for (i = 0; i <= sps->num_subpics_minus1; i++) {
+        pps->num_slices_in_subpic[i] = 0;
+
+        for (j = 0; j <= pps->num_slices_in_pic_minus1; j++) {
+          guint16 pos_x = pps->slice_top_left_ctu_x[j];
+          guint16 pos_y = pps->slice_top_left_ctu_y[j];
+
+          if ((pos_x >= sps->subpic_ctu_top_left_x[i]) &&
+              (pos_x < sps->subpic_ctu_top_left_x[i] +
+                  sps->subpic_width_minus1[i] + 1) &&
+              (pos_y >= sps->subpic_ctu_top_left_y[i])
+              && (pos_y < sps->subpic_ctu_top_left_y[i] +
+                  sps->subpic_height_minus1[i] + 1))
+            pps->num_slices_in_subpic[i]++;
+        }
+      }
+    } else {
+      gint start_x, start_y;
+
+      pps->num_slices_in_pic_minus1 = sps->num_subpics_minus1;
+      for (i = 0; i <= sps->num_subpics_minus1; i++) {
+        start_x = -1;
+        start_y = -1;
+
+        pps->num_slices_in_subpic[i] = 1;
+
+        for (tile_y = 0; tile_y < pps->num_tile_rows; tile_y++) {
+          for (tile_x = 0; tile_x < pps->num_tile_columns; tile_x++) {
+            if ((pps->tile_col_bd_val[tile_x] >= sps->subpic_ctu_top_left_x[i])
+                && (pps->tile_col_bd_val[tile_x] < sps->subpic_ctu_top_left_x[i]
+                    + sps->subpic_width_minus1[i] + 1)
+                && (pps->tile_row_bd_val[tile_y] >=
+                    sps->subpic_ctu_top_left_y[i])
+                && (pps->tile_row_bd_val[tile_y] < sps->subpic_ctu_top_left_y[i]
+                    + sps->subpic_height_minus1[i] + 1)) {
+              if (start_x == -1) {
+                start_x = tile_x;
+                start_y = tile_y;
+              }
+              pps->slice_width_in_tiles_minus1[i] = tile_x - start_x;
+              pps->slice_height_in_tiles_minus1[i] = tile_y - start_y;
+            }
+          }
+        }
+
+        if (start_x == -1) {
+          GST_WARNING ("No tile found for subpic start at: [%d, %d], "
+              "size: [%d, %d] in CTUs", sps->subpic_ctu_top_left_x[i],
+              sps->subpic_ctu_top_left_y[i], sps->subpic_width_minus1[i] + 1,
+              sps->subpic_height_minus1[i] + 1);
+          goto error;
+        }
+
+        pps->slice_top_left_tile_idx[i] =
+            start_x + start_y * pps->num_tile_columns;
+        pps->slice_top_left_ctu_x[i] = sps->subpic_ctu_top_left_x[i];
+        pps->slice_top_left_ctu_y[i] = sps->subpic_ctu_top_left_y[i];
+        pps->slice_height_in_ctus[i] = sps->subpic_height_minus1[i] + 1;
+      }
+    }
+  }
+
+  if (!pps->rect_slice_flag || pps->single_slice_per_subpic_flag ||
+      pps->num_slices_in_pic_minus1 > 0) {
+    READ_UINT8 (nr, pps->loop_filter_across_slices_enabled_flag, 1);
+  } else {
+    pps->loop_filter_across_slices_enabled_flag = 0;
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"Picture Partition\"");
+  return FALSE;
+}
+
+static guint16
+gst_h266_parser_add_slice_ctus_map (GstH266Parser * parser,
+    const GstH266PPS * pps, guint slice_start_offset,
+    guint ctu_x, guint ctu_y, guint width, guint height)
+{
+  guint x, y;
+  guint16 ctb_count = 0;
+
+  for (y = ctu_y; y < ctu_y + height; y++) {
+    for (x = ctu_x; x < ctu_x + width; x++) {
+      /* CtbAddrInRs */
+      parser->ctb_addr_in_slice[slice_start_offset + ctb_count] =
+          y * pps->pic_width_in_ctbs_y + x;
+      ctb_count++;
+    }
+  }
+
+  return ctb_count;
+}
+
+static gboolean
+gst_h266_parser_generate_ctb_map (GstH266Parser * parser,
+    const GstH266PPS * pps)
+{
+  gint tile_y, tile_x, ctu_y, ctu_x;
+  guint ctb_addr_x, ctb_addr_y;
+  gint ctu_idx = 0;
+  gint i, j, k;
+
+  memset (parser->ctb_addr_in_slice, 0, sizeof (parser->ctb_addr_in_slice));
+  memset (parser->slice_start_offset, 0, sizeof (parser->slice_start_offset));
+  memset (parser->num_ctus_in_slice, 0, sizeof (parser->num_ctus_in_slice));
+  memset (parser->ctb_to_tile_col_bd, 0, sizeof (parser->ctb_to_tile_col_bd));
+  memset (parser->ctb_to_tile_row_bd, 0, sizeof (parser->ctb_to_tile_row_bd));
+
+  if (pps->pic_size_in_ctbs_y >= GST_H266_MAX_CTUS_IN_PICTURE) {
+    GST_WARNING ("Too many CTBs %d", pps->pic_size_in_ctbs_y);
+    return FALSE;
+  }
+
+  tile_x = 0, tile_y = 0;
+  for (ctb_addr_x = 0; ctb_addr_x < pps->pic_width_in_ctbs_y; ctb_addr_x++) {
+    if (ctb_addr_x == pps->tile_col_bd_val[tile_x + 1])
+      tile_x++;
+    parser->ctb_to_tile_col_bd[ctb_addr_x] = pps->tile_col_bd_val[tile_x];
+  }
+  parser->ctb_to_tile_col_bd[pps->pic_width_in_ctbs_y] =
+      pps->pic_width_in_ctbs_y;
+
+  for (ctb_addr_y = 0; ctb_addr_y < pps->pic_height_in_ctbs_y; ctb_addr_y++) {
+    if (ctb_addr_y == pps->tile_row_bd_val[tile_y + 1])
+      tile_y++;
+    parser->ctb_to_tile_row_bd[ctb_addr_y] = pps->tile_row_bd_val[tile_y];
+  }
+  parser->ctb_to_tile_row_bd[pps->pic_height_in_ctbs_y] =
+      pps->pic_height_in_ctbs_y;
+
+
+  /* Map between raster scan address and CTU address.
+   * For non rect slice mode, the slice number for each picture is not
+   * fixed, we only need to establish the map based on tile info.
+   *
+   * For rect slice mode, the slice structure for each picture is fixed
+   * based on the PPS info. So beside the map, we can also know the
+   * slice_start_offset and num_ctus_in_slice for each slice.
+   */
+  if (!pps->no_pic_partition_flag && pps->rect_slice_flag) {
+    guint16 ctb_count;
+    guint16 slice_start_offset = 0;
+
+    for (i = 0; i <= pps->num_slices_in_pic_minus1; i++) {
+      tile_x = pps->slice_top_left_tile_idx[i] % pps->num_tile_columns;
+      tile_y = pps->slice_top_left_tile_idx[i] / pps->num_tile_columns;
+
+      if (pps->slice_width_in_tiles_minus1[i] == 0 &&
+          pps->slice_height_in_tiles_minus1[i] == 0) {
+        /* Slice contains no more than one tile, the slice_top_left_ctu_x/y
+           and slice_height_in_ctus give all the info. */
+        ctb_count = gst_h266_parser_add_slice_ctus_map (parser,
+            pps, slice_start_offset, pps->slice_top_left_ctu_x[i],
+            pps->slice_top_left_ctu_y[i],
+            pps->tile_column_width_minus1[tile_x] + 1,
+            pps->slice_height_in_ctus[i]);
+
+        parser->slice_start_offset[i] = slice_start_offset;
+        parser->num_ctus_in_slice[i] = ctb_count;
+        slice_start_offset += ctb_count;
+      } else {
+        guint16 ctu_x, ctu_y, ctu_width, ctu_height;
+
+        g_assert (pps->tile_col_bd_val[tile_x] == pps->slice_top_left_ctu_x[i]);
+        g_assert (pps->tile_row_bd_val[tile_y] == pps->slice_top_left_ctu_y[i]);
+
+        parser->slice_start_offset[i] = slice_start_offset;
+
+        for (j = 0; j <= pps->slice_height_in_tiles_minus1[i]; j++) {
+          for (k = 0; k <= pps->slice_width_in_tiles_minus1[i]; k++) {
+            ctu_x = pps->tile_col_bd_val[tile_x + k];
+            ctu_y = pps->tile_row_bd_val[tile_y + j];
+            ctu_width = pps->tile_column_width_minus1[tile_x + k] + 1;
+            ctu_height = pps->tile_row_height_minus1[tile_y + j] + 1;
+
+            ctb_count = gst_h266_parser_add_slice_ctus_map (parser,
+                pps, slice_start_offset, ctu_x, ctu_y, ctu_width, ctu_height);
+            slice_start_offset += ctb_count;
+          }
+        }
+
+        parser->num_ctus_in_slice[i] =
+            slice_start_offset - parser->slice_start_offset[i];
+      }
+    }
+  } else {
+    for (tile_y = 0; tile_y < pps->num_tile_rows; tile_y++) {
+      for (tile_x = 0; tile_x < pps->num_tile_columns; tile_x++) {
+        for (ctu_y = pps->tile_row_bd_val[tile_y];
+            ctu_y < pps->tile_row_bd_val[tile_y] +
+            pps->tile_row_height_minus1[tile_y] + 1; ctu_y++) {
+          for (ctu_x = pps->tile_col_bd_val[tile_x];
+              ctu_x < pps->tile_col_bd_val[tile_x] +
+              pps->tile_column_width_minus1[tile_x] + 1; ctu_x++) {
+            g_assert (ctu_idx < pps->pic_size_in_ctbs_y);
+            parser->ctb_addr_in_slice[ctu_idx++] =
+                ctu_y * pps->pic_width_in_ctbs_y + ctu_x;
+          }
+        }
+      }
+    }
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_h266_parser_set_active_sps_pps (GstH266Parser * parser,
+    const GstH266SPS * sps, const GstH266PPS * pps)
+{
+  gboolean need_update = FALSE;
+
+  g_assert (sps->vps);
+  g_assert (sps->valid);
+  g_assert (pps->valid);
+
+  if (sps->vps != parser->active_vps) {
+    parser->active_vps = (GstH266VPS *) sps->vps;
+    need_update = TRUE;
+  }
+
+  if (sps != parser->active_sps) {
+    parser->active_sps = (GstH266SPS *) sps;
+    need_update = TRUE;
+  }
+
+  if (pps != parser->active_pps) {
+    parser->active_pps = (GstH266PPS *) pps;
+    need_update = TRUE;
+  }
+
+  if (need_update) {
+    if (!gst_h266_parser_generate_ctb_map (parser, pps))
+      return FALSE;
+
+    GST_DEBUG ("set active VPS:%d, SPS:%d, PPS:%d",
+        sps->vps->vps_id, sps->sps_id, pps->pps_id);
+  }
+
+  return TRUE;
+}
+
+/**
+ * gst_h266_parser_parse_pps:
+ * @parser: a #GstH266Parser
+ * @nalu: The #GST_H266_NAL_PPS #GstH266NalUnit to parse
+ * @pps: The #GstH266PPS to fill.
+ *
+ * Parses @data, and fills the @pps structure.
+ *
+ * Returns: a #GstH266ParserResult
+ *
+ * Since: 1.24
+ */
+GstH266ParserResult
+gst_h266_parser_parse_pps (GstH266Parser * parser,
+    GstH266NalUnit * nalu, GstH266PPS * pps)
+{
+  GstH266ParserResult res = gst_h266_parse_pps (parser, nalu, pps);
+
+  if (res == GST_H266_PARSER_OK) {
+    GST_DEBUG ("adding picture parameter set with id: %d to array",
+        pps->pps_id);
+
+    if (parser->active_pps && parser->active_pps->pps_id == pps->pps_id)
+      parser->active_pps = NULL;
+
+    parser->pps[pps->pps_id] = *pps;
+    parser->last_pps = &parser->pps[pps->pps_id];
+  }
+
+  return res;
+}
+
+/**
+ * gst_h266_parse_pps:
+ * @parser: a #GstH266Parser
+ * @nalu: The #GST_H266_NAL_PPS #GstH266NalUnit to parse
+ * @pps: The #GstH266PPS to fill.
+ *
+ * Parses @data, and fills the @pps structure.
+ *
+ * Returns: a #GstH266ParserResult
+ *
+ * Since: 1.24
+ */
+GstH266ParserResult
+gst_h266_parse_pps (GstH266Parser * parser, GstH266NalUnit * nalu,
+    GstH266PPS * pps)
+{
+  NalReader nr;
+  GstH266SPS *sps;
+  gint min_cb_size_y, ctb_size_y;
+  guint8 sub_width_c, sub_height_c;
+  const guint8 h266_sub_width_c[] = { 1, 2, 2, 1 };
+  const guint8 h266_sub_height_c[] = { 1, 2, 1, 1 };
+  gint QpBdOffset, i;
+
+  GST_DEBUG ("parsing \"Picture parameter set\"");
+
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+
+  memset (pps, 0, sizeof (*pps));
+
+  READ_UINT8 (&nr, pps->pps_id, 6);
+  READ_UINT8 (&nr, pps->sps_id, 4);
+
+  sps = gst_h266_parser_get_sps (parser, pps->sps_id);
+  if (!sps) {
+    GST_WARNING ("couldn't find associated sequence parameter set with id: %d",
+        pps->sps_id);
+    return GST_H266_PARSER_BROKEN_LINK;
+  }
+  pps->sps = sps;
+
+  ctb_size_y = 1 << (sps->log2_ctu_size_minus5 + 5);
+  min_cb_size_y = 1 << (sps->log2_min_luma_coding_block_size_minus2 + 2);
+  sub_width_c = h266_sub_width_c[sps->chroma_format_idc];
+  sub_height_c = h266_sub_height_c[sps->chroma_format_idc];
+
+  READ_UINT8 (&nr, pps->mixed_nalu_types_in_pic_flag, 1);
+
+  READ_UE_ALLOWED (&nr, pps->pic_width_in_luma_samples, 1,
+      sps->pic_width_max_in_luma_samples);
+  READ_UE_ALLOWED (&nr, pps->pic_height_in_luma_samples, 1,
+      sps->pic_height_max_in_luma_samples);
+
+  if (pps->pic_width_in_luma_samples % MAX (min_cb_size_y, 8) ||
+      pps->pic_height_in_luma_samples % MAX (min_cb_size_y, 8)) {
+    GST_WARNING ("Invalid dimensions: %ux%u not divisible "
+        "by %u, MinCbSizeY = %u.\n", pps->pic_width_in_luma_samples,
+        pps->pic_height_in_luma_samples, MAX (min_cb_size_y, 8), min_cb_size_y);
+    goto error;
+  }
+
+  if (!sps->res_change_in_clvs_allowed_flag &&
+      (pps->pic_width_in_luma_samples !=
+          sps->pic_width_max_in_luma_samples ||
+          pps->pic_height_in_luma_samples !=
+          sps->pic_height_max_in_luma_samples)) {
+    GST_WARNING ("Resoltuion change is not allowed, "
+        "resolution sps(%ux%u) mismatched with pps(%ux%u).\n",
+        sps->pic_width_max_in_luma_samples,
+        sps->pic_height_max_in_luma_samples,
+        pps->pic_width_in_luma_samples, pps->pic_height_in_luma_samples);
+    goto error;
+  }
+
+  if (sps->ref_wraparound_enabled_flag) {
+    if ((ctb_size_y / min_cb_size_y + 1) >
+        (pps->pic_width_in_luma_samples / min_cb_size_y - 1)) {
+      GST_WARNING ("The value %d of (CtbSizeY / MinCbSizeY + 1) shall be "
+          "less than or equal to the value %d of "
+          "(pps_pic_width_in_luma_samples / MinCbSizeY - 1).",
+          ctb_size_y / min_cb_size_y + 1,
+          pps->pic_width_in_luma_samples / min_cb_size_y - 1);
+      goto error;
+    }
+  }
+
+  READ_UINT8 (&nr, pps->conformance_window_flag, 1);
+  if (pps->conformance_window_flag &&
+      pps->pic_width_in_luma_samples == sps->pic_width_max_in_luma_samples &&
+      pps->pic_height_in_luma_samples == sps->pic_height_max_in_luma_samples) {
+    GST_WARNING ("When pps_pic_width_in_luma_samples is equal to "
+        "sps_pic_width_max_in_luma_samples and pps_pic_height_in_luma_samples "
+        "is equal to sps_pic_height_max_in_luma_samples, the value of "
+        "pps_conformance_window_flag shall be equal to 0");
+    goto error;
+  }
+
+  if (pps->conformance_window_flag) {
+    guint width, height;
+
+    width = pps->pic_width_in_luma_samples / sub_width_c;
+    height = pps->pic_height_in_luma_samples / sub_height_c;
+
+    READ_UE_MAX (&nr, pps->conf_win_left_offset, width);
+    READ_UE_MAX (&nr, pps->conf_win_right_offset, width);
+    READ_UE_MAX (&nr, pps->conf_win_top_offset, height);
+    READ_UE_MAX (&nr, pps->conf_win_bottom_offset, height);
+
+    if (sub_width_c * (pps->conf_win_left_offset +
+            pps->conf_win_right_offset) >= pps->pic_width_in_luma_samples
+        || sub_height_c * (pps->conf_win_top_offset +
+            pps->conf_win_bottom_offset) >= pps->pic_height_in_luma_samples) {
+      GST_WARNING ("Invalid pps conformance window: (%u, %u, %u, %u), "
+          "resolution is %ux%u, sub WxH is %ux%u.\n", pps->conf_win_left_offset,
+          pps->conf_win_right_offset, pps->conf_win_top_offset,
+          pps->conf_win_bottom_offset, pps->pic_width_in_luma_samples,
+          pps->pic_height_in_luma_samples, sub_width_c, sub_height_c);
+      goto error;
+    }
+  } else {
+    if (pps->pic_width_in_luma_samples ==
+        sps->pic_width_max_in_luma_samples &&
+        pps->pic_height_in_luma_samples ==
+        sps->pic_height_max_in_luma_samples) {
+      pps->conf_win_left_offset = sps->conf_win_left_offset;
+      pps->conf_win_right_offset = sps->conf_win_right_offset;
+      pps->conf_win_top_offset = sps->conf_win_top_offset;
+      pps->conf_win_bottom_offset = sps->conf_win_bottom_offset;
+    } else {
+      pps->conf_win_left_offset = 0;
+      pps->conf_win_right_offset = 0;
+      pps->conf_win_top_offset = 0;
+      pps->conf_win_bottom_offset = 0;
+    }
+  }
+
+  READ_UINT8 (&nr, pps->scaling_window_explicit_signalling_flag, 1);
+  if (pps->scaling_window_explicit_signalling_flag) {
+    if (!sps->ref_pic_resampling_enabled_flag) {
+      GST_WARNING ("When sps_ref_pic_resampling_enabled_flag is equal to 0, "
+          "the value of pps_scaling_window_explicit_signalling_flag "
+          "shall be equal to 0");
+      goto error;
+    }
+
+    READ_SE (&nr, pps->scaling_win_left_offset);
+    CHECK_ALLOWED (pps->scaling_win_left_offset * sub_width_c,
+        -pps->pic_width_in_luma_samples * 15, pps->pic_width_in_luma_samples);
+    READ_SE (&nr, pps->scaling_win_right_offset);
+    CHECK_ALLOWED (pps->scaling_win_right_offset * sub_width_c,
+        -pps->pic_width_in_luma_samples * 15, pps->pic_width_in_luma_samples);
+    READ_SE (&nr, pps->scaling_win_top_offset);
+    CHECK_ALLOWED (pps->scaling_win_top_offset * sub_height_c,
+        -pps->pic_height_in_luma_samples * 15, pps->pic_height_in_luma_samples);
+    READ_SE (&nr, pps->scaling_win_bottom_offset);
+    CHECK_ALLOWED (pps->scaling_win_bottom_offset * sub_height_c,
+        -pps->pic_height_in_luma_samples * 15, pps->pic_height_in_luma_samples);
+
+    CHECK_ALLOWED ((pps->scaling_win_left_offset +
+            pps->scaling_win_right_offset) * sub_width_c,
+        -pps->pic_width_in_luma_samples * 15, pps->pic_width_in_luma_samples);
+    CHECK_ALLOWED ((pps->scaling_win_top_offset +
+            pps->scaling_win_bottom_offset) * sub_height_c,
+        -pps->pic_height_in_luma_samples * 15, pps->pic_height_in_luma_samples);
+  } else {
+    pps->scaling_win_left_offset = pps->conf_win_left_offset;
+    pps->scaling_win_right_offset = pps->conf_win_right_offset;
+    pps->scaling_win_top_offset = pps->conf_win_top_offset;
+    pps->scaling_win_bottom_offset = pps->conf_win_bottom_offset;
+  }
+
+  READ_UINT8 (&nr, pps->output_flag_present_flag, 1);
+  READ_UINT8 (&nr, pps->no_pic_partition_flag, 1);
+
+  READ_UINT8 (&nr, pps->subpic_id_mapping_present_flag, 1);
+  if (pps->subpic_id_mapping_present_flag) {
+    if (!pps->no_pic_partition_flag) {
+      READ_UE (&nr, pps->num_subpics_minus1);
+      if (pps->num_subpics_minus1 != sps->num_subpics_minus1) {
+        GST_WARNING ("pps_num_subpics_minus1 shall be equal "
+            "to sps_num_subpics_minus1");
+        goto error;
+      }
+    } else {
+      pps->num_subpics_minus1 = 0;
+    }
+
+    READ_UE (&nr, pps->subpic_id_len_minus1);
+    if (pps->subpic_id_len_minus1 != sps->subpic_id_len_minus1) {
+      GST_WARNING ("pps_subpic_id_len_minus1 shall be equal "
+          "to sps_subpic_id_len_minus1");
+      goto error;
+    }
+
+    for (i = 0; i <= pps->num_subpics_minus1; i++)
+      READ_UINT16 (&nr, pps->subpic_id[i], pps->subpic_id_len_minus1 + 1);
+  }
+
+  pps->pic_width_in_ctbs_y =
+      (pps->pic_width_in_luma_samples + ctb_size_y - 1) / ctb_size_y;
+  pps->pic_height_in_ctbs_y =
+      (pps->pic_height_in_luma_samples + ctb_size_y - 1) / ctb_size_y;
+  pps->pic_size_in_ctbs_y =
+      pps->pic_width_in_ctbs_y * pps->pic_height_in_ctbs_y;
+
+  if (!pps->no_pic_partition_flag) {
+    if (!gst_h266_parser_parse_picture_partition (sps, pps, &nr))
+      goto error;
+  } else {
+    pps->single_slice_per_subpic_flag = 1;
+    pps->num_exp_tile_columns_minus1 = 0;
+    pps->tile_column_width_minus1[0] = pps->pic_width_in_ctbs_y - 1;
+    pps->num_exp_tile_rows_minus1 = 0;
+    pps->tile_row_height_minus1[0] = pps->pic_height_in_ctbs_y - 1;
+    pps->num_tile_columns = 1;
+    pps->num_tile_rows = 1;
+    pps->num_tiles_in_pic = 1;
+    pps->rect_slice_flag = 1;
+
+    pps->tile_col_bd_val[0] = 0;
+    for (i = 0; i < pps->num_tile_columns; i++) {
+      pps->tile_col_bd_val[i + 1] =
+          pps->tile_col_bd_val[i] + pps->tile_column_width_minus1[i] + 1;
+    }
+    pps->tile_row_bd_val[0] = 0;
+    for (i = 0; i < pps->num_tile_rows; i++) {
+      pps->tile_row_bd_val[i + 1] =
+          pps->tile_row_bd_val[i] + pps->tile_row_height_minus1[i] + 1;
+    }
+  }
+
+  READ_UINT8 (&nr, pps->cabac_init_present_flag, 1);
+
+  for (i = 0; i < 2; i++)
+    READ_UE_MAX (&nr, pps->num_ref_idx_default_active_minus1[i], 14);
+
+  READ_UINT8 (&nr, pps->rpl1_idx_present_flag, 1);
+  READ_UINT8 (&nr, pps->weighted_pred_flag, 1);
+  READ_UINT8 (&nr, pps->weighted_bipred_flag, 1);
+
+  READ_UINT8 (&nr, pps->ref_wraparound_enabled_flag, 1);
+  if (pps->ref_wraparound_enabled_flag)
+    READ_UE_MAX (&nr, pps->pic_width_minus_wraparound_offset,
+        (pps->pic_width_in_luma_samples / min_cb_size_y)
+        - (ctb_size_y / min_cb_size_y) - 2);
+
+  QpBdOffset = 6 * sps->bitdepth_minus8;
+  READ_SE_ALLOWED (&nr, pps->init_qp_minus26, -(26 + QpBdOffset), 37);
+  READ_UINT8 (&nr, pps->cu_qp_delta_enabled_flag, 1);
+  READ_UINT8 (&nr, pps->chroma_tool_offsets_present_flag, 1);
+  if (pps->chroma_tool_offsets_present_flag) {
+    READ_SE_ALLOWED (&nr, pps->cb_qp_offset, -12, 12);
+    READ_SE_ALLOWED (&nr, pps->cr_qp_offset, -12, 12);
+
+    READ_UINT8 (&nr, pps->joint_cbcr_qp_offset_present_flag, 1);
+    if (pps->joint_cbcr_qp_offset_present_flag) {
+      READ_SE_ALLOWED (&nr, pps->joint_cbcr_qp_offset_value, -12, 12);
+    } else {
+      pps->joint_cbcr_qp_offset_value = 0;
+    }
+
+    READ_UINT8 (&nr, pps->slice_chroma_qp_offsets_present_flag, 1);
+
+    READ_UINT8 (&nr, pps->cu_chroma_qp_offset_list_enabled_flag, 1);
+    if (pps->cu_chroma_qp_offset_list_enabled_flag) {
+      READ_UE_MAX (&nr, pps->chroma_qp_offset_list_len_minus1, 5);
+      for (i = 0; i <= pps->chroma_qp_offset_list_len_minus1; i++) {
+        READ_SE_ALLOWED (&nr, pps->cb_qp_offset_list[i], -12, 12);
+        READ_SE_ALLOWED (&nr, pps->cr_qp_offset_list[i], -12, 12);
+
+        if (pps->joint_cbcr_qp_offset_present_flag) {
+          READ_SE_ALLOWED (&nr, pps->joint_cbcr_qp_offset_list[i], -12, 12);
+        } else {
+          pps->joint_cbcr_qp_offset_list[i] = 0;
+        }
+      }
+    }
+  } else {
+    pps->cb_qp_offset = 0;
+    pps->cr_qp_offset = 0;
+    pps->joint_cbcr_qp_offset_present_flag = 0;
+    pps->joint_cbcr_qp_offset_value = 0;
+    pps->slice_chroma_qp_offsets_present_flag = 0;
+    pps->cu_chroma_qp_offset_list_enabled_flag = 0;
+  }
+
+  READ_UINT8 (&nr, pps->deblocking_filter_control_present_flag, 1);
+  if (pps->deblocking_filter_control_present_flag) {
+    READ_UINT8 (&nr, pps->deblocking_filter_override_enabled_flag, 1);
+    READ_UINT8 (&nr, pps->deblocking_filter_disabled_flag, 1);
+
+    if (!pps->no_pic_partition_flag &&
+        pps->deblocking_filter_override_enabled_flag) {
+      READ_UINT8 (&nr, pps->dbf_info_in_ph_flag, 1);
+    } else {
+      pps->dbf_info_in_ph_flag = 0;
+    }
+
+    if (!pps->deblocking_filter_disabled_flag) {
+      READ_SE_ALLOWED (&nr, pps->luma_beta_offset_div2, -12, 12);
+      READ_SE_ALLOWED (&nr, pps->luma_tc_offset_div2, -12, 12);
+
+      if (pps->chroma_tool_offsets_present_flag) {
+        READ_SE_ALLOWED (&nr, pps->cb_beta_offset_div2, -12, 12);
+        READ_SE_ALLOWED (&nr, pps->cb_tc_offset_div2, -12, 12);
+        READ_SE_ALLOWED (&nr, pps->cr_beta_offset_div2, -12, 12);
+        READ_SE_ALLOWED (&nr, pps->cr_tc_offset_div2, -12, 12);
+      } else {
+        pps->cb_beta_offset_div2 = 0;
+        pps->cb_tc_offset_div2 = 0;
+        pps->cr_beta_offset_div2 = pps->luma_beta_offset_div2;
+        pps->cr_tc_offset_div2 = pps->luma_tc_offset_div2;
+      }
+    } else {
+      pps->luma_beta_offset_div2 = 0;
+      pps->luma_tc_offset_div2 = 0;
+      pps->cb_beta_offset_div2 = 0;
+      pps->cb_tc_offset_div2 = 0;
+      pps->cr_beta_offset_div2 = pps->luma_beta_offset_div2;
+      pps->cr_tc_offset_div2 = pps->luma_tc_offset_div2;
+    }
+  } else {
+    pps->deblocking_filter_override_enabled_flag = 0;
+    pps->deblocking_filter_disabled_flag = 0;
+    pps->dbf_info_in_ph_flag = 0;
+    pps->luma_beta_offset_div2 = 0;
+    pps->luma_tc_offset_div2 = 0;
+    pps->cb_beta_offset_div2 = 0;
+    pps->cb_tc_offset_div2 = 0;
+    pps->cr_beta_offset_div2 = 0;
+    pps->cr_tc_offset_div2 = 0;
+  }
+
+  if (!pps->no_pic_partition_flag) {
+    READ_UINT8 (&nr, pps->rpl_info_in_ph_flag, 1);
+    READ_UINT8 (&nr, pps->sao_info_in_ph_flag, 1);
+    READ_UINT8 (&nr, pps->alf_info_in_ph_flag, 1);
+
+    if ((pps->weighted_pred_flag || pps->weighted_bipred_flag) &&
+        pps->rpl_info_in_ph_flag)
+      READ_UINT8 (&nr, pps->wp_info_in_ph_flag, 1);
+
+    READ_UINT8 (&nr, pps->qp_delta_info_in_ph_flag, 1);
+  }
+
+  READ_UINT8 (&nr, pps->picture_header_extension_present_flag, 1);
+  READ_UINT8 (&nr, pps->slice_header_extension_present_flag, 1);
+
+  READ_UINT8 (&nr, pps->extension_flag, 1);
+  if (pps->extension_flag) {
+    GST_WARNING ("extension_flag is not supported in current version pps.");
+    goto error;
+  }
+
+  /* calculate width and height */
+  pps->width = pps->pic_width_in_luma_samples;
+  pps->height = pps->pic_height_in_luma_samples;
+  if (pps->conformance_window_flag) {
+    pps->crop_rect_width = pps->width -
+        (pps->conf_win_left_offset + pps->conf_win_right_offset) * sub_width_c;
+    pps->crop_rect_height = pps->height -
+        (pps->conf_win_top_offset + pps->conf_win_bottom_offset) * sub_height_c;
+    pps->crop_rect_x = pps->conf_win_left_offset * sub_width_c;
+    pps->crop_rect_y = pps->conf_win_top_offset * sub_height_c;
+
+    GST_LOG ("crop_rectangle x=%u y=%u width=%u, height=%u", pps->crop_rect_x,
+        pps->crop_rect_y, pps->crop_rect_width, pps->crop_rect_height);
+  }
+
+  pps->valid = TRUE;
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Picture parameter set\"");
+  pps->valid = FALSE;
+  return GST_H266_PARSER_ERROR;
+}
+
+/**
+ * gst_h266_parser_parse_pps:
+ * @parser: a #GstH266Parser
+ * @nalu: The #GST_H266_APS_NUT #GstH266NalUnit to parse
+ * @pps: The #GstH266APS to fill.
+ *
+ * Parses @data, and fills the @aps structure.
+ *
+ * Returns: a #GstH266ParserResult
+ *
+ * Since: 1.24
+ */
+GstH266ParserResult
+gst_h266_parser_parse_aps (GstH266Parser * parser,
+    GstH266NalUnit * nalu, GstH266APS * aps)
+{
+  GstH266ParserResult res = gst_h266_parse_aps (parser, nalu, aps);
+
+  if (res == GST_H266_PARSER_OK) {
+    GST_DEBUG ("adding adaptation parameter set with id: %d to array",
+        aps->aps_id);
+    parser->aps[aps->params_type][aps->aps_id] = *aps;
+    parser->last_aps[aps->params_type] =
+        &parser->aps[aps->params_type][aps->aps_id];
+  }
+
+  return res;
+}
+
+/**
+ * gst_h266_parse_aps:
+ * @parser: a #GstH266Parser
+ * @nalu: The #GST_H266_APS_NUT #GstH266NalUnit to parse
+ * @pps: The #GstH266PPS to fill.
+ *
+ * Parses @data, and fills the @aps structure.
+ *
+ * Returns: a #GstH266ParserResult
+ */
+GstH266ParserResult
+gst_h266_parse_aps (GstH266Parser * parser, GstH266NalUnit * nalu,
+    GstH266APS * aps)
+{
+  NalReader nr;
+  guint8 params_type;
+
+  GST_DEBUG ("parsing APS");
+
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+
+  memset (aps, 0, sizeof (*aps));
+
+  READ_UINT8 (&nr, params_type, 3);
+  aps->params_type = params_type;
+  READ_UINT8 (&nr, aps->aps_id, 5);
+  CHECK_ALLOWED_MAX (aps->aps_id, GST_H266_MAX_APS_COUNT);
+  READ_UINT8 (&nr, aps->chroma_present_flag, 1);
+
+  switch (aps->params_type) {
+    case GST_H266_ALF_APS:
+      if (!gst_h266_parse_alf (&aps->alf, &nr, aps->chroma_present_flag))
+        goto error;
+      break;
+    case GST_H266_LMCS_APS:
+      if (!gst_h266_parse_lmcs (&aps->lmcs, &nr, aps->chroma_present_flag))
+        goto error;
+      break;
+    case GST_H266_SCALING_APS:
+      if (!gst_h266_parse_scaling_list (&aps->sl, &nr,
+              aps->chroma_present_flag))
+        goto error;
+      break;
+    default:
+      GST_WARNING ("unknown APS params_type %d", aps->params_type);
+      goto error;
+      break;
+  }
+
+  READ_UINT8 (&nr, aps->extension_flag, 1);
+  if (aps->extension_flag) {
+    READ_UINT8 (&nr, aps->extension_data_flag, 1);
+    if (aps->extension_data_flag) {
+      GST_WARNING ("extension_data_flag shall be equal to 0 "
+          "in current version aps.");
+      goto error;
+    }
+  }
+
+  aps->valid = TRUE;
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Adaptation parameter set\"");
+  aps->valid = FALSE;
+  return GST_H266_PARSER_ERROR;
+}
+
+GstH266ParserResult
+gst_h266_parser_parse_aud (GstH266Parser * parser,
+    GstH266NalUnit * nalu, GstH266AUD * aud)
+{
+  NalReader nr;
+
+  GST_DEBUG ("parsing Access Unit Delimiter");
+
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+
+  memset (aud, 0, sizeof (*aud));
+
+  READ_UINT8 (&nr, aud->irap_or_gdr_flag, 1);
+  READ_UINT8 (&nr, aud->pic_type, 3);
+  CHECK_ALLOWED_MAX (aud->pic_type, 2);
+
+  /* Skip the byte alignment bits */
+  if (!nal_reader_skip (&nr, 1))
+    goto error;
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Access Unit Delimiter\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+GstH266ParserResult
+gst_h266_parser_parse_opi (GstH266Parser * parser,
+    GstH266NalUnit * nalu, GstH266OPI * opi)
+{
+  NalReader nr;
+
+  GST_DEBUG ("parsing Operating Point Information");
+
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+
+  memset (opi, 0, sizeof (*opi));
+
+  READ_UINT8 (&nr, opi->ols_info_present_flag, 1);
+  READ_UINT8 (&nr, opi->htid_info_present_flag, 1);
+
+  if (opi->ols_info_present_flag)
+    READ_UE (&nr, opi->ols_idx);
+
+  if (opi->htid_info_present_flag)
+    READ_UINT8 (&nr, opi->htid_plus1, 3);
+
+  READ_UINT8 (&nr, opi->extension_flag, 1);
+  if (opi->extension_flag) {
+    GST_WARNING ("extension_flag is not supported in current version OPI.");
+    goto error;
+  }
+
+  /* Skip the byte alignment bits */
+  if (!nal_reader_skip (&nr, 1))
+    goto error;
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Operating Point Information\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+GstH266ParserResult
+gst_h266_parser_parse_dci (GstH266Parser * parser,
+    GstH266NalUnit * nalu, GstH266DCI * dci)
+{
+  NalReader nr;
+  guint8 dci_reserved_zero_4bits;
+  guint i;
+
+  GST_DEBUG ("parsing Decoding Capability Information");
+
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+
+  memset (dci, 0, sizeof (*dci));
+
+  READ_UINT8 (&nr, dci_reserved_zero_4bits, 4);
+  READ_UINT8 (&nr, dci->num_ptls_minus1, 4);
+  CHECK_ALLOWED_MAX (dci->num_ptls_minus1, 15);
+  for (i = 0; i <= dci->num_ptls_minus1; i++) {
+    if (!gst_h266_parse_profile_tier_level (&dci->profile_tier_level[i],
+            &nr, 1, 0))
+      goto error;
+  }
+
+  READ_UINT8 (&nr, dci->extension_flag, 1);
+  if (dci->extension_flag) {
+    GST_WARNING ("extension_flag is not supported in current version DCI.");
+    goto error;
+  }
+
+  /* Skip the byte alignment bits */
+  if (!nal_reader_skip (&nr, 1))
+    goto error;
+
+  return GST_H266_PARSER_OK;
+
+error:
+  GST_WARNING ("error parsing \"Decoding Capability Information\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+static gboolean
+gst_h266_parse_pred_weight_table (GstH266PredWeightTable * pwt, NalReader * nr,
+    const GstH266SPS * sps, const GstH266PPS * pps,
+    const GstH266RefPicLists * ref_lists, const guint8 num_ref_idx_active[2])
+{
+  gint i, j;
+
+  GST_DEBUG ("parsing Pred Weight Table");
+
+  memset (pwt, 0, sizeof (*pwt));
+
+  READ_UE_MAX (nr, pwt->luma_log2_weight_denom, 7);
+
+  if (sps->chroma_format_idc != 0) {
+    gint luma_log2_weight_denom = pwt->luma_log2_weight_denom;
+
+    READ_SE_ALLOWED (nr, pwt->delta_chroma_log2_weight_denom,
+        -luma_log2_weight_denom, 7 - luma_log2_weight_denom);
+  } else {
+    pwt->delta_chroma_log2_weight_denom = 0;
+  }
+
+  if (pps->wp_info_in_ph_flag) {
+    READ_UE_MAX (nr, pwt->num_l0_weights, MIN (15,
+            ref_lists->rpl_ref_list[0].num_ref_entries));
+  } else {
+    pwt->num_l0_weights = num_ref_idx_active[0];
+  }
+
+  for (i = 0; i < pwt->num_l0_weights; i++)
+    READ_UINT8 (nr, pwt->luma_weight_l0_flag[i], 1);
+
+  if (sps->chroma_format_idc != 0) {
+    for (i = 0; i < pwt->num_l0_weights; i++)
+      READ_UINT8 (nr, pwt->chroma_weight_l0_flag[i], 1);
+  }
+
+  for (i = 0; i < pwt->num_l0_weights; i++) {
+    if (pwt->luma_weight_l0_flag[i]) {
+      READ_SE_ALLOWED (nr, pwt->delta_luma_weight_l0[i], -128, 127);
+      READ_SE_ALLOWED (nr, pwt->luma_offset_l0[i], -128, 127);
+    } else {
+      pwt->delta_luma_weight_l0[i] = 0;
+      pwt->luma_offset_l0[i] = 0;
+    }
+
+    if (pwt->chroma_weight_l0_flag[i]) {
+      for (j = 0; j < 2; j++) {
+        READ_SE_ALLOWED (nr, pwt->delta_chroma_weight_l0[i][j], -128, 127);
+        READ_SE_ALLOWED (nr, pwt->delta_chroma_offset_l0[i][j], -4 * 128,
+            4 * 127);
+      }
+    }
+  }
+
+  if (pps->weighted_bipred_flag && pps->wp_info_in_ph_flag &&
+      ref_lists->rpl_ref_list[1].num_ref_entries > 0) {
+  }
+
+  if (!pps->weighted_bipred_flag
+      || ref_lists->rpl_ref_list[1].num_ref_entries == 0) {
+    pwt->num_l1_weights = 0;
+  } else if (pps->wp_info_in_ph_flag) {
+    READ_UE_MAX (nr, pwt->num_l1_weights, MIN (15,
+            ref_lists->rpl_ref_list[1].num_ref_entries));
+  } else {
+    pwt->num_l1_weights = num_ref_idx_active[1];
+  }
+
+  for (i = 0; i < pwt->num_l1_weights; i++)
+    READ_UINT8 (nr, pwt->luma_weight_l1_flag[i], 1);
+
+  if (sps->chroma_format_idc != 0) {
+    for (i = 0; i < pwt->num_l1_weights; i++)
+      READ_UINT8 (nr, pwt->chroma_weight_l1_flag[i], 1);
+  }
+
+  for (i = 0; i < pwt->num_l1_weights; i++) {
+    if (pwt->luma_weight_l1_flag[i]) {
+      READ_SE_ALLOWED (nr, pwt->delta_luma_weight_l1[i], -128, 127);
+      READ_SE_ALLOWED (nr, pwt->luma_offset_l1[i], -128, 127);
+    } else {
+      pwt->delta_luma_weight_l1[i] = 0;
+      pwt->luma_offset_l1[i] = 0;
+    }
+
+    if (pwt->chroma_weight_l1_flag[i]) {
+      for (j = 0; j < 2; j++) {
+        READ_SE_ALLOWED (nr, pwt->delta_chroma_weight_l1[i][j], -128, 127);
+        READ_SE_ALLOWED (nr, pwt->delta_chroma_offset_l1[i][j], -4 * 128,
+            4 * 127);
+      }
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing \"Pred Weight Table\"");
+  return FALSE;
+}
+
+static void
+gst_h266_parse_inherit_deblock_param_from_pps (GstH266PicHdr * ph)
+{
+  ph->luma_beta_offset_div2 = ph->pps->luma_beta_offset_div2;
+  ph->luma_tc_offset_div2 = ph->pps->luma_tc_offset_div2;
+  ph->cb_beta_offset_div2 = ph->pps->cb_beta_offset_div2;
+  ph->cb_tc_offset_div2 = ph->pps->cb_tc_offset_div2;
+  ph->cr_beta_offset_div2 = ph->pps->cr_beta_offset_div2;
+  ph->cr_tc_offset_div2 = ph->pps->cr_tc_offset_div2;
+}
+
+static GstH266ParserResult
+gst_h266_parse_picture_hdr_structure (GstH266PicHdr * ph,
+    NalReader * nr, GstH266Parser * parser)
+{
+  const GstH266SPS *sps;
+  guint ctb_log2_size_y, min_cb_log2_size_y, i;
+  GstH266ParserResult ret = GST_H266_PARSER_OK;
+
+  GST_DEBUG ("parsing Picture Header Structure");
+
+  READ_UINT8 (nr, ph->gdr_or_irap_pic_flag, 1);
+  READ_UINT8 (nr, ph->non_ref_pic_flag, 1);
+
+  if (ph->gdr_or_irap_pic_flag) {
+    READ_UINT8 (nr, ph->gdr_pic_flag, 1);
+  } else {
+    ph->gdr_pic_flag = 0;
+  }
+
+  READ_UINT8 (nr, ph->inter_slice_allowed_flag, 1);
+  if (ph->inter_slice_allowed_flag) {
+    READ_UINT8 (nr, ph->intra_slice_allowed_flag, 1);
+  } else {
+    ph->intra_slice_allowed_flag = 1;
+  }
+
+  READ_UE_MAX (nr, ph->pps_id, GST_H266_MAX_PPS_COUNT - 1);
+  ph->pps = gst_h266_parser_get_pps (parser, ph->pps_id);
+  if (!ph->pps) {
+    GST_WARNING ("PPS id %d not available.", ph->pps_id);
+    ret = GST_H266_PARSER_BROKEN_LINK;
+    goto error_with_ret;
+  }
+  sps = gst_h266_parser_get_sps (parser, ph->pps->sps_id);
+  if (!sps) {
+    GST_WARNING ("SPS id %d not available.", ph->pps->sps_id);
+    ret = GST_H266_PARSER_BROKEN_LINK;
+    goto error_with_ret;
+  }
+
+  READ_UINT16 (nr, ph->pic_order_cnt_lsb,
+      sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+
+  if (ph->gdr_pic_flag)
+    READ_UE_MAX (nr, ph->recovery_poc_cnt,
+        1 << (sps->log2_max_pic_order_cnt_lsb_minus4 + 4));
+
+  if ((!ph->gdr_or_irap_pic_flag || ph->gdr_pic_flag) &&
+      (!ph->gdr_pic_flag || ph->recovery_poc_cnt != 0)) {
+    const GstH266GeneralConstraintsInfo *general_constraints_info =
+        &sps->profile_tier_level.general_constraints_info;
+
+    if (sps->profile_tier_level.profile_idc & GST_H266_PROFILE_INTRA) {
+      GST_WARNING ("Invalid non-irap pictures or gdr "
+          "pictures with ph_recovery_poc_cnt!=0 for Intra profile");
+      goto error;
+    }
+
+    if (general_constraints_info->all_rap_pictures_constraint_flag) {
+      GST_WARNING ("gci_all_rap_pictures_flag equal to 1 specifies that "
+          "all pictures in OlsInScope are IRAP pictures or GDR pictures "
+          "with ph_recovery_poc_cnt equal to 0");
+      goto error;
+    }
+  }
+
+  for (i = 0; i < sps->num_extra_ph_bytes * 8; i++) {
+    /* extra bits are ignored now */
+    if (sps->extra_ph_bit_present_flag[i])
+      READ_UINT8 (nr, ph->extra_bit[i], 1);
+  }
+
+  if (sps->poc_msb_cycle_flag) {
+    READ_UINT8 (nr, ph->poc_msb_cycle_present_flag, 1);
+    if (ph->poc_msb_cycle_present_flag)
+      READ_UINT8 (nr, ph->poc_msb_cycle_val, sps->poc_msb_cycle_len_minus1 + 1);
+  }
+
+  if (sps->alf_enabled_flag && ph->pps->alf_info_in_ph_flag) {
+    READ_UINT8 (nr, ph->alf_enabled_flag, 1);
+    if (ph->alf_enabled_flag) {
+      READ_UINT8 (nr, ph->num_alf_aps_ids_luma, 3);
+      for (i = 0; i < ph->num_alf_aps_ids_luma; i++)
+        READ_UINT8 (nr, ph->alf_aps_id_luma[i], 3);
+
+      if (sps->chroma_format_idc != 0) {
+        READ_UINT8 (nr, ph->alf_cb_enabled_flag, 1);
+        READ_UINT8 (nr, ph->alf_cr_enabled_flag, 1);
+      } else {
+        ph->alf_cb_enabled_flag = 0;
+        ph->alf_cr_enabled_flag = 0;
+      }
+
+      if (ph->alf_cb_enabled_flag || ph->alf_cr_enabled_flag)
+        READ_UINT8 (nr, ph->alf_aps_id_chroma, 3);
+
+      if (sps->ccalf_enabled_flag) {
+        READ_UINT8 (nr, ph->alf_cc_cb_enabled_flag, 1);
+        if (ph->alf_cc_cb_enabled_flag)
+          READ_UINT8 (nr, ph->alf_cc_cb_aps_id, 3);
+
+        READ_UINT8 (nr, ph->alf_cc_cr_enabled_flag, 1);
+        if (ph->alf_cc_cr_enabled_flag)
+          READ_UINT8 (nr, ph->alf_cc_cr_aps_id, 3);
+      }
+    }
+  } else {
+    ph->alf_enabled_flag = 0;
+  }
+
+  if (sps->lmcs_enabled_flag) {
+    READ_UINT8 (nr, ph->lmcs_enabled_flag, 1);
+    if (ph->lmcs_enabled_flag) {
+      READ_UINT8 (nr, ph->lmcs_aps_id, 2);
+
+      if (sps->chroma_format_idc != 0) {
+        READ_UINT8 (nr, ph->chroma_residual_scale_flag, 1);
+      } else {
+        ph->chroma_residual_scale_flag = 0;
+      }
+    }
+  } else {
+    ph->lmcs_enabled_flag = 0;
+    ph->chroma_residual_scale_flag = 0;
+  }
+
+  if (sps->explicit_scaling_list_enabled_flag) {
+    READ_UINT8 (nr, ph->explicit_scaling_list_enabled_flag, 1);
+    if (ph->explicit_scaling_list_enabled_flag)
+      READ_UINT8 (nr, ph->scaling_list_aps_id, 3);
+  } else {
+    ph->explicit_scaling_list_enabled_flag = 0;
+  }
+
+  if (sps->virtual_boundaries_enabled_flag &&
+      !sps->virtual_boundaries_present_flag) {
+    READ_UINT8 (nr, ph->virtual_boundaries_present_flag, 1);
+    if (ph->virtual_boundaries_present_flag) {
+      READ_UE_MAX (nr, ph->num_ver_virtual_boundaries,
+          ((ph->pps->pic_width_in_luma_samples <= 8) ? 0 : 3));
+      for (i = 0; i < ph->num_ver_virtual_boundaries; i++)
+        READ_UE_MAX (nr, ph->virtual_boundary_pos_x_minus1[i],
+            (ph->pps->pic_width_in_luma_samples + 7) / 8 - 2);
+
+      READ_UE_MAX (nr, ph->num_hor_virtual_boundaries,
+          ((ph->pps->pic_height_in_luma_samples <= 8) ? 0 : 3));
+      for (i = 0; i < ph->num_hor_virtual_boundaries; i++) {
+        READ_UE_MAX (nr, ph->virtual_boundary_pos_y_minus1[i],
+            (ph->pps->pic_height_in_luma_samples + 7) / 8 - 2);
+      }
+    } else {
+      ph->num_ver_virtual_boundaries = 0;
+      ph->num_hor_virtual_boundaries = 0;
+    }
+  }
+
+  if (ph->pps->output_flag_present_flag && !ph->non_ref_pic_flag) {
+    READ_UINT8 (nr, ph->pic_output_flag, 1);
+  } else {
+    ph->pic_output_flag = 1;
+  }
+
+  if (ph->pps->rpl_info_in_ph_flag) {
+    if (!gst_h266_ref_pic_lists (&ph->ref_pic_lists, nr, sps, ph->pps))
+      goto error;
+  }
+
+  if (sps->partition_constraints_override_enabled_flag) {
+    READ_UINT8 (nr, ph->partition_constraints_override_flag, 1);
+  } else {
+    ph->partition_constraints_override_flag = 0;
+  }
+
+  ctb_log2_size_y = sps->log2_ctu_size_minus5 + 5;
+  min_cb_log2_size_y = sps->log2_min_luma_coding_block_size_minus2 + 2;
+
+  ph->log2_diff_min_qt_min_cb_intra_slice_luma =
+      sps->log2_diff_min_qt_min_cb_intra_slice_luma;
+  ph->max_mtt_hierarchy_depth_intra_slice_luma =
+      sps->max_mtt_hierarchy_depth_intra_slice_luma;
+  ph->log2_diff_max_bt_min_qt_intra_slice_luma =
+      sps->log2_diff_max_bt_min_qt_intra_slice_luma;
+  ph->log2_diff_max_tt_min_qt_intra_slice_luma =
+      sps->log2_diff_max_tt_min_qt_intra_slice_luma;
+  ph->log2_diff_min_qt_min_cb_intra_slice_chroma =
+      sps->log2_diff_min_qt_min_cb_intra_slice_chroma;
+  ph->max_mtt_hierarchy_depth_intra_slice_chroma =
+      sps->max_mtt_hierarchy_depth_intra_slice_chroma;
+  ph->log2_diff_max_bt_min_qt_intra_slice_chroma =
+      sps->log2_diff_max_bt_min_qt_intra_slice_chroma;
+  ph->log2_diff_max_tt_min_qt_intra_slice_chroma =
+      sps->log2_diff_max_tt_min_qt_intra_slice_chroma;
+
+  ph->log2_diff_min_qt_min_cb_inter_slice =
+      sps->log2_diff_min_qt_min_cb_inter_slice;
+  ph->max_mtt_hierarchy_depth_inter_slice =
+      sps->max_mtt_hierarchy_depth_inter_slice;
+  ph->log2_diff_max_bt_min_qt_inter_slice =
+      sps->log2_diff_max_bt_min_qt_inter_slice;
+  ph->log2_diff_max_tt_min_qt_inter_slice =
+      sps->log2_diff_max_tt_min_qt_inter_slice;
+
+  ph->collocated_from_l0_flag = 1;
+
+  if (ph->intra_slice_allowed_flag) {
+    guint min_qt_log2_size_intra_y;
+
+    if (ph->partition_constraints_override_flag) {
+      READ_UE_MAX (nr, ph->log2_diff_min_qt_min_cb_intra_slice_luma,
+          MIN (6, ctb_log2_size_y) - min_cb_log2_size_y);
+      min_qt_log2_size_intra_y =
+          ph->log2_diff_min_qt_min_cb_intra_slice_luma + min_cb_log2_size_y;
+
+      READ_UE_MAX (nr, ph->max_mtt_hierarchy_depth_intra_slice_luma,
+          2 * (ctb_log2_size_y - min_cb_log2_size_y));
+
+      if (ph->max_mtt_hierarchy_depth_intra_slice_luma != 0) {
+        READ_UE_MAX (nr, ph->log2_diff_max_bt_min_qt_intra_slice_luma,
+            ctb_log2_size_y - min_qt_log2_size_intra_y);
+        READ_UE_MAX (nr, ph->log2_diff_max_tt_min_qt_intra_slice_luma,
+            MIN (6, ctb_log2_size_y) - min_qt_log2_size_intra_y);
+      } else {
+        ph->log2_diff_max_bt_min_qt_intra_slice_luma =
+            sps->log2_diff_max_bt_min_qt_intra_slice_luma;
+        ph->log2_diff_max_tt_min_qt_intra_slice_luma =
+            sps->log2_diff_max_tt_min_qt_intra_slice_luma;
+      }
+
+      if (sps->qtbtt_dual_tree_intra_flag) {
+        READ_UE_MAX (nr, ph->log2_diff_min_qt_min_cb_intra_slice_chroma,
+            MIN (6, ctb_log2_size_y) - min_cb_log2_size_y);
+        READ_UE_MAX (nr, ph->max_mtt_hierarchy_depth_intra_slice_chroma,
+            2 * (ctb_log2_size_y - min_cb_log2_size_y));
+
+        if (sps->max_mtt_hierarchy_depth_intra_slice_chroma != 0) {
+          gint32 min_qt_log2_size_intra_c =
+              sps->log2_diff_min_qt_min_cb_intra_slice_chroma +
+              min_cb_log2_size_y;
+
+          READ_UE_MAX (nr, ph->log2_diff_max_bt_min_qt_intra_slice_chroma,
+              MIN (6, ctb_log2_size_y) - min_qt_log2_size_intra_c);
+          READ_UE_MAX (nr, ph->log2_diff_max_tt_min_qt_intra_slice_chroma,
+              MIN (6, ctb_log2_size_y) - min_qt_log2_size_intra_c);
+        } else {
+          ph->log2_diff_max_bt_min_qt_intra_slice_chroma =
+              sps->log2_diff_max_bt_min_qt_intra_slice_chroma;
+          ph->log2_diff_max_tt_min_qt_intra_slice_chroma =
+              sps->log2_diff_max_tt_min_qt_intra_slice_chroma;
+        }
+      }
+    }
+
+    min_qt_log2_size_intra_y =
+        ph->log2_diff_min_qt_min_cb_intra_slice_luma + ctb_log2_size_y;
+
+    if (ph->pps->cu_qp_delta_enabled_flag) {
+      READ_UE_MAX (nr, ph->cu_qp_delta_subdiv_intra_slice,
+          2 * (ctb_log2_size_y - min_qt_log2_size_intra_y +
+              ph->max_mtt_hierarchy_depth_intra_slice_luma));
+    } else {
+      ph->cu_qp_delta_subdiv_intra_slice = 0;
+    }
+
+    if (ph->pps->cu_chroma_qp_offset_list_enabled_flag) {
+      READ_UE_MAX (nr, ph->cu_chroma_qp_offset_subdiv_intra_slice,
+          2 * (ctb_log2_size_y - min_qt_log2_size_intra_y +
+              ph->max_mtt_hierarchy_depth_intra_slice_luma));
+    } else {
+      ph->cu_chroma_qp_offset_subdiv_intra_slice = 0;
+    }
+  }
+
+  if (ph->inter_slice_allowed_flag) {
+    guint min_qt_log2_size_inter_y;
+
+    if (ph->partition_constraints_override_flag) {
+      READ_UE_MAX (nr, ph->log2_diff_min_qt_min_cb_inter_slice,
+          MIN (6, ctb_log2_size_y) - min_cb_log2_size_y);
+      min_qt_log2_size_inter_y =
+          ph->log2_diff_min_qt_min_cb_inter_slice + min_cb_log2_size_y;
+
+      READ_UE_MAX (nr, ph->max_mtt_hierarchy_depth_inter_slice,
+          2 * (ctb_log2_size_y - min_cb_log2_size_y));
+      if (ph->max_mtt_hierarchy_depth_inter_slice != 0) {
+        READ_UE_MAX (nr, ph->log2_diff_max_bt_min_qt_inter_slice,
+            ctb_log2_size_y - min_qt_log2_size_inter_y);
+        READ_UE_MAX (nr, ph->log2_diff_max_tt_min_qt_inter_slice,
+            MIN (6, ctb_log2_size_y) - min_qt_log2_size_inter_y);
+      }
+    }
+
+    min_qt_log2_size_inter_y =
+        ph->log2_diff_min_qt_min_cb_inter_slice + min_cb_log2_size_y;
+
+    if (ph->pps->cu_qp_delta_enabled_flag) {
+      READ_UE_MAX (nr, ph->cu_qp_delta_subdiv_inter_slice,
+          2 * (ctb_log2_size_y - min_qt_log2_size_inter_y +
+              ph->max_mtt_hierarchy_depth_inter_slice));
+    } else {
+      ph->cu_qp_delta_subdiv_inter_slice = 0;
+    }
+
+    if (ph->pps->cu_chroma_qp_offset_list_enabled_flag) {
+      READ_UE_MAX (nr, ph->cu_chroma_qp_offset_subdiv_inter_slice,
+          2 * (ctb_log2_size_y - min_qt_log2_size_inter_y +
+              ph->max_mtt_hierarchy_depth_inter_slice));
+    } else {
+      ph->cu_chroma_qp_offset_subdiv_inter_slice = 0;
+    }
+
+    if (sps->temporal_mvp_enabled_flag) {
+      READ_UINT8 (nr, ph->temporal_mvp_enabled_flag, 1);
+      if (ph->temporal_mvp_enabled_flag && ph->pps->rpl_info_in_ph_flag) {
+        if (ph->ref_pic_lists.rpl_ref_list[1].num_ref_entries > 0) {
+          READ_UINT8 (nr, ph->collocated_from_l0_flag, 1);
+        } else {
+          ph->collocated_from_l0_flag = 1;
+        }
+
+        if ((ph->collocated_from_l0_flag &&
+                ph->ref_pic_lists.rpl_ref_list[0].num_ref_entries > 1) ||
+            (!ph->collocated_from_l0_flag &&
+                ph->ref_pic_lists.rpl_ref_list[1].num_ref_entries > 1)) {
+          guint idx = ph->collocated_from_l0_flag ? 0 : 1;
+
+          READ_UE_MAX (nr, ph->collocated_ref_idx,
+              ph->ref_pic_lists.rpl_ref_list[idx].num_ref_entries - 1);
+        } else {
+          ph->collocated_ref_idx = 0;
+        }
+      }
+    }
+
+    if (sps->mmvd_fullpel_only_enabled_flag) {
+      READ_UINT8 (nr, ph->mmvd_fullpel_only_flag, 1);
+    } else {
+      ph->mmvd_fullpel_only_flag = 0;
+    }
+
+    if (!ph->pps->rpl_info_in_ph_flag ||
+        ph->ref_pic_lists.rpl_ref_list[1].num_ref_entries > 0) {
+      READ_UINT8 (nr, ph->mvd_l1_zero_flag, 1);
+
+      if (sps->bdof_control_present_in_ph_flag) {
+        READ_UINT8 (nr, ph->bdof_disabled_flag, 1);
+      } else {
+        if (!sps->bdof_control_present_in_ph_flag)
+          ph->bdof_disabled_flag = !sps->bdof_enabled_flag;
+        else
+          ph->bdof_disabled_flag = 1;
+      }
+
+      if (sps->dmvr_control_present_in_ph_flag) {
+        READ_UINT8 (nr, ph->dmvr_disabled_flag, 1);
+      } else {
+        if (!sps->dmvr_control_present_in_ph_flag)
+          ph->dmvr_disabled_flag = !sps->dmvr_enabled_flag;
+        else
+          ph->dmvr_disabled_flag = 1;
+      }
+    } else {
+      ph->mvd_l1_zero_flag = 1;
+    }
+
+    if (sps->prof_control_present_in_ph_flag) {
+      READ_UINT8 (nr, ph->prof_disabled_flag, 1);
+    } else {
+      ph->prof_disabled_flag = !sps->affine_prof_enabled_flag;
+    }
+
+    if ((ph->pps->weighted_pred_flag ||
+            ph->pps->weighted_bipred_flag) && ph->pps->wp_info_in_ph_flag) {
+      guint8 num_ref_idx_active[2];
+
+      num_ref_idx_active[0] = ph->ref_pic_lists.rpl_ref_list[0].num_ref_entries;
+      num_ref_idx_active[1] = ph->ref_pic_lists.rpl_ref_list[1].num_ref_entries;
+
+      if (!gst_h266_parse_pred_weight_table (&ph->pred_weight_table,
+              nr, sps, ph->pps, &ph->ref_pic_lists, num_ref_idx_active))
+        goto error;
+    }
+  }
+
+  if (ph->pps->qp_delta_info_in_ph_flag) {
+    /* SliceQpy = 26 + pps_init_qp_minus26 + ph_qp_delta,
+       The value of SliceQp Y shall be in the range of
+       -QpBdOffset to +63, inclusive */
+    gint qp_bd_offset = 6 * sps->bitdepth_minus8;
+    READ_SE_ALLOWED (nr, ph->qp_delta,
+        -qp_bd_offset - (26 + ph->pps->init_qp_minus26),
+        63 - (26 + ph->pps->init_qp_minus26));
+  }
+
+  if (sps->joint_cbcr_enabled_flag) {
+    READ_UINT8 (nr, ph->joint_cbcr_sign_flag, 1);
+  } else {
+    ph->joint_cbcr_sign_flag = 0;
+  }
+
+  if (sps->sao_enabled_flag && ph->pps->sao_info_in_ph_flag) {
+    READ_UINT8 (nr, ph->sao_luma_enabled_flag, 1);
+    if (sps->chroma_format_idc != 0) {
+      READ_UINT8 (nr, ph->sao_chroma_enabled_flag, 1);
+    } else
+      ph->sao_chroma_enabled_flag = 0;
+  } else {
+    ph->sao_luma_enabled_flag = 0;
+    ph->sao_chroma_enabled_flag = 0;
+  }
+
+  if (ph->pps->dbf_info_in_ph_flag) {
+    READ_UINT8 (nr, ph->deblocking_params_present_flag, 1);
+    if (ph->deblocking_params_present_flag) {
+      if (!ph->pps->deblocking_filter_disabled_flag) {
+        READ_UINT8 (nr, ph->deblocking_filter_disabled_flag, 1);
+      } else {
+        ph->deblocking_filter_disabled_flag = 0;
+      }
+
+      if (!ph->deblocking_filter_disabled_flag) {
+        READ_SE_ALLOWED (nr, ph->luma_beta_offset_div2, -12, 12);
+        READ_SE_ALLOWED (nr, ph->luma_tc_offset_div2, -12, 12);
+        if (ph->pps->chroma_tool_offsets_present_flag) {
+          READ_SE_ALLOWED (nr, ph->cb_beta_offset_div2, -12, 12);
+          READ_SE_ALLOWED (nr, ph->cb_tc_offset_div2, -12, 12);
+          READ_SE_ALLOWED (nr, ph->cr_beta_offset_div2, -12, 12);
+          READ_SE_ALLOWED (nr, ph->cr_tc_offset_div2, -12, 12);
+        } else {
+          ph->cb_beta_offset_div2 = ph->luma_beta_offset_div2;
+          ph->cb_tc_offset_div2 = ph->luma_tc_offset_div2;
+          ph->cr_beta_offset_div2 = ph->luma_beta_offset_div2;
+          ph->cr_tc_offset_div2 = ph->luma_tc_offset_div2;
+        }
+      } else {
+        if (ph->pps->chroma_tool_offsets_present_flag) {
+          gst_h266_parse_inherit_deblock_param_from_pps (ph);
+        } else {
+          ph->luma_beta_offset_div2 = ph->pps->luma_beta_offset_div2;
+          ph->luma_tc_offset_div2 = ph->pps->luma_tc_offset_div2;
+          ph->cb_beta_offset_div2 = ph->luma_beta_offset_div2;
+          ph->cb_tc_offset_div2 = ph->luma_tc_offset_div2;
+          ph->cr_beta_offset_div2 = ph->luma_beta_offset_div2;
+          ph->cr_tc_offset_div2 = ph->luma_tc_offset_div2;
+        }
+      }
+    } else {
+      ph->deblocking_filter_disabled_flag =
+          ph->pps->deblocking_filter_disabled_flag;
+      gst_h266_parse_inherit_deblock_param_from_pps (ph);
+    }
+  } else {
+    ph->deblocking_filter_disabled_flag =
+        ph->pps->deblocking_filter_disabled_flag;
+    gst_h266_parse_inherit_deblock_param_from_pps (ph);
+  }
+
+  if (ph->pps->picture_header_extension_present_flag) {
+    READ_UE_MAX (nr, ph->extension_length, 256);
+    for (i = 0; i < ph->extension_length; i++)
+      READ_UINT8 (nr, ph->extension_data_byte[i], 8);
+  }
+
+  return ret;
+
+error:
+  ret = GST_H266_PARSER_ERROR;
+error_with_ret:
+  GST_WARNING ("error parsing \"Picture Header\"");
+  return FALSE;
+}
+
+GstH266ParserResult
+gst_h266_parser_parse_picture_hdr (GstH266Parser * parser,
+    GstH266NalUnit * nalu, GstH266PicHdr * ph)
+{
+  NalReader nr;
+  GstH266ParserResult ret;
+
+  GST_DEBUG ("parsing Picture Header");
+
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+
+  memset (ph, 0, sizeof (*ph));
+
+  ret = gst_h266_parse_picture_hdr_structure (ph, &nr, parser);
+  if (ret != GST_H266_PARSER_OK)
+    goto error;
+
+  ph->valid = TRUE;
+  parser->ph = *ph;
+
+  return ret;
+
+error:
+  GST_WARNING ("error parsing \"Picture Header\"");
+  return ret;
+}
+
+static gboolean
+gst_h266_parser_parse_slice_address (GstH266Parser * parser, NalReader * nr,
+    const GstH266PPS * pps, GstH266SliceHdr * sh, guint16 curr_subpic_idx,
+    const guint16 ** ctb_addr_in_curr_slice, guint16 * num_ctus_in_curr_slice)
+{
+  GST_DEBUG ("parsing Slice Address");
+
+  if (!pps->no_pic_partition_flag && pps->rect_slice_flag) {
+    guint16 pic_level_slice_idx = sh->slice_address;
+    gint j;
+
+    for (j = 0; j < curr_subpic_idx; j++)
+      pic_level_slice_idx += pps->num_slices_in_subpic[j];
+
+    *ctb_addr_in_curr_slice = parser->ctb_addr_in_slice +
+        parser->slice_start_offset[pic_level_slice_idx];
+    *num_ctus_in_curr_slice = parser->num_ctus_in_slice[pic_level_slice_idx];
+  } else {
+    guint16 tile_idx;
+    guint16 tile_x = sh->slice_address % pps->num_tile_columns;
+    gint16 tile_y = sh->slice_address / pps->num_tile_columns;
+    guint16 slice_start_ctb =
+        pps->tile_row_bd_val[tile_y] * pps->pic_width_in_ctbs_y +
+        pps->tile_col_bd_val[tile_x] * (pps->tile_row_height_minus1[tile_y] +
+        1);
+
+    if (pps->num_tiles_in_pic - sh->slice_address > 1) {
+      READ_UE_MAX (nr, sh->num_tiles_in_slice_minus1,
+          pps->num_tiles_in_pic - 1);
+    } else {
+      sh->num_tiles_in_slice_minus1 = 0;
+    }
+
+    *ctb_addr_in_curr_slice = parser->ctb_addr_in_slice + slice_start_ctb;
+    *num_ctus_in_curr_slice = 0;
+    for (tile_idx = sh->slice_address;
+        tile_idx <= sh->slice_address + sh->num_tiles_in_slice_minus1;
+        tile_idx++) {
+      tile_x = tile_idx % pps->num_tile_columns;
+      tile_y = tile_idx / pps->num_tile_columns;
+      *num_ctus_in_curr_slice += (pps->tile_row_height_minus1[tile_y] + 1) *
+          (pps->tile_column_width_minus1[tile_x] + 1);
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING ("error parsing Slice Address");
+  return FALSE;
+}
+
+GstH266ParserResult
+gst_h266_parser_parse_slice_hdr (GstH266Parser * parser,
+    GstH266NalUnit * nalu, GstH266SliceHdr * sh)
+{
+  NalReader nr;
+  const GstH266SPS *sps;
+  const GstH266PPS *pps;
+  const GstH266PicHdr *ph;
+  const GstH266RefPicLists *ref_pic_lists;
+  const GstH266GeneralConstraintsInfo *constraints_info;
+  guint8 nal_unit_type;
+  guint16 curr_subpic_idx, num_slices_in_subpic;
+  const guint16 *ctb_addr_in_curr_slice;        /* CtbAddrInCurrSlice */
+  guint16 num_ctus_in_curr_slice;       /* NumCtusInCurrSlice */
+  GstH266ParserResult ret = GST_H266_PARSER_OK;
+  gint i;
+
+  GST_DEBUG ("parsing Slice Header");
+
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+
+  memset (sh, 0, sizeof (*sh));
+
+  READ_UINT8 (&nr, sh->picture_header_in_slice_header_flag, 1);
+  if (sh->picture_header_in_slice_header_flag) {
+    ret = gst_h266_parse_picture_hdr_structure (&sh->picture_header,
+        &nr, parser);
+    if (ret != GST_H266_PARSER_OK)
+      goto error_with_ret;
+  } else {
+    if (!parser->ph.valid) {
+      GST_WARNING ("Picture header not available.\n");
+      goto error;
+    }
+
+    sh->picture_header = parser->ph;
+  }
+  ph = &sh->picture_header;
+
+  pps = gst_h266_parser_get_pps (parser, ph->pps_id);
+  if (!pps) {
+    GST_WARNING ("PPS id %d not available.", ph->pps_id);
+    ret = GST_H266_PARSER_BROKEN_LINK;
+    goto error_with_ret;
+  }
+
+  sps = gst_h266_parser_get_sps (parser, pps->sps_id);
+  if (!sps) {
+    GST_WARNING ("SPS id %d not available.", pps->sps_id);
+    ret = GST_H266_PARSER_BROKEN_LINK;
+    goto error_with_ret;
+  }
+
+  if (!gst_h266_parser_set_active_sps_pps (parser, sps, pps)) {
+    GST_WARNING ("PPS id %d not active.", ph->pps_id);
+    ret = GST_H266_PARSER_ERROR;
+    goto error_with_ret;
+  }
+
+  constraints_info = &sps->profile_tier_level.general_constraints_info;
+  if (constraints_info->pic_header_in_slice_header_constraint_flag &&
+      !sh->picture_header_in_slice_header_flag) {
+    GST_WARNING ("PH shall be present in SH, when "
+        "pic_header_in_slice_header_constraint_flag is equal to 1");
+    goto error;
+  }
+
+  if (sh->picture_header_in_slice_header_flag) {
+    if (pps->rpl_info_in_ph_flag) {
+      GST_WARNING ("When sh_picture_header_in_slice_header_flag is equal "
+          "to 1, rpl_info_in_ph_flag shall be equal to 0");
+      goto error;
+    }
+
+    if (pps->dbf_info_in_ph_flag) {
+      GST_WARNING ("When sh_picture_header_in_slice_header_flag is equal "
+          "to 1, dbf_info_in_ph_flag shall be equal to 0");
+      goto error;
+    }
+
+    if (pps->sao_info_in_ph_flag) {
+      GST_WARNING ("When sh_picture_header_in_slice_header_flag is equal "
+          "to 1, sao_info_in_ph_flag shall be equal to 0");
+      goto error;
+    }
+
+    if (pps->alf_info_in_ph_flag) {
+      GST_WARNING ("When sh_picture_header_in_slice_header_flag is equal "
+          "to 1, alf_info_in_ph_flag shall be equal to 0");
+      goto error;
+    }
+
+    if (pps->wp_info_in_ph_flag) {
+      GST_WARNING ("When sh_picture_header_in_slice_header_flag is equal "
+          "to 1, wp_info_in_ph_flag shall be equal to 0");
+      goto error;
+    }
+
+    if (pps->qp_delta_info_in_ph_flag) {
+      GST_WARNING ("When sh_picture_header_in_slice_header_flag is equal "
+          "to 1, qp_delta_info_in_ph_flag shall be equal to 0");
+      goto error;
+    }
+
+    if (sps->subpic_info_present_flag) {
+      GST_WARNING ("When sps_subpic_info_present_flag is equal to 1, "
+          "the value of sh_picture_header_in_slice_header_flag shall be "
+          "equal to 0");
+      goto error;
+    }
+  }
+
+  curr_subpic_idx = 0;
+  if (sps->subpic_info_present_flag) {
+    READ_UINT16 (&nr, sh->subpic_id, sps->subpic_id_len_minus1 + 1);
+
+    if (sps->subpic_id_mapping_explicitly_signalled_flag) {
+      for (i = 0; i <= sps->num_subpics_minus1; i++) {
+        guint16 subpic_id_val = pps->subpic_id_mapping_present_flag ?
+            pps->subpic_id[i] : sps->subpic_id[i];
+
+        if (subpic_id_val == sh->subpic_id) {
+          curr_subpic_idx = i;
+          break;
+        }
+      }
+    } else {
+      curr_subpic_idx = sh->subpic_id;
+      if (curr_subpic_idx > sps->num_subpics_minus1) {
+        GST_WARNING ("sh_subpic_id(%d) should in range [0, %d]",
+            curr_subpic_idx, sps->num_subpics_minus1);
+        goto error;
+      }
+    }
+  }
+
+  num_slices_in_subpic = pps->num_slices_in_subpic[curr_subpic_idx];
+
+  if ((pps->rect_slice_flag && num_slices_in_subpic > 1) ||
+      (!pps->rect_slice_flag && pps->num_tiles_in_pic > 1)) {
+    guint bits, max;
+
+    if (!pps->rect_slice_flag) {
+      bits = gst_util_ceil_log2 (pps->num_tiles_in_pic);
+      max = pps->num_tiles_in_pic - 1;
+    } else {
+      bits = gst_util_ceil_log2 (num_slices_in_subpic);
+      max = num_slices_in_subpic - 1;
+    }
+
+    READ_UINT16 (&nr, sh->slice_address, bits);
+    CHECK_ALLOWED_MAX (sh->slice_address, max);
+  } else {
+    sh->slice_address = 0;
+  }
+
+  for (i = 0; i < sps->num_extra_sh_bytes * 8; i++) {
+    if (sps->extra_sh_bit_present_flag[i])
+      READ_UINT8 (&nr, sh->extra_bit[i], 1);
+  }
+
+  if (!gst_h266_parser_parse_slice_address (parser, &nr, pps, sh,
+          curr_subpic_idx, &ctb_addr_in_curr_slice, &num_ctus_in_curr_slice))
+    goto error;
+
+  if (ph->inter_slice_allowed_flag) {
+    READ_UE_MAX (&nr, sh->slice_type, 2);
+  } else {
+    sh->slice_type = GST_H266_I_SLICE;
+  }
+  if (!ph->intra_slice_allowed_flag && sh->slice_type == GST_H266_I_SLICE) {
+    GST_WARNING ("when ph_intra_slice_allowed_flag = 0, "
+        "no I_Slice is allowed");
+    goto error;
+  }
+
+  nal_unit_type = nalu->type;
+  if (nal_unit_type == GST_H266_NAL_SLICE_IDR_W_RADL ||
+      nal_unit_type == GST_H266_NAL_SLICE_IDR_N_LP ||
+      nal_unit_type == GST_H266_NAL_SLICE_CRA ||
+      nal_unit_type == GST_H266_NAL_SLICE_GDR)
+    READ_UINT8 (&nr, sh->no_output_of_prior_pics_flag, 1);
+
+  if (sps->alf_enabled_flag && !pps->alf_info_in_ph_flag) {
+    READ_UINT8 (&nr, sh->alf_enabled_flag, 1);
+
+    if (sh->alf_enabled_flag) {
+      READ_UINT8 (&nr, sh->num_alf_aps_ids_luma, 3);
+      for (i = 0; i < sh->num_alf_aps_ids_luma; i++)
+        READ_UINT8 (&nr, sh->alf_aps_id_luma[i], 3);
+
+      if (sps->chroma_format_idc != 0) {
+        READ_UINT8 (&nr, sh->alf_cb_enabled_flag, 1);
+        READ_UINT8 (&nr, sh->alf_cr_enabled_flag, 1);
+      } else {
+        sh->alf_cb_enabled_flag = ph->alf_cb_enabled_flag;
+        sh->alf_cr_enabled_flag = ph->alf_cr_enabled_flag;
+      }
+
+      if (sh->alf_cb_enabled_flag || sh->alf_cr_enabled_flag) {
+        READ_UINT8 (&nr, sh->alf_aps_id_chroma, 3);
+      } else {
+        sh->alf_aps_id_chroma = ph->alf_aps_id_chroma;
+      }
+
+      if (sps->ccalf_enabled_flag) {
+        READ_UINT8 (&nr, sh->alf_cc_cb_enabled_flag, 1);
+        if (sh->alf_cc_cb_enabled_flag) {
+          READ_UINT8 (&nr, sh->alf_cc_cb_aps_id, 3);
+        } else {
+          sh->alf_cc_cb_aps_id = ph->alf_cc_cb_aps_id;
+        }
+
+        READ_UINT8 (&nr, sh->alf_cc_cr_enabled_flag, 1);
+        if (sh->alf_cc_cr_enabled_flag) {
+          READ_UINT8 (&nr, sh->alf_cc_cr_aps_id, 3);
+        } else {
+          sh->alf_cc_cr_aps_id = ph->alf_cc_cr_aps_id;
+        }
+      } else {
+        sh->alf_cc_cb_enabled_flag = ph->alf_cc_cb_enabled_flag;
+        sh->alf_cc_cr_enabled_flag = ph->alf_cc_cr_enabled_flag;
+        sh->alf_cc_cb_aps_id = ph->alf_cc_cb_aps_id;
+        sh->alf_cc_cr_aps_id = ph->alf_cc_cr_aps_id;
+      }
+    }
+  } else {
+    sh->alf_enabled_flag = ph->alf_enabled_flag;
+    sh->num_alf_aps_ids_luma = ph->num_alf_aps_ids_luma;
+    for (i = 0; i < sh->num_alf_aps_ids_luma; i++)
+      sh->alf_aps_id_luma[i] = ph->alf_aps_id_luma[i];
+    sh->alf_cb_enabled_flag = ph->alf_cb_enabled_flag;
+    sh->alf_cr_enabled_flag = ph->alf_cr_enabled_flag;
+    sh->alf_aps_id_chroma = ph->alf_aps_id_chroma;
+    sh->alf_cc_cb_enabled_flag = ph->alf_cc_cb_enabled_flag;
+    sh->alf_cc_cb_aps_id = ph->alf_cc_cb_aps_id;
+    sh->alf_cc_cr_enabled_flag = ph->alf_cc_cr_enabled_flag;
+    sh->alf_cc_cr_aps_id = ph->alf_cc_cr_aps_id;
+  }
+
+  if (ph->lmcs_enabled_flag && !sh->picture_header_in_slice_header_flag) {
+    READ_UINT8 (&nr, sh->lmcs_used_flag, 1);
+  } else {
+    sh->lmcs_used_flag =
+        sh->picture_header_in_slice_header_flag ? ph->lmcs_enabled_flag : 0;
+  }
+
+  if (ph->explicit_scaling_list_enabled_flag &&
+      !sh->picture_header_in_slice_header_flag) {
+    READ_UINT8 (&nr, sh->explicit_scaling_list_used_flag, 1);
+  } else {
+    sh->explicit_scaling_list_used_flag =
+        sh->picture_header_in_slice_header_flag ?
+        ph->explicit_scaling_list_enabled_flag : 0;
+  }
+
+  if (!pps->rpl_info_in_ph_flag &&
+      ((nal_unit_type != GST_H266_NAL_SLICE_IDR_W_RADL &&
+              nal_unit_type != GST_H266_NAL_SLICE_IDR_N_LP) ||
+          sps->idr_rpl_present_flag)) {
+    if (!gst_h266_ref_pic_lists (&sh->ref_pic_lists, &nr, sps, pps))
+      goto error;
+  } else {
+    sh->ref_pic_lists = ph->ref_pic_lists;
+  }
+  ref_pic_lists = &sh->ref_pic_lists;
+
+  if ((sh->slice_type != GST_H266_I_SLICE &&
+          ref_pic_lists->rpl_ref_list[0].num_ref_entries > 1) ||
+      (sh->slice_type == GST_H266_B_SLICE &&
+          ref_pic_lists->rpl_ref_list[1].num_ref_entries > 1)) {
+    READ_UINT8 (&nr, sh->num_ref_idx_active_override_flag, 1);
+    if (sh->num_ref_idx_active_override_flag) {
+      for (i = 0; i < (sh->slice_type == GST_H266_B_SLICE ? 2 : 1); i++)
+        if (ref_pic_lists->rpl_ref_list[i].num_ref_entries > 1) {
+          READ_UE_MAX (&nr, sh->num_ref_idx_active_minus1[i], 14);
+        } else {
+          sh->num_ref_idx_active_minus1[i] = 0;
+        }
+    }
+  } else {
+    sh->num_ref_idx_active_override_flag = 1;
+  }
+
+  for (i = 0; i < 2; i++) {
+    if (sh->slice_type == GST_H266_B_SLICE
+        || (sh->slice_type == GST_H266_P_SLICE && i == 0)) {
+      if (sh->num_ref_idx_active_override_flag) {
+        sh->num_ref_idx_active[i] = sh->num_ref_idx_active_minus1[i] + 1;
+      } else {
+        sh->num_ref_idx_active[i] =
+            MIN (ref_pic_lists->rpl_ref_list[i].num_ref_entries,
+            pps->num_ref_idx_default_active_minus1[i] + 1);
+      }
+    } else {
+      /* sh_slice_type == I || (sh_slice_type == P && i == 1) */
+      sh->num_ref_idx_active[i] = 0;
+    }
+  }
+
+  sh->collocated_from_l0_flag = ph->collocated_from_l0_flag;
+
+  if (sh->slice_type != GST_H266_I_SLICE) {
+    if (pps->cabac_init_present_flag) {
+      READ_UINT8 (&nr, sh->cabac_init_flag, 1);
+    } else {
+      sh->cabac_init_flag = 0;
+    }
+
+    if (ph->temporal_mvp_enabled_flag) {
+      if (ph->temporal_mvp_enabled_flag) {
+        if (sh->slice_type == GST_H266_P_SLICE) {
+          sh->collocated_from_l0_flag = 1;
+        } else if (!pps->rpl_info_in_ph_flag
+            && sh->slice_type == GST_H266_B_SLICE) {
+          READ_UINT8 (&nr, sh->collocated_from_l0_flag, 1);
+        } else {
+          sh->collocated_from_l0_flag = ph->collocated_from_l0_flag;
+        }
+      }
+
+      if (!pps->rpl_info_in_ph_flag) {
+        if ((sh->collocated_from_l0_flag && sh->num_ref_idx_active[0] > 1) ||
+            (!sh->collocated_from_l0_flag && sh->num_ref_idx_active[1] > 1)) {
+          gint idx = sh->collocated_from_l0_flag ? 0 : 1;
+          READ_UE_MAX (&nr, sh->collocated_ref_idx,
+              sh->num_ref_idx_active[idx] - 1);
+        } else {
+          sh->collocated_ref_idx = 0;
+        }
+      } else {
+        sh->collocated_ref_idx = ph->collocated_ref_idx;
+      }
+    }
+
+    if (!pps->wp_info_in_ph_flag &&
+        ((pps->weighted_pred_flag && sh->slice_type == GST_H266_P_SLICE) ||
+            (pps->weighted_bipred_flag &&
+                sh->slice_type == GST_H266_B_SLICE))) {
+      if (!gst_h266_parse_pred_weight_table (&sh->pred_weight_table,
+              &nr, sps, pps, ref_pic_lists, sh->num_ref_idx_active))
+        goto error;
+    }
+  }
+
+  if (!pps->qp_delta_info_in_ph_flag) {
+    READ_SE_ALLOWED (&nr, sh->qp_delta, -63, 63);
+  } else {
+    sh->qp_delta = ph->qp_delta;
+  }
+  sh->slice_qp_y = 26 + pps->init_qp_minus26 + sh->qp_delta;
+  if (sh->slice_qp_y < -6 * sps->bitdepth_minus8 || sh->slice_qp_y > 63) {
+    GST_WARNING ("SliceQpy = %d is our of range.", sh->slice_qp_y);
+    goto error;
+  }
+
+  if (pps->slice_chroma_qp_offsets_present_flag) {
+    gint8 off;
+
+    READ_SE_ALLOWED (&nr, sh->cb_qp_offset, -12, 12);
+    off = pps->cb_qp_offset + sh->cb_qp_offset;
+    if (off < -12 || off > 12) {
+      GST_WARNING ("pps_cb_qp_offset + sh_cb_qp_offset(%d) = %d, "
+          "out of range [-12, 12].", sh->cb_qp_offset, off);
+      goto error;
+    }
+
+    READ_SE_ALLOWED (&nr, sh->cr_qp_offset, -12, 12);
+    off = pps->cr_qp_offset + sh->cr_qp_offset;
+    if (off < -12 || off > 12) {
+      GST_WARNING ("pps_cr_qp_offset + sh_cr_qp_offset(%d) = %d, "
+          "out of range [-12, 12].", sh->cr_qp_offset, off);
+      goto error;
+    }
+
+    if (sps->joint_cbcr_enabled_flag) {
+      READ_SE_ALLOWED (&nr, sh->joint_cbcr_qp_offset, -12, 12);
+      off = pps->joint_cbcr_qp_offset_value + sh->joint_cbcr_qp_offset;
+      if (off < -12 || off > 12) {
+        GST_WARNING ("pps_joint_cbcr_qp_offset_value + sh_joint_cbcr_qp_offset"
+            "(%d) = %d, out of range [-12, 12].",
+            sh->joint_cbcr_qp_offset, off);
+        goto error;
+      }
+    } else {
+      sh->joint_cbcr_qp_offset = 0;
+    }
+  } else {
+    sh->cb_qp_offset = 0;
+    sh->cr_qp_offset = 0;
+    sh->joint_cbcr_qp_offset = 0;
+  }
+
+  if (pps->cu_chroma_qp_offset_list_enabled_flag) {
+    READ_UINT8 (&nr, sh->cu_chroma_qp_offset_enabled_flag, 1);
+  } else {
+    sh->cu_chroma_qp_offset_enabled_flag = 0;
+  }
+
+  if (sps->sao_enabled_flag && !pps->sao_info_in_ph_flag) {
+    READ_UINT8 (&nr, sh->sao_luma_used_flag, 1);
+
+    if (sps->chroma_format_idc != 0) {
+      READ_UINT8 (&nr, sh->sao_chroma_used_flag, 1);
+    } else {
+      sh->sao_chroma_used_flag = ph->sao_chroma_enabled_flag;
+    }
+  } else {
+    sh->sao_luma_used_flag = ph->sao_luma_enabled_flag;
+    sh->sao_chroma_used_flag = ph->sao_chroma_enabled_flag;
+  }
+
+  /* Inherit deblock filter features from picture header */
+  sh->deblocking_filter_disabled_flag = ph->deblocking_filter_disabled_flag;
+  sh->luma_beta_offset_div2 = ph->luma_beta_offset_div2;
+  sh->luma_tc_offset_div2 = ph->luma_tc_offset_div2;
+  sh->cb_beta_offset_div2 = ph->cb_beta_offset_div2;
+  sh->cb_tc_offset_div2 = ph->cb_tc_offset_div2;
+  sh->cr_beta_offset_div2 = ph->cr_beta_offset_div2;
+  sh->cr_tc_offset_div2 = ph->cr_tc_offset_div2;
+
+  if (pps->deblocking_filter_override_enabled_flag && !pps->dbf_info_in_ph_flag) {
+    READ_UINT8 (&nr, sh->deblocking_params_present_flag, 1);
+  } else {
+    sh->deblocking_params_present_flag = 0;
+  }
+  if (sh->deblocking_params_present_flag) {
+    if (!pps->deblocking_filter_disabled_flag) {
+      READ_UINT8 (&nr, sh->deblocking_filter_disabled_flag, 1);
+    } else {
+      sh->deblocking_filter_disabled_flag = 0;
+    }
+
+    if (!sh->deblocking_filter_disabled_flag) {
+      READ_SE_ALLOWED (&nr, sh->luma_beta_offset_div2, -12, 12);
+      READ_SE_ALLOWED (&nr, sh->luma_tc_offset_div2, -12, 12);
+
+      if (pps->chroma_tool_offsets_present_flag) {
+        READ_SE_ALLOWED (&nr, sh->cb_beta_offset_div2, -12, 12);
+        READ_SE_ALLOWED (&nr, sh->cb_tc_offset_div2, -12, 12);
+        READ_SE_ALLOWED (&nr, sh->cr_beta_offset_div2, -12, 12);
+        READ_SE_ALLOWED (&nr, sh->cr_tc_offset_div2, -12, 12);
+      } else {
+        sh->cb_beta_offset_div2 = sh->luma_beta_offset_div2;
+        sh->cb_tc_offset_div2 = sh->luma_tc_offset_div2;
+        sh->cr_beta_offset_div2 = sh->luma_beta_offset_div2;
+        sh->cr_tc_offset_div2 = sh->luma_tc_offset_div2;
+      }
+    }
+  }
+
+  if (sps->dep_quant_enabled_flag) {
+    READ_UINT8 (&nr, sh->dep_quant_used_flag, 1);
+  } else {
+    sh->dep_quant_used_flag = 0;
+  }
+  if (sps->sign_data_hiding_enabled_flag && !sh->dep_quant_used_flag) {
+    READ_UINT8 (&nr, sh->sign_data_hiding_used_flag, 1);
+  } else {
+    sh->sign_data_hiding_used_flag = 0;
+  }
+  if (sps->transform_skip_enabled_flag &&
+      !sh->dep_quant_used_flag && !sh->sign_data_hiding_used_flag) {
+    READ_UINT8 (&nr, sh->ts_residual_coding_disabled_flag, 1);
+  } else {
+    sh->ts_residual_coding_disabled_flag = 0;
+  }
+
+  if (sh->ts_residual_coding_disabled_flag &&
+      sps->range_params.ts_residual_coding_rice_present_in_sh_flag) {
+    READ_UINT8 (&nr, sh->ts_residual_coding_rice_idx_minus1, 3);
+  } else {
+    sh->ts_residual_coding_rice_idx_minus1 = 0;
+  }
+
+  if (sps->range_params.reverse_last_sig_coeff_enabled_flag) {
+    READ_UINT8 (&nr, sh->reverse_last_sig_coeff_flag, 1);
+  } else {
+    sh->reverse_last_sig_coeff_flag = 0;
+  }
+
+  if (pps->slice_header_extension_present_flag) {
+    READ_UE_MAX (&nr, sh->slice_header_extension_length, 256);
+    for (i = 0; i < sh->slice_header_extension_length; i++)
+      READ_UINT8 (&nr, sh->slice_header_extension_data_byte[i], 8);
+  }
+
+  /* (141) */
+  sh->num_entry_points = 0;
+  if (sps->entry_point_offsets_present_flag) {
+    for (i = 1; i < num_ctus_in_curr_slice; i++) {
+      guint16 ctb_addr_x, ctb_addr_y, pre_ctb_addr_x, pre_ctb_addr_y;
+
+      ctb_addr_x = ctb_addr_in_curr_slice[i] % pps->pic_width_in_ctbs_y;
+      ctb_addr_y = ctb_addr_in_curr_slice[i] / pps->pic_width_in_ctbs_y;
+      pre_ctb_addr_x = ctb_addr_in_curr_slice[i - 1] % pps->pic_width_in_ctbs_y;
+      pre_ctb_addr_y = ctb_addr_in_curr_slice[i - 1] / pps->pic_width_in_ctbs_y;
+
+      if (parser->ctb_to_tile_row_bd[ctb_addr_y] !=
+          parser->ctb_to_tile_row_bd[pre_ctb_addr_y]
+          || parser->ctb_to_tile_col_bd[ctb_addr_x] !=
+          parser->ctb_to_tile_col_bd[pre_ctb_addr_x]
+          || (ctb_addr_y != pre_ctb_addr_y
+              && sps->entropy_coding_sync_enabled_flag)) {
+        sh->entry_point_start_ctu[sh->num_entry_points] = i;
+        sh->num_entry_points++;
+      }
+    }
+
+    if (sh->num_entry_points > GST_H266_MAX_ENTRY_POINTS) {
+      GST_WARNING ("Too many entry points: %d.", sh->num_entry_points);
+      goto error;
+    }
+    if (sh->num_entry_points > 0) {
+      READ_UE_MAX (&nr, sh->entry_offset_len_minus1, 31);
+      for (i = 0; i < sh->num_entry_points; i++) {
+        READ_UINT32 (&nr, sh->entry_point_offset_minus1[i],
+            sh->entry_offset_len_minus1 + 1);
+      }
+    }
+  }
+
+  /* Skip the byte alignment bits */
+  if (!nal_reader_skip (&nr, 1))
+    goto error;
+  while (!nal_reader_is_byte_aligned (&nr))
+    if (!nal_reader_skip (&nr, 1))
+      goto error;
+
+  sh->header_size = nal_reader_get_pos (&nr);
+  sh->n_emulation_prevention_bytes = nal_reader_get_epb_count (&nr);
+
+  return ret;
+
+error:
+  ret = GST_H266_PARSER_ERROR;
+error_with_ret:
+  GST_WARNING ("error parsing \"Slice Header\"");
+  return ret;
+}
+
+static GstH266ParserResult
+gst_h266_parser_parse_sei_message (GstH266SEIMessage * sei, NalReader * nr,
+    GstH266Parser * parser, guint8 nal_type, guint8 nal_tid)
+{
+  guint8 payload_type_byte, payload_size_byte;
+  guint remaining, payload_size, payloadSize, payload_start_pos_bit;
+  GstH266ParserResult res = GST_H266_PARSER_OK;
+
+  if (nal_type == GST_H266_NAL_PREFIX_SEI)
+    GST_DEBUG ("parsing \"Prefix SEI message\"");
+  else if (nal_type == GST_H266_NAL_SUFFIX_SEI)
+    GST_DEBUG ("parsing \"Suffix SEI message\"");
+
+  memset (sei, 0, sizeof (*sei));
+
+  do {
+    READ_UINT8 (nr, payload_type_byte, 8);
+    sei->payloadType += payload_type_byte;
+  } while (payload_type_byte == 0xff);
+  payloadSize = 0;
+  do {
+    READ_UINT8 (nr, payload_size_byte, 8);
+    payloadSize += payload_size_byte;
+  } while (payload_size_byte == 0xff);
+
+  remaining = nal_reader_get_remaining (nr);
+  payload_size = payloadSize * 8 < remaining ? payloadSize * 8 : remaining;
+  payload_start_pos_bit = nal_reader_get_pos (nr);
+
+  GST_DEBUG ("SEI message received: payloadType  %u, payloadSize = %u bits",
+      sei->payloadType, payload_size);
+
+  if (nal_type == GST_H266_NAL_PREFIX_SEI) {
+    switch (sei->payloadType) {
+      case GST_H266_SEI_BUF_PERIOD:
+        res = gst_h266_parser_parse_buffering_period
+            (&sei->payload.buffering_period, nr);
+        if (res == GST_H266_PARSER_OK) {
+          parser->buffering_period = *sei;
+          parser->last_buffering_period = &parser->buffering_period;
+        }
+        break;
+      case GST_H266_SEI_PIC_TIMING:
+        if (!parser->last_buffering_period) {
+          GST_WARNING ("No buffering_period SEI.");
+          goto error;
+        }
+
+        res = gst_h266_parser_parse_pic_timing (&sei->payload.pic_timing, nr,
+            parser->buffering_period.payload.buffering_period, nal_tid);
+        break;
+      case GST_H266_SEI_DU_INFO:
+        if (!parser->last_buffering_period) {
+          GST_WARNING ("No buffering_period SEI.");
+          goto error;
+        }
+
+        res = gst_h266_parser_parse_du_info (&sei->payload.du_info, nr,
+            parser->buffering_period.payload.buffering_period, nal_tid);
+        break;
+      case GST_H266_SEI_FRAME_FIELD_INFO:
+        res = gst_h266_parser_parse_frame_field_info
+            (&sei->payload.frame_field_info, nr);
+        break;
+      case GST_H266_SEI_SUBPIC_LEVEL_INFO:
+        res = gst_h266_parser_parse_subpic_level_info
+            (&sei->payload.subpic_level_info, nr);
+        break;
+      default:
+        /* Just consume payloadSize bytes, which does not account for
+           emulation prevention bytes */
+        if (!nal_reader_skip_long (nr, payload_size))
+          goto error;
+        res = GST_H266_PARSER_OK;
+        break;
+    }
+  } else if (nal_type == GST_H266_NAL_SUFFIX_SEI) {
+    switch (sei->payloadType) {
+      case GST_H266_SEI_SCALABLE_NESTING:
+        res = gst_h266_parser_parse_scalable_nesting
+            (&sei->payload.scalable_nesting, nr);
+        break;
+      default:
+        /* Just consume payloadSize bytes, which does not account for
+           emulation prevention bytes */
+        if (!nal_reader_skip_long (nr, payload_size))
+          goto error;
+        res = GST_H266_PARSER_OK;
+        break;
+    }
+  }
+
+  /* Not parsing the reserved_payload_extension, but it shouldn't be
+   * an issue because of 1: There shall not be any reserved_payload_extension
+   * present in bitstreams conforming to the specification.2. Even though
+   * it is present, the size will be less than total PayloadSize since the
+   * size of reserved_payload_extension is supposed to be
+   * 8 * payloadSize - nEarlierBits - nPayloadZeroBits -1 which means the
+   * the current implementation will still skip all unnecessary bits correctly.
+   * In theory, we can have a more optimized implementation by skipping the
+   * data left in PayLoadSize without out individually checking for each bits,
+   * since the totoal size will be always less than payloadSize*/
+  while (nal_reader_has_more_data_in_payload (nr, payload_start_pos_bit,
+          payloadSize)) {
+    /* Skip the byte alignment bits */
+    if (!nal_reader_skip (nr, 1))
+      goto error;
+    while (!nal_reader_is_byte_aligned (nr)) {
+      if (!nal_reader_skip (nr, 1))
+        goto error;
+    }
+  }
+
+  return res;
+
+error:
+  GST_WARNING ("error parsing \"Sei message\"");
+  return GST_H266_PARSER_ERROR;
+}
+
+/**
+ * gst_h266_sei_free:
+ * sei: The #GstH266SEIMessage to free
+ *
+ * Frees @sei fields.
+ *
+ * Since: 1.24
+ */
+void
+gst_h266_sei_free (GstH266SEIMessage * sei)
+{
+  g_return_if_fail (sei != NULL);
+}
+
+/**
+ * gst_h266_parser_parse_sei:
+ * @nalparser: a #GstH266Parser
+ * @nalu: The `GST_H266_NAL_*_SEI` #GstH266NalUnit to parse
+ * @messages: The GArray of #GstH266SEIMessage to fill. The caller must free it when done.
+ *
+ * Parses @data, create and fills the @messages array.
+ *
+ * Returns: a #GstH266ParserResult
+ *
+ * Since: 1.24
+ */
+GstH266ParserResult
+gst_h266_parser_parse_sei (GstH266Parser * nalparser, GstH266NalUnit * nalu,
+    GArray ** messages)
+{
+  NalReader nr;
+  GstH266SEIMessage sei;
+  GstH266ParserResult res;
+
+  GST_DEBUG ("parsing SEI nal");
+  nal_reader_init (&nr, nalu->data + nalu->offset + nalu->header_bytes,
+      nalu->size - nalu->header_bytes);
+  *messages = g_array_new (FALSE, FALSE, sizeof (GstH266SEIMessage));
+  g_array_set_clear_func (*messages, (GDestroyNotify) gst_h266_sei_free);
+
+  do {
+    res = gst_h266_parser_parse_sei_message (&sei, &nr, nalparser, nalu->type,
+        nalu->temporal_id_plus1 - 1);
+    if (res == GST_H266_PARSER_OK)
+      g_array_append_val (*messages, sei);
+    else
+      break;
+  } while (nal_reader_has_more_data (&nr));
+
+  return res;
+}
+
+/**
+ * gst_h266_profile_to_string:
+ * @profile: a #GstH266Profile
+ *
+ * Returns the descriptive name for the #GstH266Profile.
+ *
+ * Returns: (nullable): the name for @profile or %NULL on error
+ *
+ * Since: 1.24
+ */
+const gchar *
+gst_h266_profile_to_string (GstH266Profile profile)
+{
+  guint i;
+
+  if (profile <= GST_H266_PROFILE_INVALID || profile >= GST_H266_PROFILE_MAX)
+    return NULL;
+
+  for (i = 0; i < G_N_ELEMENTS (h266_profiles); i++) {
+    if (profile == h266_profiles[i].profile)
+      return h266_profiles[i].name;
+  }
+
+  return NULL;
+}
+
+/**
+ * gst_h266_profile_from_string:
+ * @string: the descriptive name for #GstH266Profile
+ *
+ * Returns a #GstH266Profile for the @string.
+ *
+ * Returns: the #GstH266Profile of @string or %GST_H266_PROFILE_INVALID on error
+ *
+ * Since: 1.24
+ */
+GstH266Profile
+gst_h266_profile_from_string (const gchar * string)
+{
+  guint i;
+
+  if (string == NULL)
+    return GST_H266_PROFILE_INVALID;
+
+  for (i = 0; i < G_N_ELEMENTS (h266_profiles); i++) {
+    if (g_strcmp0 (string, h266_profiles[i].name) == 0) {
+      return h266_profiles[i].profile;
+    }
+  }
+
+  return GST_H266_PROFILE_INVALID;
+}
diff --git a/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/gsth266parser.h b/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/gsth266parser.h
new file mode 100644
index 0000000000..4923da0dad
--- /dev/null
+++ b/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/gsth266parser.h
@@ -0,0 +1,3336 @@
+/* Gstreamer H.266 bitstream parser
+ *
+ * Copyright (C) 2023 Intel Corporation
+ *    Author: Zhong Hongcheng <spartazhc@gmail.com>
+ *    Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#pragma once
+
+#ifndef GST_USE_UNSTABLE_API
+#warning "The H.266 parsing library is unstable API and may change in future."
+#warning "You can define GST_USE_UNSTABLE_API to avoid this warning."
+#endif
+
+#include <gst/gst.h>
+#include <gst/codecparsers/codecparsers-prelude.h>
+
+G_BEGIN_DECLS
+
+#define GST_H266_IS_B_SLICE(slice)  ((slice)->slice_type == GST_H266_B_SLICE)
+#define GST_H266_IS_P_SLICE(slice)  ((slice)->slice_type == GST_H266_P_SLICE)
+#define GST_H266_IS_I_SLICE(slice)  ((slice)->slice_type == GST_H266_I_SLICE)
+
+/* 6.2 we can have 3 sample arrays */
+#define GST_H266_MAX_SAMPLE_ARRAYS 3
+/* 7.4.3.3 vps_max_layers_minus1 is u(6) */
+#define GST_H266_MAX_LAYERS 64
+/* 7.4.3.3 The value of vps_max_sublayers_minus1
+ * shall be in the range of 0 to 6, inclusive */
+#define GST_H266_MAX_SUBLAYERS 7
+/* 7.4.3.3 vps_num_output_layer_sets_minus2 is u(8) */
+#define GST_H266_MAX_TOTAL_NUM_OLSS 257
+/* 7.4.3.3 vps_num_ptls_minus1 shall be less than TotalNumOlss,
+ * which is MAX(GST_H266_MAX_LAYERS, GST_H266_MAX_TOTAL_NUM_OLSS) */
+#define GST_H266_MAX_PTLS GST_H266_MAX_TOTAL_NUM_OLSS
+/* 7.3.2.3: vps_video_parameter_set_id is u(4). */
+#define GST_H266_MAX_VPS_COUNT 16
+/* 7.3.2.4: sps_seq_parameter_set_id is u(4) */
+#define GST_H266_MAX_SPS_COUNT 16
+/* 7.3.2.5: pps_pic_parameter_set_id is u(6) */
+#define GST_H266_MAX_PPS_COUNT 64
+/* 7.3.2.7: the value of aps_adaptation_parameter_set_id shall be in
+ * the range of 0 to 7 or in the range of 0 to 3 inclusive, depending
+ * on the aps_params_type. */
+#define GST_H266_MAX_APS_COUNT 8
+/* 7.4.4.1: ptl_num_sub_profiles is u(8) */
+#define GST_H266_MAX_SUB_PROFILES 256
+/* A.4.2: MaxDpbSize is bounded above by 2*maxDpbPicBuf(8) */
+#define GST_H266_MAX_DPB_SIZE 16
+/* 7.4.3.4: sps_num_ref_pic_lists in range [0, 64] */
+#define GST_H266_MAX_REF_PIC_LISTS 64
+/* 7.4.3.18: NumAlfFilters is 25 */
+#define GST_H266_NUM_ALF_FILTERS 25
+/* 7.4.11: num_ref_entries in range [0, MaxDpbSize + 13] */
+#define GST_H266_MAX_REF_ENTRIES (GST_H266_MAX_DPB_SIZE + 13)
+/* 7.4.3.3 sps_num_points_in_qp_table_minus1[i] in range
+ * [0, 36 - sps_qp_table_start_minus26[i]], and sps_qp_table_start_minus26[i]
+ * in range [-26 - QpBdOffset, 36]. For 16 bits QpBdOffset is 6*8,
+ * so sps_num_points_in_qp_table_minus1[i] in range [0, 110] */
+#define GST_H266_MAX_POINTS_IN_QP_TABLE 111
+/* 7.4.6.1: hrd_cpb_cnt_minus1 is in [0, 31]. */
+#define GST_H266_MAX_CPB_CNT 32
+/* A.4.1: the highest level allows a MaxLumaPs of 35 651 584. */
+#define GST_H266_MAX_LUMA_PS 35651584
+/* A.4.1: pic_width_in_luma_samples and pic_height_in_luma_samples are
+ * constrained to be not greater than sqrt(MaxLumaPs * 8).  Hence height/
+ * width are bounded above by sqrt(8 * 35651584) = 16888.2 samples. */
+#define GST_H266_MAX_WIDTH 16888
+#define GST_H266_MAX_HEIGHT 16888
+/* A.4.1: table A.1 allows at most 440 tiles per au for any level. */
+#define GST_H266_MAX_TILES_PER_AU 440
+/* A.4.1: table A.1 did not define max tile rows. */
+/* in worest a case, we can have 1x440 tiles picture. */
+#define GST_H266_MAX_TILE_ROWS GST_H266_MAX_TILES_PER_AU
+/* A.4.1: table A.1 allows at most 20 tile columns for any level. */
+#define GST_H266_MAX_TILE_COLUMNS 20
+/* A.4.1 table A.1 allows at most 1000 slice for any level. */
+#define GST_H266_MAX_SLICES_PER_AU 1000
+/* 7.4.8: in the worst case (!pps_no_pic_partition_flag and
+ * sps_entropy_coding_sync_enabled_flag are both true), entry points can be
+ * placed at the beginning of every Ctb row in every tile, giving an
+ * upper bound of (num_tile_columns_minus1 + 1) * PicHeightInCtbsY - 1.
+ * Only a stream with very high resolution and perverse parameters could
+ * get near that, though, so set a lower limit here with the maximum
+ * possible value for 8K video (at most 135 32x32 Ctb rows). */
+#define GST_H266_MAX_ENTRY_POINTS (GST_H266_MAX_TILE_COLUMNS * 135)
+/* Use MaxLumaPs of level 6.3 in Table A.2.
+   The min coding block size is 8, so min width or height is 8.
+   The min CTU size is 32. */
+#define GST_H266_MAX_CTUS_IN_PICTURE (80216064 / 8 / 32)
+
+/**
+ * GST_H266_IS_NAL_TYPE_IDR:
+ * @nal_type: a #GstH266NalUnitType
+ *
+ * Check whether @nal_type is IDR or not.
+ */
+#define GST_H266_IS_NAL_TYPE_IDR(nal_type) \
+  ((nal_type) == GST_H266_NAL_SLICE_IDR_N_LP || \
+   (nal_type) == GST_H266_NAL_SLICE_IDR_W_RADL)
+
+/**
+ * GST_H266_IS_NAL_TYPE_GDR:
+ * @nal_type: a #GstH266NalUnitType
+ *
+ * Check whether @nal_type is GDR or not.
+ */
+#define GST_H266_IS_NAL_TYPE_GDR(nal_type) ((nal_type) == GST_H266_NAL_SLICE_GDR)
+
+/**
+ * GST_H266_IS_NAL_TYPE_CRA:
+ * @nal_type: a #GstH266NalUnitType
+ *
+ * Check whether @nal_type is CRA or not.
+ */
+#define GST_H266_IS_NAL_TYPE_CRA(nal_type) ((nal_type) == GST_H266_NAL_SLICE_CRA)
+
+/**
+ * GST_H266_IS_NAL_TYPE_IRAP:
+ * @nal_type: a #GstH266NalUnitType
+ *
+ * Check whether @nal_type is IRAP or not.
+ */
+#define GST_H266_IS_NAL_TYPE_IRAP(nal_type) \
+  (GST_H266_IS_NAL_TYPE_IDR (nal_type) || GST_H266_IS_NAL_TYPE_CRA (nal_type))
+
+/**
+ * GST_H266_IS_NAL_TYPE_CVSS:
+ * @nal_type: a #GstH266NalUnitType
+ *
+ * Check whether @nal_type is coded video sequence start or not.
+ */
+#define GST_H266_IS_NAL_TYPE_CVSS(nal_type) \
+  (GST_H266_IS_NAL_TYPE_IRAP(nal_type) || GST_H266_IS_NAL_TYPE_GDR(nal_type))
+
+/**
+ * GST_H266_IS_NAL_TYPE_RADL:
+ * @nal_type: a #GstH266NalUnitType
+ *
+ * Check whether @nal_type is RADL or not.
+ */
+#define GST_H266_IS_NAL_TYPE_RADL(nal_type) ((nal_type) == GST_H266_NAL_SLICE_RADL)
+
+/**
+ * GST_H266_IS_NAL_TYPE_RASL:
+ * @nal_type: a #GstH266NalUnitType
+ *
+ * Check whether @nal_type is RASL or not.
+ */
+#define GST_H266_IS_NAL_TYPE_RASL(nal_type) ((nal_type) == GST_H266_NAL_SLICE_RASL)
+
+/**
+ * GstH266ParserResult:
+ *
+ * The result of parsing H266 data.
+ *
+ * @GST_H266_PARSER_OK: The parsing succeeded.
+ * @GST_H266_PARSER_BROKEN_DATA: The data to parse is broken.
+ * @GST_H266_PARSER_BROKEN_LINK: The link to structure needed for the parsing
+ *  couldn't be found.
+ * @GST_H266_PARSER_ERROR: An error accured when parsing.
+ * @GST_H266_PARSER_NO_NAL: No nal found during the parsing.
+ * @GST_H266_PARSER_NO_NAL_END: Start of the nal found, but not the end.
+ */
+typedef enum
+{
+  GST_H266_PARSER_OK,
+  GST_H266_PARSER_BROKEN_DATA,
+  GST_H266_PARSER_BROKEN_LINK,
+  GST_H266_PARSER_ERROR,
+  GST_H266_PARSER_NO_NAL,
+  GST_H266_PARSER_NO_NAL_END
+} GstH266ParserResult;
+
+/**
+ * GstH266Profile:
+ *
+ * H.266 Profiles.
+ *
+ * @GST_H266_PROFILE_MAIN_10: Main 10 profile (A.3.1).
+ * @GST_H266_PROFILE_MAIN_10_STILL_PICTURE: Main 10 Still Picture profile (A.3.1).
+ * @GST_H266_PROFILE_MULTILAYER_MAIN_10: MultiLayer Main 10 profile (A.3.3).
+ * @GST_H266_PROFILE_MULTILAYER_MAIN_10_STILL_PICTURE: MultiLayer Main 10 Still
+ *  Picture profile (A.3.3).
+ * @GST_H266_PROFILE_MAIN_10_444: Main 10 4:4:4 profile (A.3.2).
+ * @GST_H266_PROFILE_MAIN_10_444_STILL_PICTURE: Main 10 4:4:4 Still Picture
+ *  profile (A.3.2).
+ * @GST_H266_PROFILE_MULTILAYER_MAIN_10_444: MultiLayer Main 10 4:4:4
+ *  profile (A.3.4).
+ * @GST_H266_PROFILE_MULTILAYER_MAIN_10_444_STILL_PICTURE: MultiLayer Main 10
+ *  4:4:4 Still Picture profile (A.3.4).
+ * @GST_H266_PROFILE_MAIN_12: Main 12 profile (A.3.5).
+ * @GST_H266_PROFILE_MAIN_12_444: Main 12 4:4:4 profile (A.3.5).
+ * @GST_H266_PROFILE_MAIN_16_444: Main 16 4:4:4 profile (A.3.5).
+ * @GST_H266_PROFILE_MAIN_12_INTRA: Main 12 Intra profile (A.3.5).
+ * @GST_H266_PROFILE_MAIN_12_444_INTRA: Main 12 4:4:4 Intra profile (A.3.5).
+ * @GST_H266_PROFILE_MAIN_16_444_INTRA: Main 16 4:4:4 Intra profile (A.3.5).
+ * @GST_H266_PROFILE_MAIN_12_STILL_PICTURE: Main 12 Still Picture profile (A.3.5).
+ * @GST_H266_PROFILE_MAIN_12_444_STILL_PICTURE: Main 12 4:4:4 Still Picture
+ *  profile (A.3.5).
+ * @GST_H266_PROFILE_MAIN_16_444_STILL_PICTURE: Main 16 4:4:4 Still Picture
+ *  profile (A.3.5).
+ */
+typedef enum {
+  GST_H266_PROFILE_INVALID                              = -1,
+  GST_H266_PROFILE_NONE                                 = 0,
+
+  GST_H266_PROFILE_INTRA                                = 8,
+  GST_H266_PROFILE_STILL_PICTURE                        = 64,
+
+  GST_H266_PROFILE_MAIN_10                              = 1,
+  GST_H266_PROFILE_MAIN_10_STILL_PICTURE                = GST_H266_PROFILE_MAIN_10 | GST_H266_PROFILE_STILL_PICTURE,
+  GST_H266_PROFILE_MULTILAYER_MAIN_10                   = 17,
+  GST_H266_PROFILE_MULTILAYER_MAIN_10_STILL_PICTURE     = GST_H266_PROFILE_MULTILAYER_MAIN_10 | GST_H266_PROFILE_STILL_PICTURE,
+  GST_H266_PROFILE_MAIN_10_444                          = 33,
+  GST_H266_PROFILE_MAIN_10_444_STILL_PICTURE            = GST_H266_PROFILE_MAIN_10_444 | GST_H266_PROFILE_STILL_PICTURE,
+  GST_H266_PROFILE_MULTILAYER_MAIN_10_444               = 49,
+  GST_H266_PROFILE_MULTILAYER_MAIN_10_444_STILL_PICTURE = GST_H266_PROFILE_MULTILAYER_MAIN_10_444 | GST_H266_PROFILE_STILL_PICTURE,
+  GST_H266_PROFILE_MAIN_12                              = 2,
+  GST_H266_PROFILE_MAIN_12_444                          = 34,
+  GST_H266_PROFILE_MAIN_16_444                          = 35,
+  GST_H266_PROFILE_MAIN_12_INTRA                        = GST_H266_PROFILE_MAIN_12 | GST_H266_PROFILE_INTRA,
+  GST_H266_PROFILE_MAIN_12_444_INTRA                    = GST_H266_PROFILE_MAIN_12_444 | GST_H266_PROFILE_INTRA,
+  GST_H266_PROFILE_MAIN_16_444_INTRA                    = GST_H266_PROFILE_MAIN_16_444 | GST_H266_PROFILE_INTRA,
+  GST_H266_PROFILE_MAIN_12_STILL_PICTURE                = GST_H266_PROFILE_MAIN_12 | GST_H266_PROFILE_STILL_PICTURE,
+  GST_H266_PROFILE_MAIN_12_444_STILL_PICTURE            = GST_H266_PROFILE_MAIN_12_444 | GST_H266_PROFILE_STILL_PICTURE,
+  GST_H266_PROFILE_MAIN_16_444_STILL_PICTURE            = GST_H266_PROFILE_MAIN_16_444 | GST_H266_PROFILE_STILL_PICTURE,
+
+  /* end of the profiles */
+  GST_H266_PROFILE_MAX
+} GstH266Profile;
+
+/**
+ * GstH266Level:
+ *
+ * H.266 level.
+ *
+ */
+typedef enum
+{
+  GST_H266_LEVEL_L1_0 = 16,
+  GST_H266_LEVEL_L2_0 = 32,
+  GST_H266_LEVEL_L2_1 = 35,
+  GST_H266_LEVEL_L3_0 = 48,
+  GST_H266_LEVEL_L3_1 = 51,
+  GST_H266_LEVEL_L4_0 = 64,
+  GST_H266_LEVEL_L4_1 = 67,
+  GST_H266_LEVEL_L5_0 = 80,
+  GST_H266_LEVEL_L5_1 = 83,
+  GST_H266_LEVEL_L5_2 = 86,
+  GST_H266_LEVEL_L6_0 = 96,
+  GST_H266_LEVEL_L6_1 = 99,
+  GST_H266_LEVEL_L6_2 = 102,
+  GST_H266_LEVEL_L6_3 = 105,
+} GstH266Level;
+
+/**
+ * GstH266NalUnitType:
+ *
+ * Indicates the types of H266 Nal Units as
+ * table 5 - NAL unit type codes and NAL unit type classes.
+ *
+ * @GST_H266_NAL_SLICE_TRAIL: Coded slice of a trailing picture or subpicture.
+ * @GST_H266_NAL_SLICE_STSA: Coded slice of an STSA picture or subpicture.
+ * @GST_H266_NAL_SLICE_RADL: Coded slice of a RADL picture or subpicture.
+ * @GST_H266_NAL_SLICE_RASL: Coded slice of a RASL picture or subpicture.
+ * @GST_H266_NAL_SLICE_IDR_W_RADL: Coded slice of an IDR picture or subpicture.
+ * @GST_H266_NAL_SLICE_IDR_N_LP: Coded slice of an IDR picture or subpicture.
+ * @GST_H266_NAL_SLICE_CRA: Coded slice of a CRA picture or subpicture.
+ * @GST_H266_NAL_SLICE_GDR: Coded slice of a GDR picture or subpicture.
+ * @GST_H266_NAL_OPI: Operating point information.
+ * @GST_H266_NAL_DCI: Decoding capability information.
+ * @GST_H266_NAL_VPS: Video parameter set(VPS).
+ * @GST_H266_NAL_SPS: Sequence parameter set (SPS).
+ * @GST_H266_NAL_PPS: Picture parameter set (PPS).
+ * @GST_H266_NAL_PREFIX_APS: Prefix Adaptation parameter set (APS).
+ * @GST_H266_NAL_SUFFIX_APS: Suffix Adaptation parameter set (APS).
+ * @GST_H266_NAL_PH: Picture header (PH).
+ * @GST_H266_NAL_AUD: AU delimiter.
+ * @GST_H266_NAL_EOS: End of sequence (EOS).
+ * @GST_H266_NAL_EOB: End of bitstream (EOB).
+ * @GST_H266_NAL_PREFIX_SEI: Prefix Supplemental enhancement information.
+ * @GST_H266_NAL_SUFFIX_SEI: Suffix Suppliemental enhancement information.
+ * @GST_H266_NAL_FD: Filler data (FD).
+ */
+typedef enum
+{
+  GST_H266_NAL_SLICE_TRAIL      = 0,
+  GST_H266_NAL_SLICE_STSA       = 1,
+  GST_H266_NAL_SLICE_RADL       = 2,
+  GST_H266_NAL_SLICE_RASL       = 3,
+  GST_H266_NAL_SLICE_IDR_W_RADL = 7,
+  GST_H266_NAL_SLICE_IDR_N_LP   = 8,
+  GST_H266_NAL_SLICE_CRA        = 9,
+  GST_H266_NAL_SLICE_GDR        = 10,
+  GST_H266_NAL_OPI              = 12,
+  GST_H266_NAL_DCI              = 13,
+  GST_H266_NAL_VPS              = 14,
+  GST_H266_NAL_SPS              = 15,
+  GST_H266_NAL_PPS              = 16,
+  GST_H266_NAL_PREFIX_APS       = 17,
+  GST_H266_NAL_SUFFIX_APS       = 18,
+  GST_H266_NAL_PH               = 19,
+  GST_H266_NAL_AUD              = 20,
+  GST_H266_NAL_EOS              = 21,
+  GST_H266_NAL_EOB              = 22,
+  GST_H266_NAL_PREFIX_SEI       = 23,
+  GST_H266_NAL_SUFFIX_SEI       = 24,
+  GST_H266_NAL_FD               = 25,
+} GstH266NalUnitType;
+
+/**
+ * GstH266SEIPayloadType:
+ *
+ * The type of SEI message.
+ * More other SEIs are specified in Rec.ITU-T H.274 | ISO/IEC 23002-7.
+ *
+ * @GST_H266_SEI_BUF_PERIOD: Buffering Period SEI Message.
+ * @GST_H266_SEI_PIC_TIMING: Picture Timing SEI Message.
+ * @GST_H266_SEI_REGISTERED_USER_DATA: Registered user data.
+ * @GST_H266_SEI_USER_DATA_UNREGISTERED: User data Unregistered.
+ * @GST_H266_SEI_DU_INFO: DU Information SEI Message.
+ * @GST_H266_SEI_SCALABLE_NETING: Scalable Nesting SEI Message.
+ * @GST_H266_SEI_FRAME_FIELD_INFO: Frame Field Info SEI Message.
+ * @GST_H266_SEI_SUBPIC_LEVEL_INFO: Subpicture Level Information SEI.
+ */
+typedef enum
+{
+  GST_H266_SEI_BUF_PERIOD = 0,
+  GST_H266_SEI_PIC_TIMING = 1,
+  GST_H266_SEI_REGISTERED_USER_DATA = 4,
+  GST_H266_SEI_USER_DATA_UNREGISTERED = 5,
+  GST_H266_SEI_DU_INFO = 130,
+  GST_H266_SEI_SCALABLE_NESTING = 133,
+  GST_H266_SEI_FRAME_FIELD_INFO = 168,
+  GST_H266_SEI_SUBPIC_LEVEL_INFO = 203,
+  /* and more...  */
+} GstH266SEIPayloadType;
+
+/**
+ * GstH266SliceType:
+ *
+ * Types of Picture slice.
+ *
+ * @GST_H266_B_SLICE: B slice type.
+ * @GST_H266_P_SLICE: P slice type.
+ * @GST_H266_I_SLICE: I slice type.
+ */
+typedef enum
+{
+  GST_H266_B_SLICE = 0,
+  GST_H266_P_SLICE = 1,
+  GST_H266_I_SLICE = 2
+} GstH266SliceType;
+
+/**
+ * GstH266APSType:
+ *
+ * Indicates the types of Adaptation parameter set (APS) as
+ * Table 6 - APS parameters type codes and types of APS parameters.
+ *
+ * @GST_H266_ALF_APS: ALF parameters.
+ * @GST_H266_LMCS_APS: LMCS parameters.
+ * @GST_H266_SCALING_APS: Scaling list parameters.
+ */
+typedef enum
+{
+  GST_H266_ALF_APS      = 0,
+  GST_H266_LMCS_APS     = 1,
+  GST_H266_SCALING_APS  = 2,
+  /* end of the aps type */
+  GST_H266_APS_TYPE_MAX = 3
+} GstH266APSType;
+
+typedef struct _GstH266Parser                   GstH266Parser;
+typedef struct _GstH266NalUnit                  GstH266NalUnit;
+
+typedef struct _GstH266VPS                      GstH266VPS;
+typedef struct _GstH266SPS                      GstH266SPS;
+typedef struct _GstH266PPS                      GstH266PPS;
+typedef struct _GstH266APS                      GstH266APS;
+typedef struct _GstH266ProfileTierLevel         GstH266ProfileTierLevel;
+typedef struct _GstH266GeneralConstraintsInfo   GstH266GeneralConstraintsInfo;
+typedef struct _GstH266DPBParameters            GstH266DPBParameters;
+typedef struct _GstH266GeneralHRDParameters     GstH266GeneralHRDParameters;
+typedef struct _GstH266OLSHRDParameters         GstH266OLSHRDParameters;
+typedef struct _GstH266SubLayerHRDParameters    GstH266SubLayerHRDParameters;
+typedef struct _GstH266HRDParams                GstH266HRDParams;
+typedef struct _GstH266VUIParams                GstH266VUIParams;
+typedef struct _GstH266SPSRangeExtensionParams  GstH266SPSRangeExtensionParams;
+
+typedef struct _GstH266ALF                      GstH266ALF;
+typedef struct _GstH266LMCS                     GstH266LMCS;
+typedef struct _GstH266ScalingList              GstH266ScalingList;
+
+typedef struct _GstH266PredWeightTable          GstH266PredWeightTable;
+typedef struct _GstH266RefPicListStruct         GstH266RefPicListStruct;
+typedef struct _GstH266RefPicLists              GstH266RefPicLists;
+typedef struct _GstH266SliceHdr                 GstH266SliceHdr;
+typedef struct _GstH266PicHdr                   GstH266PicHdr;
+typedef struct _GstH266AUD                      GstH266AUD;
+typedef struct _GstH266OPI                      GstH266OPI;
+typedef struct _GstH266DCI                      GstH266DCI;
+
+typedef struct _GstH266BufferingPeriod          GstH266BufferingPeriod;
+typedef struct _GstH266PicTiming                GstH266PicTiming;
+typedef struct _GstH266DUInfo                   GstH266DUInfo;
+typedef struct _GstH266ScalableNesting          GstH266ScalableNesting;
+typedef struct _GstH266SubPicLevelInfo          GstH266SubPicLevelInfo;
+typedef struct _GstH266FrameFieldInfo           GstH266FrameFieldInfo;
+typedef struct _GstH266SEIMessage               GstH266SEIMessage;
+
+/**
+ * GstH266NalUnit:
+ *
+ * Structure defining the H266 Nal unit headers.
+ *
+ * @type: A #GstH266NalUnitType.
+ * @layer_id: A nal unit layer id.
+ * @temporal_id_plus1: A nal unit temporal identifier.
+ * @size: The size of the nal unit starting from @offset.
+ * @offset: The offset of the actual start of the nal unit.
+ * @sc_offset:The offset of the start code of the nal unit.
+ * @valid: If the nal unit is valid, which mean it has
+ *  already been parsed.
+ * @data: The data from which the Nalu has been parsed.
+ * @header_bytes: The size of the NALU header in bytes.
+ */
+struct _GstH266NalUnit
+{
+  guint8 type;
+  guint8 layer_id;
+  guint8 temporal_id_plus1;
+
+  /* calculated values */
+  guint size;
+  guint offset;
+  guint sc_offset;
+  gboolean valid;
+
+  guint8 *data;
+  guint8 header_bytes;
+};
+
+/**
+ * GstH266GeneralConstraintsInfo:
+ *
+ * Structure defining the H266 general constraints info.
+ *
+ * @present_flag: specifies whether additional syntax elements are present.
+ * @intra_only_constraint_flag: specifies whether sh_slice_type for all slices
+ *  in OlsInScope shall be equal to 2.
+ * @all_layers_independent_constraint_flag: specifies whether the
+ *  vps_all_independent_layers_flag for all pictures in OlsInScope
+ *  shall be equal to 1.
+ * @one_au_only_constraint_flag: specifies whether there is only one
+ *  AU in OlsInScope.
+ * @sixteen_minus_max_bitdepth_constraint_idc: specifies whether
+ *  sps_bitdepth_minus8 plus 8 for all pictures in OlsInScope shall be in the
+ *  range of 0 to 16 - gci_sixteen_minus_max_bitdepth_constraint_idc, inclusive.
+ * @three_minus_max_chroma_format_constraint_idc: specifies whether the
+ *  sps_chroma_format_idc for all pictures in OlsInScope shall be in the range
+ *  of 0 to 3 - gci_three_minus_max_chroma_format_constraint_idc, inclusive.
+ * @no_mixed_nalu_types_in_pic_constraint_flag: specifies whether the
+ *  pps_mixed_nalu_types_in_pic_flag for all pictures in OlsInScope shall
+ *  be equal to 0.
+ * @no_trail_constraint_flag: specifies whether there shall be no NAL unit
+ *  with nuh_unit_type equal to TRAIL_NUT present in OlsInScope.
+ * @no_stsa_constraint_flag: specifies whether there shall be no NAL unit with
+ *  nuh_unit_type equal to STSA_NUT present in OlsInScope.
+ * @no_rasl_constraint_flag: specifies whether there shall be no NAL unit with
+ *  nuh_unit_type equal to RASL_NUT present in OlsInScope.
+ * @no_radl_constraint_flag: specifies whether there shall be no NAL unit with
+ *  nuh_unit_type equal to RADL_NUT present in OlsInScope.
+ * @no_idr_constraint_flag: specifies whether there shall be no NAL unit with
+ *  nuh_unit_type equal to IDR_W_RADL or IDR_N_LP present in OlsInScope.
+ * @no_cra_constraint_flag: specifies whether there shall be no NAL unit with
+ *  nuh_unit_type equal to CRA_NUT present in OlsInScope.
+ * @no_gdr_constraint_flag: specifies whether sps_gdr_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_aps_constraint_flag: specifies whether there shall be no NAL unit with
+ *  nuh_unit_type equal to PREFIX_APS_NUT or SUFFIX_APS_NUT present in
+ *  OlsInScope.
+ * @no_idr_rpl_constraint_flag: specifies whether sps_idr_rpl_present_flag for
+ *  all pictures in OlsInScope shall be equal to 0.
+ * @one_tile_per_pic_constraint_flag: specifies whether each picture in
+ *  OlsInScope shall contain only one tile.
+ * @pic_header_in_slice_header_constraint_flag: specifies whether each picture
+ *  in OlsInScope shall contain only one slice and the value of
+ *  sh_picture_header_in_slice_header_flag in each slice in OlsInScope shall
+ *  be equal to 1.
+ * @one_slice_per_pic_constraint_flag: specifies whether each picture in
+ *  OlsInScope shall contain only one slice.
+ * @no_rectangular_slice_constraint_flag: specifies whether pps_rect_slice_flag
+ *  for all pictures in OlsInScope shall be equal to 0.
+ * @one_slice_per_subpic_constraint_flag: specifies whether the value of
+ *  pps_single_slice_per_subpic_flag for all pictures in OlsInScope shall
+ *  be equal to 1.
+ * @no_subpic_info_constraint_flag: specifies whether sps_subpic_info_present_flag
+ *  for all pictures in OlsInScope shall be equal to 0.
+ * @three_minus_max_log2_ctu_size_constraint_idc: specifies whether
+ *  sps_log2_ctu_size_minus5 for all pictures in OlsInScope shall be in the
+ *  range of 0 to 3-gci_three_minus_max_log2_ctu_size_constraint_idc, inclusive.
+ * @no_partition_constraints_override_constraint_flag: specifies whether
+ *  sps_partition_constraints_override_enabled_flag for all pictures in
+ *  OlsInScope shall be equal to 0.
+ * @no_mtt_constraint_flag: specifies whether
+ *  sps_max_mtt_hierarchy_depth_intra_slice_luma,
+ *  sps_max_mtt_hierarchy_depth_inter_slice, and
+ *  sps_max_mtt_hierarchy_depth_intra_slice_chroma for all pictures in
+ *  OlsInScope shall be equal to 0.
+ * @no_qtbtt_dual_tree_intra_constraint_flag: specifies whether
+ *  sps_qtbtt_dual_tree_intra_flag for all pictures in OlsInScope shall
+ *  be equal to 0.
+ * @no_palette_constraint_flag: specifies whether sps_palette_enabled_flag
+ *  for all pictures in OlsInScope shall be equal to 0.
+ * @no_ibc_constraint_flag: specifies whether sps_ibc_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_isp_constraint_flag: specifies whether sps_isp_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_mrl_constraint_flag: specifies whether sps_mrl_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_mip_constraint_flag: specifies whether sps_mip_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_cclm_constraint_flag: specifies whether sps_cclm_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_ref_pic_resampling_constraint_flag: specifies whether
+ *  sps_ref_pic_resampling_enabled_flag for all pictures in OlsInScope shall
+ *  be equal to 0.
+ * @no_res_change_in_clvs_constraint_flag: specifies whether
+ *  sps_res_change_in_clvs_allowed_flag for all pictures in OlsInScope shall
+ *  be equal to 0.
+ * @no_weighted_prediction_constraint_flag: specifies whether
+ *  sps_weighted_pred_flag and sps_weighted_bipred_flag for all pictures in
+ *  OlsInScope shall both be equal to 0.
+ * @no_ref_wraparound_constraint_flag: specifies whether
+ *  sps_ref_wraparound_enabled_flag for all pictures in OlsInScope shall be
+ *  equal to 0.
+ * @no_temporal_mvp_constraint_flag: specifies whether
+ *  sps_temporal_mvp_enabled_flag for all pictures in OlsInScope shall be
+ *  equal to 0.
+ * @no_sbtmvp_constraint_flag: specifies whether sps_sbtmvp_enabled_flag
+ *  for all pictures in OlsInScope shall be equal to 0.
+ * @no_amvr_constraint_flag: specifies whether sps_amvr_enabled_flag for
+ *  all pictures in OlsInScope shall be equal to 0.
+ * @no_bdof_constraint_flag: specifies whether sps_bdof_enabled_flag for
+ *  all pictures in OlsInScope shall be equal to 0.
+ * @no_smvd_constraint_flag: specifies whether sps_smvd_enabled_flag for
+ *  all pictures in OlsInScope shall be equal to 0.
+ * @no_dmvr_constraint_flag: specifies whether sps_dmvr_enabled_flag for
+ *  all pictures in OlsInScope shall be equal to 0.
+ * @no_mmvd_constraint_flag: specifies whether sps_mmvd_enabled_flag for
+ *  all pictures in OlsInScope shall be equal to 0.
+ * @no_affine_motion_constraint_flag: specifies whether sps_affine_enabled_flag
+ *  for all pictures in OlsInScope shall be equal to 0.
+ * @no_prof_constraint_flag: specifies whether sps_affine_prof_enabled_flag for
+ *  all pictures in OlsInScope shall be equal to 0.
+ * @no_bcw_constraint_flag: specifies whether sps_bcw_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_ciip_constraint_flag: specifies whether sps_ciip_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_gpm_constraint_flag: specifies whether sps_gpm_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_luma_transform_size_64_constraint_flag: specifies whether
+ *  sps_max_luma_transform_size_64_flag for all pictures in OlsInScope shall
+ *  be equal to 0.
+ * @no_transform_skip_constraint_flag: specifies whether
+ *  sps_transform_skip_enabled_flag for all pictures in OlsInScope shall
+ *  be equal to 0.
+ * @no_bdpcm_constraint_flag: specifies whether sps_bdpcm_enabled_flag for
+ *  all pictures in OlsInScope shall be equal to 0.
+ * @no_mts_constraint_flag: specifies whether sps_mts_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_lfnst_constraint_flag: specifies whether sps_lfnst_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_joint_cbcr_constraint_flag: specifies whether sps_joint_cbcr_enabled_flag
+ *  for all pictures in OlsInScope shall be equal to 0.
+ * @no_sbt_constraint_flag: specifies whether sps_sbt_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_act_constraint_flag: specifies whether sps_act_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_explicit_scaling_list_constraint_flag: specifies whether
+ *  sps_explicit_scaling_list_enabled_flag for all pictures in OlsInScope shall
+ *  be equal to 0.
+ * @no_dep_quant_constraint_flag: specifies whether sps_dep_quant_enabled_flag
+ *  for all pictures in OlsInScope shall be equal to 0.
+ * @no_sign_data_hiding_constraint_flag: specifies whether
+ *  sps_sign_data_hiding_enabled_flag for all pictures in OlsInScope shall
+ *  be equal to 0.
+ * @no_cu_qp_delta_constraint_flag: specifies whether
+ *  pps_cu_qp_delta_enabled_flag for all pictures in OlsInScope shall be
+ *  equal to 0.
+ * @no_chroma_qp_offset_constraint_flag: specifies whether
+ *  pps_cu_chroma_qp_offset_list_enabled_flag for all pictures in OlsInScope
+ *  shall be equal to 0.
+ * @no_sao_constraint_flag: specifies whether sps_sao_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_alf_constraint_flag: specifies whether sps_alf_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_ccalf_constraint_flag: specifies whether sps_ccalf_enabled_flag for
+ *  all pictures in OlsInScope shall be equal to 0.
+ * @no_lmcs_constraint_flag: specifies whether sps_lmcs_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_ladf_constraint_flag: specifies whether sps_ladf_enabled_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @no_virtual_boundaries_constraint_flag: specifies whether
+ *  sps_virtual_boundaries_enabled_flag for all pictures in OlsInScope shall
+ *  be equal to 0.
+ * @all_rap_pictures_constraint_flag: specifies whether all pictures in
+ *  OlsInScope are GDR pictures with ph_recovery_poc_cnt equal to 0 or IRAP
+ *  pictures.
+ * @no_extended_precision_processing_constraint_flag: specifies whether
+ *  sps_extended_precision_flag for all pictures in OlsInScope shall be
+ *  equal to 0.
+ * @no_ts_residual_coding_rice_constraint_flag: specifies whether
+ *  sps_ts_residual_coding_rice_present_in_sh_flag for all pictures in
+ *  OlsInScope should be equal to 0.
+ * @no_rrc_rice_extension_constraint_flag: specifies whether
+ *  sps_rrc_rice_extension_flag for all pictures in OlsInScope shall be
+ *  equal to 0.
+ * @no_persistent_rice_adaptation_constraint_flag: specifies whether
+ *  sps_persistent_rice_adaptation_enabled_flag for all pictures in OlsInScope
+ *  shall be equal to 0.
+ * @no_reverse_last_sig_coeff_constraint_flag: specifies whether
+ *  sps_reverse_last_sig_coeff_enabled_flag for all pictures in OlsInScope
+ *  shall be equal to 0.
+ * @reserved_zero_bit: the reserved bits.
+ */
+struct _GstH266GeneralConstraintsInfo {
+  guint8 present_flag;
+
+  /* general */
+  guint8 intra_only_constraint_flag;
+  guint8 all_layers_independent_constraint_flag;
+  guint8 one_au_only_constraint_flag;
+  /* picture format */
+  guint8 sixteen_minus_max_bitdepth_constraint_idc;
+  guint8 three_minus_max_chroma_format_constraint_idc;
+  /* NAL unit type related */
+  guint8 no_mixed_nalu_types_in_pic_constraint_flag;
+  guint8 no_trail_constraint_flag;
+  guint8 no_stsa_constraint_flag;
+  guint8 no_rasl_constraint_flag;
+  guint8 no_radl_constraint_flag;
+  guint8 no_idr_constraint_flag;
+  guint8 no_cra_constraint_flag;
+  guint8 no_gdr_constraint_flag;
+  guint8 no_aps_constraint_flag;
+  guint8 no_idr_rpl_constraint_flag;
+  /* tile, slice, subpicture partitioning */
+  guint8 one_tile_per_pic_constraint_flag;
+  guint8 pic_header_in_slice_header_constraint_flag;
+  guint8 one_slice_per_pic_constraint_flag;
+  guint8 no_rectangular_slice_constraint_flag;
+  guint8 one_slice_per_subpic_constraint_flag;
+  guint8 no_subpic_info_constraint_flag;
+  /* CTU and block partitioning */
+  guint8 three_minus_max_log2_ctu_size_constraint_idc;
+  guint8 no_partition_constraints_override_constraint_flag;
+  guint8 no_mtt_constraint_flag;
+  guint8 no_qtbtt_dual_tree_intra_constraint_flag;
+  /* intra */
+  guint8 no_palette_constraint_flag;
+  guint8 no_ibc_constraint_flag;
+  guint8 no_isp_constraint_flag;
+  guint8 no_mrl_constraint_flag;
+  guint8 no_mip_constraint_flag;
+  guint8 no_cclm_constraint_flag;
+  /* inter */
+  guint8 no_ref_pic_resampling_constraint_flag;
+  guint8 no_res_change_in_clvs_constraint_flag;
+  guint8 no_weighted_prediction_constraint_flag;
+  guint8 no_ref_wraparound_constraint_flag;
+  guint8 no_temporal_mvp_constraint_flag;
+  guint8 no_sbtmvp_constraint_flag;
+  guint8 no_amvr_constraint_flag;
+  guint8 no_bdof_constraint_flag;
+  guint8 no_smvd_constraint_flag;
+  guint8 no_dmvr_constraint_flag;
+  guint8 no_mmvd_constraint_flag;
+  guint8 no_affine_motion_constraint_flag;
+  guint8 no_prof_constraint_flag;
+  guint8 no_bcw_constraint_flag;
+  guint8 no_ciip_constraint_flag;
+  guint8 no_gpm_constraint_flag;
+  /* transform, quantization, residual */
+  guint8 no_luma_transform_size_64_constraint_flag;
+  guint8 no_transform_skip_constraint_flag;
+  guint8 no_bdpcm_constraint_flag;
+  guint8 no_mts_constraint_flag;
+  guint8 no_lfnst_constraint_flag;
+  guint8 no_joint_cbcr_constraint_flag;
+  guint8 no_sbt_constraint_flag;
+  guint8 no_act_constraint_flag;
+  guint8 no_explicit_scaling_list_constraint_flag;
+  guint8 no_dep_quant_constraint_flag;
+  guint8 no_sign_data_hiding_constraint_flag;
+  guint8 no_cu_qp_delta_constraint_flag;
+  guint8 no_chroma_qp_offset_constraint_flag;
+  /* loop fitler */
+  guint8 no_sao_constraint_flag;
+  guint8 no_alf_constraint_flag;
+  guint8 no_ccalf_constraint_flag;
+  guint8 no_lmcs_constraint_flag;
+  guint8 no_ladf_constraint_flag;
+  guint8 no_virtual_boundaries_constraint_flag;
+  /* additional bits */
+  guint8 all_rap_pictures_constraint_flag;
+  guint8 no_extended_precision_processing_constraint_flag;
+  guint8 no_ts_residual_coding_rice_constraint_flag;
+  guint8 no_rrc_rice_extension_constraint_flag;
+  guint8 no_persistent_rice_adaptation_constraint_flag;
+  guint8 no_reverse_last_sig_coeff_constraint_flag;
+  /* reserved for future use */
+  guint8 reserved_zero_bit[64];
+};
+
+/**
+ * GstH266ProfileTierLevel:
+ *
+ * Structure defining the H266 profile, tier and level.
+ *
+ * @profile_idc: the profile id.
+ * @tier_flag: specifies the main tier or high tier.
+ * @level_idc: indicates a level to which OlsInScope conforms
+ *  as specified in Annex A.
+ * @frame_only_constraint_flag: specifies whether sps_field_seq_flag for all
+ *  pictures in OlsInScope shall be equal to 0.
+ * @multilayer_enabled_flag: specifies whether the CVSs of OlsInScope
+ *  might contain more than one layer.
+ * @general_constraints_info: the #GstH266GeneralConstraintsInfo contains
+ *  the general constraints info.
+ * @sublayer_level_present_flag: specifies whether level information is present
+ *  in the profile_tier_level() syntax structure for the sublayer representation.
+ * @sublayer_level_idc: the sublayer level idc.
+ * @num_sub_profiles: specifies the number of the general_sub_profile_idc[i]
+ *  syntax elements.
+ * @sub_profile_idc: specifies the i-th interoperability indicator registered
+ *  as specified by Rec. ITU-T T.35
+ */
+struct _GstH266ProfileTierLevel {
+  GstH266Profile profile_idc;
+  guint8 tier_flag;
+  guint8 level_idc;
+  guint8 frame_only_constraint_flag;
+  guint8 multilayer_enabled_flag;
+
+  GstH266GeneralConstraintsInfo general_constraints_info;
+
+  guint8 sublayer_level_present_flag[GST_H266_MAX_SUBLAYERS - 1];
+  guint8 sublayer_level_idc[GST_H266_MAX_SUBLAYERS - 1];
+  guint8 num_sub_profiles;
+  GstH266Profile sub_profile_idc[GST_H266_MAX_SUB_PROFILES];
+
+  guint8 ptl_reserved_zero_bit;
+};
+
+/**
+ * GstH266DPBParameters:
+ *
+ * Structure defining the H266 DPB parameters.
+ *
+ * @max_dec_pic_buffering_minus1: specifies the maximum required size of the
+ *  DPB in units of picture storage buffers.
+ * @max_num_reorder_pics: specifies the maximum allowed number of pictures of
+ *  the OLS that can precede any picture in the OLS in decoding order and
+ *  follow that picture in output.
+ * @max_latency_increase_plus1: used to compute the value of MaxLatencyPictures,
+ *  which specifies the maximum number of pictures in the OLS.
+ */
+struct _GstH266DPBParameters
+{
+  guint8 max_dec_pic_buffering_minus1[GST_H266_MAX_SUBLAYERS];
+  guint8 max_num_reorder_pics[GST_H266_MAX_SUBLAYERS];
+  guint8 max_latency_increase_plus1[GST_H266_MAX_SUBLAYERS];
+};
+
+/**
+ * GstH266GeneralHRDParameters:
+ *
+ * Structure defining the H266 HDR parameters.
+ *
+ * @num_units_in_tick: the number of time units of a clock operating at the
+ *  frequency time_scale.
+ * @time_scale: number of time units that pass in one second.
+ * @general_nal_hrd_params_present_flag: specifies whether NAL HRD parameters
+ *  are present in the general_timing_hrd_parameters() syntax structure.
+ * @general_vcl_hrd_params_present_flag: specifies whether VCL HRD parameters
+ *  are present in the general_timing_hrd_parameters() syntax structure.
+ * @general_same_pic_timing_in_all_ols_flag: specifies whether the
+ *  non-scalable-nested PT SEI message in each AU applies to the AU for any
+ *  OLS in the bitstream and no scalable-nested PT SEI messages are present.
+ * @general_du_hrd_params_present_flag: specifies whether DU level HRD
+ *  parameters are present and the HRD could operate at the AU level or DU level.
+ * @tick_divisor_minus2: specifies the clock sub-tick.
+ * @bit_rate_scale: specifies the maximum input bit rate of the CPB.
+ * @cpb_size_scale: specifies the CPB size of the CPB.
+ * @cpb_size_du_scale: specifies the CPB size of the CPB at du level.
+ * @hrd_cpb_cnt_minus1: plus 1 specifies the number of alternative CPB
+ *  delivery schedules.
+ */
+struct _GstH266GeneralHRDParameters
+{
+  guint32 num_units_in_tick;
+  guint32 time_scale;
+  guint8 general_nal_hrd_params_present_flag;
+  guint8 general_vcl_hrd_params_present_flag;
+  guint8 general_same_pic_timing_in_all_ols_flag;
+  guint8 general_du_hrd_params_present_flag;
+  guint8 tick_divisor_minus2;
+  guint8 bit_rate_scale;
+  guint8 cpb_size_scale;
+  guint8 cpb_size_du_scale;
+  guint8 hrd_cpb_cnt_minus1;
+};
+
+/**
+ * GstH266SubLayerHRDParameters:
+ *
+ * Structure defining the H266 sub layer HDR parameters.
+ *
+ * @bit_rate_value_minus1: specifies the maximum input bit rate for the CPB.
+ * @cpb_size_value_minus1: together with cpb_size_scale to specify the CPB size.
+ * @cpb_size_du_value_minus1: together with cpb_size_du_scale to specify
+ *  the CPB size.
+ * @bit_rate_du_value_minus1: specifies the maximum input bit rate for the CPB.
+ * @cbr_flag: specifies whether to decode this bitstream by the HRD using
+ *  the CPB specification.
+ * @bit_rate: the calculated bit rate.
+ * @cpb_size: the calculated cpb size.
+ */
+struct _GstH266SubLayerHRDParameters
+{
+  guint32 bit_rate_value_minus1[GST_H266_MAX_CPB_CNT];
+  guint32 cpb_size_value_minus1[GST_H266_MAX_CPB_CNT];
+  guint32 cpb_size_du_value_minus1[GST_H266_MAX_CPB_CNT];
+  guint32 bit_rate_du_value_minus1[GST_H266_MAX_CPB_CNT];
+  guint8 cbr_flag[GST_H266_MAX_CPB_CNT];
+  /* calculated values */
+  guint32 bit_rate[GST_H266_MAX_CPB_CNT];
+  guint32 cpb_size[GST_H266_MAX_CPB_CNT];
+};
+
+/**
+ * GstH266OLSHRDParameters:
+ *
+ * Structure defining the H266 OLS HDR parameters.
+ *
+ * @fixed_pic_rate_general_flag: indicates the temporal distance between the
+ *  HRD output times of consecutive pictures in output order is constrained as
+ *  specified in this clause using the variable DpbOutputElementalInterval[n].
+ * @fixed_pic_rate_within_cvs_flag: indicates the temporal distance between the
+ *  HRD output times of consecutive pictures in output order is constrained as
+ *  specified in this clause using the variable DpbOutputElementalInterval[n].
+ * @elemental_duration_in_tc_minus1: specifies the temporal distance between
+ *  the elemental units that specify the HRD output times of consecutive
+ *  pictures in output order.
+ * @low_delay_hrd_flag: specifies the HRD operational mode as specified
+ *  in Annex C.
+ * @nal_sub_layer_hrd_parameters: sub layer nal #GstH266SubLayerHRDParameters.
+ * @vcl_sub_layer_hrd_parameters: sub layer vcl #GstH266SubLayerHRDParameters.
+ */
+struct _GstH266OLSHRDParameters
+{
+  guint8 fixed_pic_rate_general_flag[GST_H266_MAX_SUBLAYERS];
+  guint8 fixed_pic_rate_within_cvs_flag[GST_H266_MAX_SUBLAYERS];
+  guint16 elemental_duration_in_tc_minus1[GST_H266_MAX_SUBLAYERS];
+  guint8 low_delay_hrd_flag[GST_H266_MAX_SUBLAYERS];
+  GstH266SubLayerHRDParameters nal_sub_layer_hrd_parameters[GST_H266_MAX_SUBLAYERS];
+  GstH266SubLayerHRDParameters vcl_sub_layer_hrd_parameters[GST_H266_MAX_SUBLAYERS];
+};
+
+/**
+ * GstH266VPS:
+ *
+ * Structure defining the H266 VPS.
+ *
+ * @vps_id: provides an identifier for the VPS for reference by other syntax
+ *  elements.
+ * @max_layers_minus1: specifies the number of layers specified by the VPS.
+ * @max_sublayers_minus1: specifies the maximum number of temporal sublayers
+ *  that may be present in a layer specified by the VPS.
+ * @default_ptl_dpb_hrd_max_tid_flag: specifies whether the syntax elements
+ *  vps_ptl_max_tid, vps_dpb_max_tid, and vps_hrd_max_tid are present.
+ * @all_independent_layers_flag: specifies whether all layers specified by the
+ *  VPS are independently coded without using inter-layer prediction.
+ * @layer_id: specifies the nuh_layer_id value of the i-th layer.
+ * @independent_layer_flag: specifies whether the layer with index i does not
+ *  use inter-layer prediction.
+ * @max_tid_ref_present_flag: specifies whether the syntax element
+ *  vps_max_tid_il_ref_pics_plus1 could be present.
+ * @direct_ref_layer_flag: specifies whether the layer with index j is not a
+ *  direct reference layer for the layer with index i.
+ * @max_tid_il_ref_pics_plus1: specifies whether the pictures of the j-th layer
+ *  that are neither IRAP pictures nor GDR pictures with ph_recovery_poc_cnt
+ *  equal to 0 are not used as ILRPs for decoding of pictures of the i-th layer.
+ * @each_layer_is_an_ols_flag: specifies whether each OLS specified by the VPS
+ *  contains only one layer and each layer specified by the VPS is an OLS with
+ *  the single included layer being the only output layer.
+ * @ols_mode_idc: specifies whether the total number of OLSs specified by the
+ *  VPS is equal to vps_max_layers_minus1 + 1.
+ * @total_num_olss: specifies the total number of OLSs specified by the VPS.
+ * @num_multi_layer_olss: specifies the number of multi-layer OLSs (i.e., OLSs
+ *  that contain more than one layer).
+ * @multi_layer_ols_idx: specifies the index to the list of multi-layer OLSs
+ *  for the i-th OLS.
+ * @num_layers_in_ols: specifies the number of layers in the i-th OLS.
+ * @layer_id_in_ols: specifies the nuh_layer_id value of the j-th layer in
+ *  the i-th OLS.
+ * @num_output_layer_sets_minus2: specifies the total number of OLSs
+ *  specified by the VPS when vps_ols_mode_idc is equal to 2.
+ * @ols_output_layer_flag: specifies whether the layer with nuh_layer_id
+ *  equal to vps_layer_id[j] is an output layer of the i-th OLS when
+ *  vps_ols_mode_idc is equal to 2.
+ * @num_output_layers_in_ols: specifies the number of output layers in
+ *  the i-th OLS.
+ * @output_layer_id_in_ols: specifies the nuh_layer_id value of the j-th
+ *  output layer in the i-th OLS.
+ * @num_sub_layers_in_layer_in_ols: specifies the number of sublayers in the
+ *  j-th layer in the i-th OLS.
+ * @num_ptls_minus1: specifies the number of profile_tier_level()
+ *  syntax structures in the VPS.
+ * @pt_present_flag: specifies whether profile, tier, and general constraints
+ *  information are present in the i-th profile_tier_level() syntax structure
+ *  in the VPS.
+ * @ptl_max_tid: specifies the TemporalId of the highest sublayer representation.
+ * @profile_tier_level: specifies the profile, tier and level using
+ *  #GstH266ProfileTierLevel.
+ * @ols_ptl_idx: specifies the index of the profile_tier_level() syntax
+ *  structure that applies to the i-th OLS.
+ * @num_dpb_params_minus1: specifies the number of dpb_parameters() syntax
+ *  strutcures in the VPS.
+ * @sublayer_dpb_params_present_flag: is used to control the presence of
+ *  dpb_max_dec_pic_buffering_minus1[j], dpb_max_num_reorder_pics[j], and
+ *  dpb_max_latency_increase_plus1[j] syntax elements in the dpb_parameters()
+ *  syntax strucures in the VPS.
+ * @dpb_max_tid: specifies the TemporalId of the highest sublayer representation
+ *  for which the DPB parameters could be present in the i-th dpb_parameters()
+ *  syntax strutcure in the VPS.
+ * @dpb: the DPB parameters using #GstH266DPBParameters.
+ * @ols_dpb_pic_width: specifies the width of each picture storage buffer for
+ *  the i-th multi-layer OLS.
+ * @ols_dpb_pic_height: specifies the height of each picture storage buffer
+ *  for the i-th multi-layer OLS.
+ * @ols_dpb_chroma_format: specifies the greatest allowed value of
+ *  sps_chroma_format_idc for all SPSs.
+ * @ols_dpb_bitdepth_minus8: specifies the greatest allowed value of
+ *  sps_bitdepth_minus8 for all SPSs.
+ * @ols_dpb_params_idx: specifies the index of the dpb_parameters() syntax
+ *  structure that applies to the i-th multi-layer OLS.
+ * @timing_hrd_params_present_flag: specifies whether the VPS contains a
+ *  general_timing_hrd_parameters() syntax structure and other HRD parameters.
+ * @general_hrd_params: HRD parameters in #GstH266GeneralHRDParameters.
+ * @sublayer_cpb_params_present_flag: specifies that the i-th
+ *  ols_timing_hrd_parameters() syntax structure in the VPS contains HRD
+ *  parameters for the sublayer representations.
+ * @num_ols_timing_hrd_params_minus1: specifies the number of
+ *  ols_timing_hrd_parameters() syntax structures present in the VPS.
+ * @hrd_max_tid: specifies the TemporalId of the highest sublayer representation
+ *  for which the HRD parameters are contained in the i-th
+ *  ols_timing_hrd_parameters() syntax structure.
+ * @ols_hrd_params: OLS HRD parameters using #GstH266OLSHRDParameters.
+ * @ols_timing_hrd_idx: specifies the index of the ols_timing_hrd_parameters()
+ *  syntax structure that applies to the i-th multi-layer OLS.
+ * @extension_flag: specifies whether no vps_extension_data_flag syntax elements
+ *  are present in the VPS RBSP syntax structure.
+ * @extension_data: could have any value, it is not defined in this version of
+ *  this Specification.
+ * @valid: whether this VPS is valid.
+ */
+struct _GstH266VPS {
+  guint8 vps_id;
+
+  guint8 max_layers_minus1;
+  guint8 max_sublayers_minus1;
+
+  guint8 default_ptl_dpb_hrd_max_tid_flag;
+  guint8 all_independent_layers_flag;
+
+  guint8 layer_id[GST_H266_MAX_LAYERS];
+  guint8 independent_layer_flag[GST_H266_MAX_LAYERS];
+  guint8 max_tid_ref_present_flag[GST_H266_MAX_LAYERS];
+  guint8 direct_ref_layer_flag[GST_H266_MAX_LAYERS][GST_H266_MAX_LAYERS];
+  guint8 max_tid_il_ref_pics_plus1[GST_H266_MAX_LAYERS][GST_H266_MAX_LAYERS];
+  guint8 each_layer_is_an_ols_flag;
+  guint8 ols_mode_idc;
+  guint total_num_olss;
+  guint num_multi_layer_olss;
+  guint16 multi_layer_ols_idx[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint16 num_layers_in_ols[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint8 layer_id_in_ols[GST_H266_MAX_TOTAL_NUM_OLSS][GST_H266_MAX_LAYERS];
+  guint8 num_output_layer_sets_minus2;
+  guint8 ols_output_layer_flag[GST_H266_MAX_TOTAL_NUM_OLSS][GST_H266_MAX_LAYERS];
+  guint16 num_output_layers_in_ols[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint8 output_layer_id_in_ols[GST_H266_MAX_TOTAL_NUM_OLSS][GST_H266_MAX_LAYERS];
+  guint8 num_sub_layers_in_layer_in_ols[GST_H266_MAX_TOTAL_NUM_OLSS][GST_H266_MAX_LAYERS];
+
+  guint8 num_ptls_minus1;
+  guint8 pt_present_flag[GST_H266_MAX_PTLS];
+  guint8 ptl_max_tid[GST_H266_MAX_PTLS];
+  GstH266ProfileTierLevel profile_tier_level[GST_H266_MAX_PTLS];
+  guint8 ols_ptl_idx[GST_H266_MAX_TOTAL_NUM_OLSS];
+
+  guint8 num_dpb_params_minus1;
+  guint8 sublayer_dpb_params_present_flag;
+  guint8 dpb_max_tid[GST_H266_MAX_TOTAL_NUM_OLSS];
+  GstH266DPBParameters dpb[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint16 ols_dpb_pic_width[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint16 ols_dpb_pic_height[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint8 ols_dpb_chroma_format[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint8 ols_dpb_bitdepth_minus8[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint8 ols_dpb_params_idx[GST_H266_MAX_TOTAL_NUM_OLSS];
+
+  guint8 timing_hrd_params_present_flag;
+  GstH266GeneralHRDParameters general_hrd_params;
+  guint8 sublayer_cpb_params_present_flag;
+  guint8 num_ols_timing_hrd_params_minus1;
+  guint8 hrd_max_tid[GST_H266_MAX_TOTAL_NUM_OLSS];
+  GstH266OLSHRDParameters ols_hrd_params[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint8 ols_timing_hrd_idx[GST_H266_MAX_TOTAL_NUM_OLSS];
+
+  /* Reserve some data for future usage. */
+  guint8 extension_flag;
+  guint8 extension_data[64];
+
+  gboolean valid;
+};
+
+/**
+ * GstH266RefPicListStruct:
+ *
+ * Structure defining the H266 reference picture list.
+ *
+ * @num_ref_entries: specifies the number of entries in the
+ *  ref_pic_list_struct(listIdx, rplsIdx) syntax structure.
+ * @ltrp_in_header_flag: specifies whether the POC LSBs of the LTRP entries
+ *  indicated in the ref_pic_list_struct(listIdx, rplsIdx) syntax structure
+ *  are present in the same syntax structure.
+ * @inter_layer_ref_pic_flag: specifies whether the i-th entry in the
+ *  ref_pic_list_struct(listIdx, rplsIdx) syntax structure is an ILRP entry.
+ * @st_ref_pic_flag: specifies whether the i-th entry in the
+ *  ref_pic_list_struct(listIdx, rplsIdx) syntax structure is an STRP entry.
+ * @abs_delta_poc_st: specifies the value of the variable
+ *  AbsDeltaPocSt[listIdx][rplsIdx][i].
+ * @strp_entry_sign_flag: specifies whether DeltaPocValSt[listIdx][rplsIdx]
+ *  is greater than or equal to 0.
+ * @rpls_poc_lsb_lt: specifies the value of the picture order count modulo
+ *  MaxPicOrderCntLsb of the picture referred to.
+ * @num_short_term_pic: the number of short term reference picture.
+ * @num_long_term_pic: the number long term reference picture.
+ * @num_inter_layer_pic: the number of inter layer reference picture.
+ * @delta_poc_val_st: the calculated DeltaPocValSt value.
+ */
+struct _GstH266RefPicListStruct {
+  guint8 num_ref_entries;
+  guint8 ltrp_in_header_flag;
+  guint8 inter_layer_ref_pic_flag[GST_H266_MAX_REF_ENTRIES];
+  guint8 st_ref_pic_flag[GST_H266_MAX_REF_ENTRIES];
+  guint8 abs_delta_poc_st[GST_H266_MAX_REF_ENTRIES];
+  guint8 strp_entry_sign_flag[GST_H266_MAX_REF_ENTRIES];
+  guint8 rpls_poc_lsb_lt[GST_H266_MAX_REF_ENTRIES];
+  guint num_short_term_pic;
+  guint num_long_term_pic;
+  guint num_inter_layer_pic;
+  gint16 delta_poc_val_st[GST_H266_MAX_REF_ENTRIES];
+};
+
+/**
+ * GstH266RefPicLists:
+ *
+ * Structure defining the H266 reference picture lists.
+ *
+ * @rpl_sps_flag: specifies whether RPL i in ref_pic_lists() is derived based
+ *  on one of the ref_pic_list_struct(listIdx, rplsIdx) syntax structures
+ *  with listIdx equal to i in the SPS.
+ * @rpl_idx: specifies the index into the list of the
+ *  ref_pic_list_struct(listIdx, rplsIdx) syntax structures.
+ * @rpl_ref_list: reference list of #GstH266RefPicListStruct.
+ * @poc_lsb_lt: specifies the value of the picture order count
+ *  modulo MaxPicOrderCntLsb.
+ * @delta_poc_msb_cycle_present_flag: specifies whether
+ *  delta_poc_msb_cycle_lt[i][j] is present.
+ * @delta_poc_msb_cycle_lt: specifies the value of the variable FullPocLt[i][j].
+ */
+struct _GstH266RefPicLists {
+  guint8 rpl_sps_flag[2];
+  guint8 rpl_idx[2];
+  GstH266RefPicListStruct rpl_ref_list[2];
+  guint16 poc_lsb_lt[2][GST_H266_MAX_REF_ENTRIES];
+  guint8  delta_poc_msb_cycle_present_flag[2][GST_H266_MAX_REF_ENTRIES];
+  guint16 delta_poc_msb_cycle_lt[2][GST_H266_MAX_REF_ENTRIES];
+};
+
+/**
+ * GstH266VUIParams:
+ *
+ * Structure defining the H266 VUI parameters.
+ *
+ * @progressive_source_flag: flag to indicate the progressive type of stream.
+ * @interlaced_source_flag: flag to indicate the interlaced type of stream.
+ * @non_packed_constraint_flag: indicate the presence of frame packing
+ *  arrangement sei message
+ * @non_projected_constraint_flag: flag to indicate the projected support.
+ * @aspect_ratio_info_present_flag: specifies whether aspect_ratio_idc is present.
+ * @aspect_ratio_constant_flag: specifies whether the ratio is constant.
+ * @aspect_ratio_idc: specifies the value of the sample aspect ratio of
+ *  the luma samples.
+ * @sar_width: indicates the horizontal size of the sample aspect ratio.
+ * @sar_height: indicates the vertical size of the sample aspect ratio.
+ * @overscan_info_present_flag: specify whether the overscan_appropriate_flag
+ *  is present.
+ * @overscan_appropriate_flag: indicates whether the cropped decoded pictures
+ *  output are suitable for display using overscan.
+ * @colour_description_present_flag: specifies whether colour_primaries,
+ *  transfer_characteristics and matrix_coefficients are present.
+ * @colour_primaries: indicates the chromaticity coordinates of the source
+ *  primaries.
+ * @transfer_characteristics: indicates the opto-electronic
+ *  transfer characteristic.
+ * @matrix_coeffs: describes the matrix coefficients used in deriving
+ *  luma and chroma signals.
+ * @full_range_flag: indicates the full range of the color.
+ * @chroma_loc_info_present_flag: specifies whether chroma_sample_loc_type_frame,
+ *  chroma_sample_loc_type_top_field and chroma_sample_loc_type_bottom_field
+ *  are present.
+ * @chroma_sample_loc_type_frame: specify the location of chroma for the frame.
+ * @chroma_sample_loc_type_top_field: specify the location of chroma for the
+ *  top field.
+ * @chroma_sample_loc_type_bottom_field: specify the location of chroma for the
+ *  bottom field.
+ * @par_n: calculated aspect ratio numerator value.
+ * @par_d: calculated aspect ratio denominator value.
+ */
+struct _GstH266VUIParams
+{
+  guint8 progressive_source_flag;
+  guint8 interlaced_source_flag;
+  guint8 non_packed_constraint_flag;
+  guint8 non_projected_constraint_flag;
+
+  guint8 aspect_ratio_info_present_flag;
+  guint8 aspect_ratio_constant_flag;
+  guint8 aspect_ratio_idc;
+
+  guint16 sar_width;
+  guint16 sar_height;
+
+  guint8 overscan_info_present_flag;
+  guint8 overscan_appropriate_flag;
+
+  guint8 colour_description_present_flag;
+  guint8 colour_primaries;
+  guint8 transfer_characteristics;
+  guint8 matrix_coeffs;
+  guint8 full_range_flag;
+
+  guint8 chroma_loc_info_present_flag;
+  guint8 chroma_sample_loc_type_frame;
+  guint8 chroma_sample_loc_type_top_field;
+  guint8 chroma_sample_loc_type_bottom_field;
+
+  /* extension_data */
+
+  /* calculated values */
+  guint par_n;
+  guint par_d;
+};
+
+/**
+ * GstH266SPSRangeExtensionParams:
+ *
+ * Structure defining the H266 SPS range extension parameters.
+ *
+ * @extended_precision_flag: specifies whether an extended dynamic range is
+ *  used for transform coefficients.
+ * @ts_residual_coding_rice_present_in_sh_flag: specifies whether
+ *  sh_ts_residual_coding_rice_idx_minus1 may be present in slice_header()
+ *  syntax structures referring to the SPS.
+ * @rrc_rice_extension_flag: specifies whether an alternative Rice parameter
+ *  derivation is used.
+ * @persistent_rice_adaptation_enabled_flag: specifies whether Rice parameter
+ *  derivation is initialized at the start of each TU using statistics
+ *  accumulated from previous TUs.
+ * @reverse_last_sig_coeff_enabled_flag: specifies whether
+ *  sh_reverse_last_sig_coeff_flag is present in slice_header() syntax
+ *  structures referring to the SPS.
+ */
+struct _GstH266SPSRangeExtensionParams {
+  guint8 extended_precision_flag;
+  guint8 ts_residual_coding_rice_present_in_sh_flag;
+  guint8 rrc_rice_extension_flag;
+  guint8 persistent_rice_adaptation_enabled_flag;
+  guint8 reverse_last_sig_coeff_enabled_flag;
+};
+
+/**
+ * GstH266SPS:
+ *
+ * Structure defining the H266 SPS.
+ *
+ * @nuh_layer_id: specifies the identifier of the layer to which a VCL NAL unit
+ *  belongs or the identifier of a layer to which a non-VCL NAL unit applies.
+ * @sps_id: provides an identifier for the SPS for reference by other
+ *  syntax elements.
+ * @vps_id: specifies the VPS referred to by this SPS.
+ * @vps: the #GstH266VPS this SPS refers to.
+ * @max_sublayers_minus1: specifies the maximum number of temporal sublayers
+ *  that could be present in each CLVS referring to the SPS.
+ * @chroma_format_idc: specifies the chroma sampling relative to the
+ *  luma sampling.
+ * @log2_ctu_size_minus5: specifies the luma coding tree block size of each CTU.
+ * @ctu_size: the calculated ctu size.
+ * @ptl_dpb_hrd_params_present_flag: specifies whether a profile_tier_level()
+ *  syntax structure and a dpb_parameters() syntax structure are present
+ *  in the SPS.
+ * @dpb: DPB parameters of #GstH266DPBParameters.
+ * @profile_tier_level: the profile tier and level in #GstH266ProfileTierLevel.
+ * @general_hrd_params: HRD parameters of #GstH266GeneralHRDParameters.
+ * @ols_hrd_params: OLS HRD parameters of #GstH266OLSHRDParameters.
+ * @gdr_enabled_flag: specifies whether GDR pictures are enabled and could
+ *  be present in the CLVS.
+ * @res_change_in_clvs_allowed_flag: specifies whether the picture spatial
+ *  resolution might change within a CLVS.
+ * @ref_pic_resampling_enabled_flag: specifies whether reference picture
+ *  resampling is enabled.
+ * @pic_width_max_in_luma_samples: specifies the maximum width, in units of
+ *  luma samples, of each decoded picture.
+ * @pic_height_max_in_luma_samples: specifies the maximum height, in units of
+ *  luma samples, of each decoded picture.
+ * @conformance_window_flag: indicates whether the conformance cropping window
+ *  offset parameters follow next in the SPS.
+ * @conf_win_left_offset: specify left offset of the cropping window that
+ *  is applied to pictures.
+ * @conf_win_right_offset: specify right offset of the cropping window that
+ *  is applied to pictures.
+ * @conf_win_top_offset: specify top offset of the cropping window that
+ *  is applied to pictures.
+ * @conf_win_bottom_offset: specify bottom offset of the cropping window that
+ *  is applied to pictures.
+ * @subpic_info_present_flag: specifies whether subpicture information is
+ *  present for the CLVS and there might be one or more than one subpicture
+ *  in each picture of the CLVS.
+ * @num_subpics_minus1: specifies the number of subpictures in each picture
+ *  in the CLVS.
+ * @independent_subpics_flag: specifies whether all subpicture boundaries in
+ *  the CLVS are treated as picture boundaries and there is no loop filtering
+ *  across the subpicture boundaries.
+ * @subpic_same_size_flag: specifies whether all subpictures in the CLVS have
+ *  the same width and height.
+ * @subpic_ctu_top_left_x: specifies horizontal position of top-left CTU of
+ *  i-th subpicture in unit of CtbSizeY.
+ * @subpic_ctu_top_left_y: specifies vertical position of top-left CTU of
+ *  i-th subpicture in unit of CtbSizeY.
+ * @subpic_width_minus1: specifies the width of the i-th subpicture in units
+ *  of CtbSizeY.
+ * @subpic_height_minus1: specifies the height of the i-th subpicture in
+ *  units of CtbSizeY.
+ * @subpic_treated_as_pic_flag: specifies whether the i-th subpicture of each
+ *  coded picture in the CLVS is treated as a picture.
+ * @loop_filter_across_subpic_enabled_flag: specifies whether in-loop filtering
+ *  operations across subpicture boundaries is enabled and might be performed
+ *  across the boundaries of the i-th subpicture.
+ * @subpic_id: specifies the subpicture ID of the i-th subpicture.
+ * @subpic_id_len_minus1: specifies the number of bits used to represent the
+ *  syntax element sps_subpic_id[i].
+ * @subpic_id_mapping_explicitly_signalled_flag: specifies whether the
+ *  subpicture ID mapping is explicitly signalled.
+ * @subpic_id_mapping_present_flag: specifies whether the subpicture ID mapping
+ *  is signalled in the SPS.
+ * @bitdepth_minus8: specifies the bit depth of the samples of the luma and
+ *  chroma arrays.
+ * @entropy_coding_sync_enabled_flag: specifies whether a specific synchronization
+ *  process for context variables is invoked before decoding the CTU.
+ * @entry_point_offsets_present_flag: specifies whether signalling for entry
+ *  point offsets for tiles or tile-specific CTU rows could be present in the
+ *  slice headers of pictures.
+ * @log2_max_pic_order_cnt_lsb_minus4: specifies the value of the variable
+ *  MaxPicOrderCntLsb.
+ * @poc_msb_cycle_flag: specifies whether the ph_poc_msb_cycle_present_flag
+ *  syntax element is present in PH syntax structures.
+ * @poc_msb_cycle_len_minus1: specifies the length, in bits, of the
+ *  ph_poc_msb_cycle_val syntax elements.
+ * @num_extra_ph_bytes: specifies the number of bytes of extra bits in the PH
+ *  syntax structure for coded pictures.
+ * @extra_ph_bit_present_flag: specifies whether the i-th extra bit is present
+ *  in PH syntax structures.
+ * @num_extra_sh_bytes: specifies the number of bytes of extra bits in the
+ *  slice headers for coded pictures.
+ * @extra_sh_bit_present_flag: specifies whether the i-th extra bit is present
+ *  in the slice headers of pictures.
+ * @sublayer_dpb_params_flag: used to control the presence of
+ *  dpb_max_dec_pic_buffering_minus1[i], dpb_max_num_reorder_pics[i],
+ *  and dpb_max_latency_increase_plus1[i] syntax elements in the
+ *  dpb_parameters() syntax strucure.
+ * @log2_min_luma_coding_block_size_minus2: specifies the minimum luma coding
+ *  block size.
+ * @partition_constraints_override_enabled_flag: specifies the presence of
+ *  ph_partition_constraints_override_flag in PH syntax structures.
+ * @log2_diff_min_qt_min_cb_intra_slice_luma: specifies the default difference
+ *  between the base 2 logarithm of the minimum size in luma samples of a luma
+ *  leaf block resulting from quadtree splitting of a CTU and the base 2
+ *  logarithm of the minimum coding block size in luma samples.
+ * @max_mtt_hierarchy_depth_intra_slice_luma: specifies the default maximum
+ *  hierarchy depth for coding units resulting from multi-type tree splitting
+ *  of a quadtree leaf in slices with sh_slice_type equal to 2(I).
+ * @log2_diff_max_bt_min_qt_intra_slice_luma: specifies the default difference
+ *  between the base 2 logarithm of the maximum size in luma samples of a luma
+ *  coding block that can be split using a binary split and the base 2 logarithm
+ *  of the minimum size in luma samples of a luma leaf block resulting from
+ *  quadtree splitting.
+ * @log2_diff_max_tt_min_qt_intra_slice_luma: specifies the default difference
+ *  between the base 2 logarithm of the maximum size in luma samples of a luma
+ *  coding block that can be split using a ternary split and the base 2
+ *  logarithm of the minimum size in luma samples of a luma leaf block resulting
+ *  from quadtree splitting.
+ * @qtbtt_dual_tree_intra_flag: specifies whether each CTU is split into coding
+ *  units with 64x64 luma samples using an implicit quadtree split, and these
+ *  coding units are the root of two separate coding_tree syntax structure for
+ *  luma and chroma.
+ * @log2_diff_min_qt_min_cb_intra_slice_chroma: specifies the default difference
+ *  between the base 2 logarithm of the minimum size in luma samples of a chroma
+ *  leaf block resulting from quadtree splitting of a chroma CTU and the base 2
+ *  logarithm of the minimum coding block size in luma samples for chroma CUs
+ *  in slices with sh_slice_type equal to 2(I).
+ * @max_mtt_hierarchy_depth_intra_slice_chroma: specifies the default maximum
+ *  hierarchy depth for chroma coding units resulting from multi-type tree
+ *  splitting of a chroma quadtree leaf in slices with sh_slice_type equal to 2(I).
+ * @log2_diff_max_bt_min_qt_intra_slice_chroma: specifies the default difference
+ *  between the base 2 logarithm of the maximum size in luma samples of a chroma
+ *  coding block that can be split using a binary split and the base 2 logarithm
+ *  of the minimum size in luma samples of a chroma leaf block resulting from
+ *  quadtree splitting of a chroma CTU in slices with sh_slice_type equal to 2(I).
+ * @log2_diff_max_tt_min_qt_intra_slice_chroma: specifies the default difference
+ *  between the base 2 logarithm of the maximum size in luma samples of a chroma
+ *  coding block that can be split using a ternary split and the base 2 logarithm
+ *  of the minimum size in luma samples of a chroma leaf block resulting from
+ *  quadtree splitting of a chroma CTU in slices with sh_slice_type equal to 2(I).
+ * @log2_diff_min_qt_min_cb_inter_slice: specifies the default difference between
+ *  the base 2 logarithm of the minimum size in luma samples of a luma leaf block
+ *  resulting from quadtree splitting of a CTU and the base 2 logarithm of the
+ *  minimum luma coding block size in luma samples for luma CUs in slices with
+ *  sh_slice_type equal to 0(B) or 1(P).
+ * @max_mtt_hierarchy_depth_inter_slice: specifies the default maximum hierarchy
+ *  depth for coding units resulting from multi-type tree splitting of a quadtree
+ *  leaf in slices with sh_slice_type equal to 0 (B) or 1 (P).
+ * @log2_diff_max_bt_min_qt_inter_slice: specifies the default difference between
+ *  the base 2 logarithm of the maximum size in luma samples of a luma coding
+ *  block that can be split using a binary split and the base 2 logarithm of the
+ *  minimum size in luma samples of a luma leaf block resulting from quadtree
+ *  splitting of a CTU in slices with sh_slice_type equal to 0(B) or 1(P).
+ * @log2_diff_max_tt_min_qt_inter_slice: specifies the default difference between
+ *  the base 2 logarithm of the maximum size in luma samples of a luma coding
+ *  block that can be split using a ternary split and the base 2 logarithm of
+ *  the minimum size in luma samples of a luma leaf block resulting from quadtree
+ *  splitting of a CTU in slices with sh_slice_type equal to 0(B) or 1(P).
+ * @max_luma_transform_size_64_flag: specifies whether the maximum transform
+ *  size in luma samples is equal to 64.
+ * @transform_skip_enabled_flag: specifies whether transform_skip_flag could be
+ *  present in the transform unit syntax.
+ * @log2_transform_skip_max_size_minus2: specifies the maximum block size used
+ *  for transform skip.
+ * @bdpcm_enabled_flag: specifies whether intra_bdpcm_luma_flag and
+ *  intra_bdpcm_chroma_flag could be present in the coding unit syntax for
+ *  intra coding units.
+ * @mts_enabled_flag: specifies whether sps_explicit_mts_intra_enabled_flag
+ *  and sps_explicit_mts_inter_enabled_flag are present in the SPS.
+ * @explicit_mts_intra_enabled_flag: specifies whether mts_idx could be present
+ *  in the intra coding unit syntax of the CLVS.
+ * @explicit_mts_inter_enabled_flag: specifies whether mts_idx could be present
+ *  in the inter coding unit syntax of the CLVS.
+ * @lfnst_enabled_flag: specifies whether lfnst_idx could be present in intra
+ *  coding unit syntax.
+ * @joint_cbcr_enabled_flag: specifies whether the joint coding of chroma
+ *  residuals is enabled for the CLVS.
+ * @same_qp_table_for_chroma_flag: specifies whether only one chroma QP mapping
+ *  table is signalled and this table applies to Cb and Cr residuals and
+ *  additionally to joint Cb-Cr residuals.
+ * @qp_table_start_minus26: specifies the starting luma and chroma QP used to
+ *  describe the i-th chroma QP mapping table.
+ * @num_points_in_qp_table_minus1: specifies the number of points used to
+ *  describe the i-th chroma QP mapping table.
+ * @delta_qp_in_val_minus1: specifies a delta value used to derive the input
+ *  coordinate of the j-th pivot point of the i-th chroma QP mapping table.
+ * @delta_qp_diff_val: specifies a delta value used to derive the output
+ *  coordinate of the j-th pivot point of the i-th chroma QP mapping table.
+ * @sao_enabled_flag: specifies whether SAO is enabled for the CLVS.
+ * @alf_enabled_flag: specifies whether ALF is enabled for the CLVS.
+ * @ccalf_enabled_flag: specifies whether CCALF is enabled for the CLVS.
+ * @lmcs_enabled_flag: specifies whether LMCS is enabled for the CLVS.
+ * @weighted_pred_flag: specifies whether weighted prediction might be applied
+ *  to P slices referring to the SPS.
+ * @weighted_bipred_flag: specifies whether explicit weighted prediction might
+ *  be applied to B slices referring to the SPS.
+ * @guint8 long_term_ref_pics_flag: specifies whether no LTRP is used for inter
+ *  prediction of any coded picture in the CLVS.
+ * @inter_layer_prediction_enabled_flag: specifies whether inter-layer prediction
+ *  is enabled for the CLVS and ILRPs might be used for inter prediction of one
+ *  or more coded pictures in the CLVS.
+ * @idr_rpl_present_flag: specifies whether RPL syntax elements could be present
+ *  in slice headers of slices with nal_unit_type equal to IDR_N_LP or IDR_W_RADL.
+ * @rpl1_same_as_rpl0_flag: specifies whether the syntax element
+ *  sps_num_ref_pic_lists[1] and the syntax structure ref_pic_list_struct(1,
+    rplsIdx) are present.
+ * @num_ref_pic_lists: specifies the number of the ref_pic_list_struct(listIdx,
+ *  rplsIdx) syntax structures with listIdx equal to i included in the SPS.
+ * @ref_pic_list_struct: the reference list of #GstH266RefPicListStruct.
+ * @ref_wraparound_enabled_flag: specifies whether horizontal wrap-around motion
+ *  compensation is enabled for the CLVS.
+ * @temporal_mvp_enabled_flag: specifies whether temporal motion vector
+ *  predictors are enabled for the CLVS.
+ * @sbtmvp_enabled_flag: specifies whether subblock-based temporal motion vector
+ *  predictors are enabled and might be used in decoding of pictures with all
+ *  slices having sh_slice_type not equal to I in the CLVS.
+ * @amvr_enabled_flag: specifies whether adaptive motion vector difference
+ *  resolution is enabled for the CVLS.
+ * @bdof_enabled_flag: specifies whether the bi-directional optical flow inter
+ *  prediction is enabled for the CLVS.
+ * @bdof_control_present_in_ph_flag: specifies whether ph_bdof_disabled_flag
+ *  could be present in PH syntax structures referring to the SPS.
+ * @smvd_enabled_flag: specifies whether symmetric motion vector difference
+ *  is enabled for the CLVS.
+ * @dmvr_enabled_flag: specifies whether decoder motion vector refinement based
+ *  inter bi-prediction is enabled for the CLVS.
+ * @dmvr_control_present_in_ph_flag: specifies whether ph_dmvr_disabled_flag
+ *  could be present in PH syntax structures referring to the SPS.
+ * @mmvd_enabled_flag: specifies whether merge mode with motion vector
+ *  difference is enabled for the CLVS.
+ * @mmvd_fullpel_only_enabled_flag: specifies whether the merge mode with motion
+ *  vector difference using only integer sample precision is enabled for the CLVS.
+ * @six_minus_max_num_merge_cand: specifies the maximum number of merging motion
+ *  vector prediction (MVP) candidates supported in the SPS.
+ * @sbt_enabled_flag: specifies whether subblock transform for inter-predicted
+ *  CUs is enabled for the CLVS.
+ * @affine_enabled_flag: specifies whether the affine model based motion
+ *  compensation is enabled for the CLVS.
+ * @five_minus_max_num_subblock_merge_cand: specifies the maximum number of
+ *  subblock-based merging motion vector prediction candidates supported.
+ * @sps_6param_affine_enabled_flag: specifies whether the 6-parameter affine
+ *  model based motion compensation is enabled for the CLVS.
+ * @affine_amvr_enabled_flag: specifies whether adaptive motion vector
+ *  difference resolution is enabled for the CLVS.
+ * @affine_prof_enabled_flag: specifies whether the affine motion compensation
+ *  refined with optical flow is enabled for the CLVS.
+ * @prof_control_present_in_ph_flag: specifies whether ph_prof_disabled_flag
+ *  could be present in PH syntax structures.
+ * bcw_enabled_flag: specifies whether bi-prediction with CU weights is enabled
+ *  for the CLVS.
+ * @ciip_enabled_flag: specifies whether ciip_flag could be present in the
+ *  coding unit syntax for inter coding units.
+ * @gpm_enabled_flag: specifies whether the geometric partition based motion
+ *  compensation is enabled for the CLVS.
+ * @max_num_merge_cand_minus_max_num_gpm_cand: specifies the maximum number of
+ *  geometric partitioning merge mode candidates supported in the SPS.
+ * @log2_parallel_merge_level_minus2: specifies the value of the variable
+ *  Log2ParMrgLevel.
+ * @isp_enabled_flag: specifies whether intra prediction with subpartitions is
+ *  enabled for the CLVS.
+ * @mrl_enabled_flag: specifies whether intra prediction with multiple reference
+ *  lines is enabled for the CLVS.
+ * @mip_enabled_flag: specifies whether the matrix-based intra prediction is
+ *  enabled for the CLVS.
+ * @cclm_enabled_flag: specifies whether the cross-component linear model intra
+ *  prediction from luma component to chroma component is enabled for the CLVS.
+ * @chroma_horizontal_collocated_flag: specifies whether prediction processes
+ *  operate in a manner designed for chroma sample positions that are not
+ *  horizontally shifted relative to corresponding luma sample positions.
+ * @chroma_vertical_collocated_flag: specifies whether prediction processes
+ *  operate in a manner designed for chroma sample positions that are not
+ *  vertically shifted relative to corresponding luma sample positions.
+ * @palette_enabled_flag: specifies whether the palette prediction mode is
+ *  enabled for the CLVS.
+ * @act_enabled_flag: specifies whether the adaptive colour transform is enabled
+ *  for the CLVS.
+ * @min_qp_prime_ts: specifies whether minimum allowed quantization parameter
+ *  for transform skip mode.
+ * @ibc_enabled_flag: specifies whether the IBC prediction mode is enabled for
+ *  the CLVS.
+ * @six_minus_max_num_ibc_merge_cand: specifies the maximum number of IBC
+ *  merging block vector prediction (BVP) candidates.
+ * @ladf_enabled_flag: specifies whether sps_num_ladf_intervals_minus2,
+ *  sps_ladf_lowest_interval_qp_offset, sps_ladf_qp_offset[i], and
+ *  sps_ladf_delta_threshold_minus1[i] are present in the SPS.
+ * @num_ladf_intervals_minus2: specifies the number of
+ *  sps_ladf_delta_threshold_minus1[i] and sps_ladf_qp_offset[i] syntax
+ *  elements that are present in the SPS.
+ * @ladf_lowest_interval_qp_offset: specifies the offset used to derive the
+ *  variable qP.
+ * @ladf_qp_offset: specifies the offset array used to derive the variable qP.
+ * @ladf_delta_threshold_minus1: is used to compute the values of
+ *  SpsLadfIntervalLowerBound[i].
+ * @explicit_scaling_list_enabled_flag: specifies whether the use of an explicit
+ *  scaling list is enabled for the CLVS.
+ * @scaling_matrix_for_lfnst_disabled_flag: specifies whether scaling matrices
+ *  are disabled for blocks coded with LFNST for the CLVS.
+ * @scaling_matrix_for_alternative_colour_space_disabled_flag: specifies whether
+ *  scaling matrices are disabled and not applied to blocks of a coding unit.
+ * @scaling_matrix_designated_colour_space_flag: specifies whether the colour
+ *  space of the scaling matrices is the colour space that does not use a colour
+ *  space conversion for the decoded residuals.
+ * @dep_quant_enabled_flag: specifies whether dependent quantization is enabled
+ *  for the CLVS.
+ * @sign_data_hiding_enabled_flag: specifies whether sign bit hiding is enabled
+ *  for the CLVS.
+ * @virtual_boundaries_enabled_flag: specifies whether disabling in-loop
+ *  filtering across virtual boundaries is enabled for the CLVS.
+ * @virtual_boundaries_present_flag: specifies whether information of virtual
+ *  boundaries is signalled in the SPS.
+ * @num_ver_virtual_boundaries: specifies the number of
+ *  sps_virtual_boundary_pos_x_minus1[i] syntax elements.
+ * @virtual_boundary_pos_x_minus1: specifies the location of the i-th vertical
+ *  virtual boundary in units of luma samples divided by 8.
+ * @num_hor_virtual_boundaries: specifies the number of
+ *  sps_virtual_boundary_pos_y_minus1[i] syntax elements.
+ * @virtual_boundary_pos_y_minus1: specifies the location of the i-th horizontal
+ *  virtual boundary in units of luma samples divided by 8.
+ * @timing_hrd_params_present_flag: specifies whether the SPS contains a
+ *  general_timing_hrd_parameters() syntax structure and an
+ *  ols_timing_hrd_parameters() syntax structure.
+ * @sublayer_cpb_params_present_flag: specifies whether the
+ *  ols_timing_hrd_parameters() syntax structure in the SPS includes HRD
+ *  parameters for sublayer representations.
+ * @field_seq_flag: indicates whether the CLVS conveys pictures that
+ *  represent fields.
+ * @vui_parameters_present_flag: specifies whether the syntax structure
+ *  vui_payload() is present in the SPS RBSP syntax structure.
+ * @vui_payload_size_minus1: specifies the number of RBSP bytes in the
+ *  vui_payload() syntax structure.
+ * @vui_params: VUI parameters of #GstH266VUIParams.
+ * @extension_flag: specifies whether the syntax elements
+ *  sps_range_extension_flag and sps_extension_7bits are present.
+ * @range_extension_flag: specifies whether the sps_range_extension() syntax
+ *  structure is present.
+ * @extension_7_flags: specifies whether no sps_extension_data_flag syntax
+ *  elements are present.
+ * @range_params: range parameters of #GstH266SPSRangeExtensionParams.
+ * @max_width: the calculated max width of the picture.
+ * @max_height: the calculated max height of the picture.
+ * @crop_rect_width: the cropped width of the picture.
+ * @crop_rect_height: the cropped height of the picture.
+ * @crop_rect_x: the x offset of the cropped window.
+ * @crop_rect_y: the y offset of the cropped window.
+ * @fps_num: the calculated FPS numerator.
+ * @fps_den: the calculated FPS denominator.
+ * @valid: whether the SPS is valid.
+ */
+struct _GstH266SPS
+{
+  guint8 nuh_layer_id;
+  guint8 sps_id;
+  guint8 vps_id;
+
+  GstH266VPS *vps;
+
+  guint8 max_sublayers_minus1;
+  guint8 chroma_format_idc;
+  guint8 log2_ctu_size_minus5;
+  guint ctu_size;
+
+  guint8 ptl_dpb_hrd_params_present_flag;
+  GstH266DPBParameters dpb;
+  GstH266ProfileTierLevel profile_tier_level;
+  GstH266GeneralHRDParameters general_hrd_params;
+  GstH266OLSHRDParameters ols_hrd_params;
+
+  guint8 gdr_enabled_flag;
+  guint8 res_change_in_clvs_allowed_flag;
+  guint8 ref_pic_resampling_enabled_flag;
+
+  guint16 pic_width_max_in_luma_samples;
+  guint16 pic_height_max_in_luma_samples;
+
+  guint8 conformance_window_flag;
+  guint16 conf_win_left_offset;
+  guint16 conf_win_right_offset;
+  guint16 conf_win_top_offset;
+  guint16 conf_win_bottom_offset;
+
+  guint8 subpic_info_present_flag;
+  guint16 num_subpics_minus1;
+  guint8 independent_subpics_flag;
+  guint8 subpic_same_size_flag;
+  guint16 subpic_ctu_top_left_x[GST_H266_MAX_SLICES_PER_AU];
+  guint16 subpic_ctu_top_left_y[GST_H266_MAX_SLICES_PER_AU];
+  guint16 subpic_width_minus1[GST_H266_MAX_SLICES_PER_AU];
+  guint16 subpic_height_minus1[GST_H266_MAX_SLICES_PER_AU];
+  guint8 subpic_treated_as_pic_flag[GST_H266_MAX_SLICES_PER_AU];
+  guint8 loop_filter_across_subpic_enabled_flag[GST_H266_MAX_SLICES_PER_AU];
+  guint32 subpic_id[GST_H266_MAX_SLICES_PER_AU];
+  guint8 subpic_id_len_minus1;
+  guint8 subpic_id_mapping_explicitly_signalled_flag;
+  guint8 subpic_id_mapping_present_flag;
+
+  guint8 bitdepth_minus8;
+  guint8 entropy_coding_sync_enabled_flag;
+  guint8 entry_point_offsets_present_flag;
+
+  guint8 log2_max_pic_order_cnt_lsb_minus4;
+  guint8 poc_msb_cycle_flag;
+  guint8 poc_msb_cycle_len_minus1;
+
+  guint8 num_extra_ph_bytes;
+  guint8 extra_ph_bit_present_flag[16];
+  guint8 num_extra_sh_bytes;
+  guint8 extra_sh_bit_present_flag[16];
+
+  guint8 sublayer_dpb_params_flag;
+
+  guint8 log2_min_luma_coding_block_size_minus2;
+  guint8 partition_constraints_override_enabled_flag;
+  guint8 log2_diff_min_qt_min_cb_intra_slice_luma;
+  guint8 max_mtt_hierarchy_depth_intra_slice_luma;
+  guint8 log2_diff_max_bt_min_qt_intra_slice_luma;
+  guint8 log2_diff_max_tt_min_qt_intra_slice_luma;
+
+  guint8 qtbtt_dual_tree_intra_flag;
+  guint8 log2_diff_min_qt_min_cb_intra_slice_chroma;
+  guint8 max_mtt_hierarchy_depth_intra_slice_chroma;
+  guint8 log2_diff_max_bt_min_qt_intra_slice_chroma;
+  guint8 log2_diff_max_tt_min_qt_intra_slice_chroma;
+
+  guint8 log2_diff_min_qt_min_cb_inter_slice;
+  guint8 max_mtt_hierarchy_depth_inter_slice;
+  guint8 log2_diff_max_bt_min_qt_inter_slice;
+  guint8 log2_diff_max_tt_min_qt_inter_slice;
+
+  guint8 max_luma_transform_size_64_flag;
+
+  guint8 transform_skip_enabled_flag;
+  guint8 log2_transform_skip_max_size_minus2;
+  guint8 bdpcm_enabled_flag;
+
+  guint8 mts_enabled_flag;
+  guint8 explicit_mts_intra_enabled_flag;
+  guint8 explicit_mts_inter_enabled_flag;
+
+  guint8 lfnst_enabled_flag;
+
+  guint8 joint_cbcr_enabled_flag;
+  guint8 same_qp_table_for_chroma_flag;
+
+  gint8 qp_table_start_minus26[GST_H266_MAX_SAMPLE_ARRAYS];
+  guint8 num_points_in_qp_table_minus1[GST_H266_MAX_SAMPLE_ARRAYS];
+  guint8 delta_qp_in_val_minus1[GST_H266_MAX_SAMPLE_ARRAYS][GST_H266_MAX_POINTS_IN_QP_TABLE];
+  guint8 delta_qp_diff_val[GST_H266_MAX_SAMPLE_ARRAYS][GST_H266_MAX_POINTS_IN_QP_TABLE];
+
+  guint8 sao_enabled_flag;
+  guint8 alf_enabled_flag;
+  guint8 ccalf_enabled_flag;
+  guint8 lmcs_enabled_flag;
+  guint8 weighted_pred_flag;
+  guint8 weighted_bipred_flag;
+
+  guint8 long_term_ref_pics_flag;
+  guint8 inter_layer_prediction_enabled_flag;
+  guint8 idr_rpl_present_flag;
+  guint8 rpl1_same_as_rpl0_flag;
+  guint8 num_ref_pic_lists[2];
+  GstH266RefPicListStruct ref_pic_list_struct[2][GST_H266_MAX_REF_PIC_LISTS];
+
+  guint8 ref_wraparound_enabled_flag;
+  guint8 temporal_mvp_enabled_flag;
+  guint8 sbtmvp_enabled_flag;
+  guint8 amvr_enabled_flag;
+  guint8 bdof_enabled_flag;
+  guint8 bdof_control_present_in_ph_flag;
+  guint8 smvd_enabled_flag;
+  guint8 dmvr_enabled_flag;
+  guint8 dmvr_control_present_in_ph_flag;
+  guint8 mmvd_enabled_flag;
+  guint8 mmvd_fullpel_only_enabled_flag;
+  guint8 six_minus_max_num_merge_cand;
+  guint8 sbt_enabled_flag;
+  guint8 affine_enabled_flag;
+  guint8 five_minus_max_num_subblock_merge_cand;
+  guint8 sps_6param_affine_enabled_flag;
+  guint8 affine_amvr_enabled_flag;
+  guint8 affine_prof_enabled_flag;
+  guint8 prof_control_present_in_ph_flag;
+  guint8 bcw_enabled_flag;
+  guint8 ciip_enabled_flag;
+  guint8 gpm_enabled_flag;
+  guint8 max_num_merge_cand_minus_max_num_gpm_cand;
+  guint8 log2_parallel_merge_level_minus2;
+  guint8 isp_enabled_flag;
+  guint8 mrl_enabled_flag;
+  guint8 mip_enabled_flag;
+  guint8 cclm_enabled_flag;
+  guint8 chroma_horizontal_collocated_flag;
+  guint8 chroma_vertical_collocated_flag;
+  guint8 palette_enabled_flag;
+  guint8 act_enabled_flag;
+  guint8 min_qp_prime_ts;
+  guint8 ibc_enabled_flag;
+  guint8 six_minus_max_num_ibc_merge_cand;
+  guint8 ladf_enabled_flag;
+  guint8 num_ladf_intervals_minus2;
+  gint8 ladf_lowest_interval_qp_offset;
+  gint8 ladf_qp_offset[4];
+  guint16 ladf_delta_threshold_minus1[4];
+
+  guint8 explicit_scaling_list_enabled_flag;
+  guint8 scaling_matrix_for_lfnst_disabled_flag;
+  guint8 scaling_matrix_for_alternative_colour_space_disabled_flag;
+  guint8 scaling_matrix_designated_colour_space_flag;
+  guint8 dep_quant_enabled_flag;
+  guint8 sign_data_hiding_enabled_flag;
+
+  guint8 virtual_boundaries_enabled_flag;
+  guint8 virtual_boundaries_present_flag;
+  guint32 num_ver_virtual_boundaries;
+  guint16 virtual_boundary_pos_x_minus1[3];
+  guint32 num_hor_virtual_boundaries;
+  guint16 virtual_boundary_pos_y_minus1[3];
+
+  guint8 timing_hrd_params_present_flag;
+  guint8 sublayer_cpb_params_present_flag;
+
+  guint8 field_seq_flag;
+  guint8 vui_parameters_present_flag;
+  guint16 vui_payload_size_minus1;
+  GstH266VUIParams vui_params;
+
+  guint8 extension_flag;
+  guint8 range_extension_flag;
+  guint8 extension_7_flags[7];
+  GstH266SPSRangeExtensionParams range_params;
+
+  /* calculated values */
+  gint max_width, max_height;
+  gint crop_rect_width, crop_rect_height;
+  gint crop_rect_x, crop_rect_y;
+  gint fps_num, fps_den;
+  gint chroma_qp_table[GST_H266_MAX_SAMPLE_ARRAYS][GST_H266_MAX_POINTS_IN_QP_TABLE];
+  gboolean valid;
+};
+
+/**
+ * GstH266PPS:
+ *
+ * Structure defining the H266 PPS.
+ *
+ * @pps_id: provides an identifier for the PPS for reference by other
+ *  syntax elements.
+ * @sps_id: specifies the SPS referred to by this PPS.
+ * @sps: the #GstH266SPS this PPS refers to.
+ * @mixed_nalu_types_in_pic_flag: specifies whether each picture referring to
+ *  the PPS has more than one VCL NAL unit and the VCL NAL units do not have
+ *  the same value of nal_unit_type.
+ * @pic_width_in_luma_samples: specifies the width of each decoded picture
+ *  referring to the PPS in units of luma samples.
+ * @pic_height_in_luma_samples: specifies the height of each decoded picture
+ *  referring to the PPS in units of luma samples.
+ * @conformance_window_flag: specifies whether the conformance cropping window
+ *  offset parameters follow next in the PPS.
+ * @conf_win_left_offset: specify left offset of the cropping window that
+ *  is applied to pictures.
+ * @conf_win_right_offset: specify right offset of the cropping window that
+ *  is applied to pictures.
+ * @conf_win_top_offset: specify top offset of the cropping window that
+ *  is applied to pictures.
+ * @conf_win_bottom_offset: specify bottom offset of the cropping window that
+ *  is applied to pictures.
+ * @scaling_window_explicit_signalling_flag: specifies whether the scaling
+ *  window offset parameters are present in the PPS.
+ * @scaling_win_left_offset: specify the left offsets that are applied to the
+ *  picture size for scaling ratio calculation.
+ * @scaling_win_right_offset: specify the right offsets that are applied to the
+ *  picture size for scaling ratio calculation.
+ * @scaling_win_top_offset: specify the top offsets that are applied to the
+ *  picture size for scaling ratio calculation.
+ * @scaling_win_bottom_offset: specify the bottom offsets that are applied to
+ *  the picture size for scaling ratio calculation.
+ * @output_flag_present_flag: specifies whether the ph_pic_output_flag syntax
+ *  element could be present in PH syntax structures referring to the PPS.
+ * @no_pic_partition_flag: specifies whether no picture partitioning is applied
+ *  to each picture referring to the PPS.
+ * @subpic_id_mapping_present_flag: specifies whether the subpicture ID mapping
+ *  is signalled in the PPS.
+ * @num_subpics_minus1: shall be equal to sps_num_subpics_minus1.
+ * @subpic_id_len_minus1: shall be equal to sps_subpic_id_len_minus1.
+ * @subpic_id: specifies the subpicture ID of the i-th subpicture.
+ * @log2_ctu_size_minus5: specifies the luma coding tree block size of each CTU.
+ * @num_exp_tile_columns_minus1: specifies the number of explicitly provided
+ *  tile column widths.
+ * @num_exp_tile_rows_minus1: specifies the number of explicitly provided tile
+ *  row heights.
+ * @tile_column_width_minus1: specifies the width of the i-th tile column in
+ *  units of CTBs.
+ * @tile_row_height_minus1: specifies the height of the i-th tile row in units
+ *  of CTBs.
+ * @loop_filter_across_tiles_enabled_flag: specifies whether in-loop filtering
+ *  operations across tile boundaries are enabled for pictures.
+ * @rect_slice_flag: specifies whether the raster-san slice mode is in use for
+ *  each picture referring to the PPS.
+ * @single_slice_per_subpic_flag: specifies whether each subpicture consists of
+ *  one and only one rectangular slice.
+ * @num_slices_in_pic_minus1: specifies the number of rectangular slices in
+ *  each picture.
+ * @tile_idx_delta_present_flag: specifies whether all pictures are partitioned
+ *  into rectangular slice rows and rectangular slice columns in slice raster
+ *  order.
+ * @slice_width_in_tiles_minus1: specifies the width of the i-th rectangular
+ *  slice in units of tile columns.
+ * @slice_height_in_tiles_minus1: specifies the height of the i-th rectangular
+ *  slice in units of tile rows.
+ * @num_exp_slices_in_tile: specifies the number of explicitly provided slice
+ *  heights for the slices in the containing the i-th slice.
+ * @exp_slice_height_in_ctus_minus1: specifies the height of the j-th rectangular
+ *  slice in the tile containing the i-th slice.
+ * @tile_idx_delta_val: specifies the difference between the tile index of the
+ *  tile containing the first CTU in the (i+1)-th rectangular slice and the tile
+ *  index of the tile containing the first CTU in the i-th rectangular slice.
+ * @loop_filter_across_slices_enabled_flag: specifies whether in-loop filtering
+ *  operations across slice boundaries are enabled.
+ * @cabac_init_present_flag: specifies whether sh_cabac_init_flag is present
+ *  in slice headers.
+ * @num_ref_idx_default_active_minus1: specifies the inferred value of the
+ *  variable NumRefIdxActive[0] for P or B slices.
+ * @rpl1_idx_present_flag: specifies whether rpl_sps_flag[1] and rpl_idx[1] are
+ *  present in the PH.
+ * @weighted_pred_flag: specifies whether weighted prediction is applied to P
+ *  slices.
+ * @weighted_bipred_flag: specifies whether explicit weighted prediction is
+ *  applied to B slices.
+ * @ref_wraparound_enabled_flag: specifies whether the horizontal wrap-around
+ *  motion compensation is enabled.
+ * @pic_width_minus_wraparound_offset: specifies the difference between the
+ *  picture width and the offset used for computing the horizontal wrap-around
+ *  position in units of MinCbSizeY luma samples.
+ * @init_qp_minus26: specifies the initial value of SliceQp Y for each slice.
+ * @cu_qp_delta_enabled_flag: specifies whether either or both of the
+ *  ph_cu_qp_delta_subdiv_intra_slice and ph_cu_qp_delta_subdiv_inter_slice
+ *  syntax elements are present in PH.
+ * @chroma_tool_offsets_present_flag: specifies whether chroma tool offsets
+ *  related syntax elements are present in the PPS.
+ * @cb_qp_offset: specify the offsets to the luma quantization parameter Qp'Y
+ *  used for deriving Qp'Cb.
+ * @cr_qp_offset: specify the offsets to the luma quantization parameter Qp'Y
+ *  used for deriving Qp'Cr.
+ * @joint_cbcr_qp_offset_present_flag: specifies whether
+ *  pps_joint_cbcr_qp_offset_value and pps_joint_cbcr_qp_offset_list[i] are
+ *  present in the PPS.
+ * @joint_cbcr_qp_offset_value: specifies the offset to the luma quantization
+ *  parameter Qp'Y used for deriving Qp'CbCr.
+ * @slice_chroma_qp_offsets_present_flag: specifies whether the sh_cb_qp_offset
+ *  and sh_cr_qp_offset syntax elements are present in slice headers.
+ * @cu_chroma_qp_offset_list_enabled_flag: specifies whether the
+ *  ph_cu_chroma_qp_offset_subdiv_intra_slice and
+ *  ph_cu_chroma_qp_offset_subdiv_inter_slice syntax elements are present in PH.
+ * @chroma_qp_offset_list_len_minus1: specifies whether number of
+ *  pps_cb_qp_offset_list[i], pps_cr_qp_offset_list[i],
+ *  and pps_joint_cbcr_qp_offset_list[i], syntax elements that are present.
+ * @cb_qp_offset_list: specify offsets used in the derivation of Qp'Cb.
+ * @cr_qp_offset_list: specify offsets used in the derivation of Qp'Cr.
+ * @joint_cbcr_qp_offset_list: specify offsets used in the derivation of Qp'CbCr.
+ * @deblocking_filter_control_present_flag: specifies whether presence of
+ *  deblocking filter control syntax elements in the PPS.
+ * @deblocking_filter_override_enabled_flag: specifies whether the deblocking
+ *  behaviour could be overridden in the picture level or slice level.
+ * @deblocking_filter_disabled_flag: specifies whether the deblocking filter is
+ *  disabled unless overridden for a picture or slice by information.
+ * @dbf_info_in_ph_flag: specifies whether deblocking filter information is
+ *  present in the PH syntax structure and not present in slice headers.
+ * @luma_beta_offset_div2: specify the default deblocking parameter offsets
+ *  for ß that are applied to the luma component.
+ * @luma_tc_offset_div2: specify the default deblocking parameter offsets for
+ *  tC (divided by 2) that are applied to the luma component.
+ * @cb_beta_offset_div2: specify the default deblocking parameter offsets for
+ *  ß and that are applied to the Cb component.
+ * @cb_tc_offset_div2: specify the default deblocking parameter offsets for tC
+    (divided by 2) that are applied to the Cb component.
+ * @cr_beta_offset_div2: specify the default deblocking parameter offsets for
+ *  ß that are applied to the Cr component.
+ * @cr_tc_offset_div2: specify the default deblocking parameter offsets for tC
+ *  (divided by 2) that are applied to the Cr component.
+ * @rpl_info_in_ph_flag: specifies whether RPL information is present in the
+ *  PH syntax structure and not present in slice headers.
+ * @sao_info_in_ph_flag: specifies whether SAO filter information could be
+ *  present in the PH syntax structure and not present in slice headers.
+ * @alf_info_in_ph_flag: specifies whether ALF information could be present in
+ *  the PH syntax structure and not present in slice headers.
+ * @wp_info_in_ph_flag: specifies whether weighted prediction information could
+ *  be present in the PH syntax structure and not present in slice headers.
+ * @qp_delta_info_in_ph_flag: specifies whether QP delta information is present
+ *  in the PH syntax structure and not present in slice headers.
+ * @picture_header_extension_present_flag: specifies whether PH extension syntax
+ *  elements are present in PH syntax structures.
+ * @slice_header_extension_present_flag: specifies whether slice header
+ *  extension syntax elements are present in the slice headers.
+ * @extension_flag: specifies whether pps_extension_data_flag syntax elements
+ *  are present.
+ * @extension_data_flag: could have any value.
+ * @width: the calculated width of the picture.
+ * @height: the calculated height of the picture.
+ * @crop_rect_width: the cropped width of the picture.
+ * @crop_rect_height: the cropped height of the picture.
+ * @crop_rect_x: the x offset of the cropped window.
+ * @crop_rect_y: the y offset of the cropped window.
+ * @pic_width_in_ctbs_y: PicWidthInCtbsY specify picture width count in CTBs.
+ * @pic_height_in_ctbs_y: PicHeightInCtbsY specify picture height count in CTBs.
+ * @pic_size_in_ctbs_y: picture size count in CTBs.
+ * @num_tile_columns: total tile number in columns.
+ * @num_tile_rows: total tile number in rows.
+ * @num_tiles_in_pic: total tile number of the picture.
+ * @tile_col_bd_val: TileColBdVal specifying the location of the i-th tile
+ *  column boundary in units of CTBs
+ * @tile_row_bd_val: TileRowBdVal specifying the location of the j-th tile row
+ *  boundary in units of CTBs.
+ * @slice_top_left_tile_idx: SliceTopLeftTileIdx specifying the tile index of
+ *  the tile containing the first CTU in the slice.
+ * @slice_top_left_ctu_x: specifying the top left CTU index in X direction.
+ * @slice_top_left_ctu_y: specifying the top left CTU index in Y direction.
+ * @slice_height_in_ctus: slice height count in CTUs.
+ * @num_slices_in_subpic: slice number in subpicture.
+ * @valid: whether this PPS is valid.
+ */
+struct _GstH266PPS
+{
+  guint8 pps_id;
+  guint8 sps_id;
+
+  GstH266SPS *sps;
+
+  guint8 mixed_nalu_types_in_pic_flag;
+  guint16 pic_width_in_luma_samples;
+  guint16 pic_height_in_luma_samples;
+
+  guint8 conformance_window_flag;
+  guint16 conf_win_left_offset;
+  guint16 conf_win_right_offset;
+  guint16 conf_win_top_offset;
+  guint16 conf_win_bottom_offset;
+
+  guint8 scaling_window_explicit_signalling_flag;
+  gint32 scaling_win_left_offset;
+  gint32 scaling_win_right_offset;
+  gint32 scaling_win_top_offset;
+  gint32 scaling_win_bottom_offset;
+
+  guint8 output_flag_present_flag;
+  guint8 no_pic_partition_flag;
+
+  guint8 subpic_id_mapping_present_flag;
+  guint32 num_subpics_minus1;
+  guint32 subpic_id_len_minus1;
+  guint16 subpic_id[GST_H266_MAX_SLICES_PER_AU];
+
+  guint8 log2_ctu_size_minus5;
+  guint8 num_exp_tile_columns_minus1;
+  guint8 num_exp_tile_rows_minus1;
+  guint16 tile_column_width_minus1[GST_H266_MAX_TILE_COLUMNS];
+  guint16 tile_row_height_minus1[GST_H266_MAX_TILE_ROWS];
+
+  guint8 loop_filter_across_tiles_enabled_flag;
+  guint8 rect_slice_flag;
+  guint8 single_slice_per_subpic_flag;
+
+  guint16 num_slices_in_pic_minus1;
+  guint8 tile_idx_delta_present_flag;
+  guint16 slice_width_in_tiles_minus1[GST_H266_MAX_SLICES_PER_AU];
+  guint16 slice_height_in_tiles_minus1[GST_H266_MAX_SLICES_PER_AU];
+  guint16 num_exp_slices_in_tile[GST_H266_MAX_SLICES_PER_AU];
+  guint16 exp_slice_height_in_ctus_minus1[GST_H266_MAX_SLICES_PER_AU][GST_H266_MAX_TILE_ROWS];
+  gint16 tile_idx_delta_val[GST_H266_MAX_SLICES_PER_AU];
+
+  guint8 loop_filter_across_slices_enabled_flag;
+  guint8 cabac_init_present_flag;
+  guint8 num_ref_idx_default_active_minus1[2];
+  guint8 rpl1_idx_present_flag;
+  guint8 weighted_pred_flag;
+  guint8 weighted_bipred_flag;
+  guint8 ref_wraparound_enabled_flag;
+  guint16 pic_width_minus_wraparound_offset;
+  gint8 init_qp_minus26;
+  guint8 cu_qp_delta_enabled_flag;
+  guint8 chroma_tool_offsets_present_flag;
+  gint8 cb_qp_offset;
+  gint8 cr_qp_offset;
+  guint8 joint_cbcr_qp_offset_present_flag;
+  gint8 joint_cbcr_qp_offset_value;
+  guint8 slice_chroma_qp_offsets_present_flag;
+  guint8 cu_chroma_qp_offset_list_enabled_flag;
+  guint8 chroma_qp_offset_list_len_minus1;
+  guint8 cb_qp_offset_list[6];
+  guint8 cr_qp_offset_list[6];
+  guint8 joint_cbcr_qp_offset_list[6];
+  guint8 deblocking_filter_control_present_flag;
+  guint8 deblocking_filter_override_enabled_flag;
+  guint8 deblocking_filter_disabled_flag;
+  guint8 dbf_info_in_ph_flag;
+
+  gint8 luma_beta_offset_div2;
+  gint8 luma_tc_offset_div2;
+  gint8 cb_beta_offset_div2;
+  gint8 cb_tc_offset_div2;
+  gint8 cr_beta_offset_div2;
+  gint8 cr_tc_offset_div2;
+
+  guint8 rpl_info_in_ph_flag;
+  guint8 sao_info_in_ph_flag;
+  guint8 alf_info_in_ph_flag;
+  guint8 wp_info_in_ph_flag;
+  guint8 qp_delta_info_in_ph_flag;
+
+  guint8 picture_header_extension_present_flag;
+  guint8 slice_header_extension_present_flag;
+  guint8 extension_flag;
+  guint8 extension_data_flag;
+
+  /* extension_data */
+
+  /* calculated value */
+  gint width, height;
+  gint crop_rect_width, crop_rect_height;
+  gint crop_rect_x, crop_rect_y;
+  guint16 pic_width_in_ctbs_y, pic_height_in_ctbs_y;
+  guint16 pic_size_in_ctbs_y;
+  guint16 num_tile_columns;
+  guint16 num_tile_rows;
+  guint16 num_tiles_in_pic;
+  guint16 tile_col_bd_val[GST_H266_MAX_TILE_COLUMNS + 1];
+  guint16 tile_row_bd_val[GST_H266_MAX_TILE_ROWS + 1];
+  guint16 slice_top_left_tile_idx[GST_H266_MAX_SLICES_PER_AU];
+  guint16 slice_top_left_ctu_x[GST_H266_MAX_SLICES_PER_AU];
+  guint16 slice_top_left_ctu_y[GST_H266_MAX_SLICES_PER_AU];
+  guint16 slice_height_in_ctus[GST_H266_MAX_SLICES_PER_AU];
+  guint16 num_slices_in_subpic[GST_H266_MAX_SLICES_PER_AU];
+
+  gboolean valid;
+};
+
+/**
+ * GstH266ALF:
+ *
+ * Structure defining the H266 ALF parameters.
+ *
+ * @luma_filter_signal_flag: specifies whether a luma filter set is signalled.
+ * @chroma_filter_signal_flag: specifies whether a chroma filter is signalled.
+ * @cc_cb_filter_signal_flag: specifies whether cross-component filters for the
+ *  Cb colour component are signalled.
+ * @cc_cr_filter_signal_flag: specifies whether cross-component filters for the
+ *  Cr colour component are signalled.
+ * @luma_clip_flag: specifies whether linear adaptive loop filtering is applied
+ *  to the luma component.
+ * @luma_num_filters_signalled_minus1: specifies the number of adpative loop
+ *  filter classes for which luma coefficients can be signalled.
+ * @luma_coeff_delta_idx: specifies the indices of the signalled adaptive loop
+ *  filter luma coefficient deltas for the filter class.
+ * @luma_coeff_abs: specifies the absolute value of the j-th coefficient of
+ *  the signalled luma filter.
+ * @luma_coeff_sign: specifies the sign of the j-th luma coefficient of the
+ *  filter.
+ * @luma_clip_idx: specifies the clipping index of the clipping value to use
+ *  before multiplying by the j-th coefficient of the signalled luma filter.
+ * @chroma_clip_flag: specifies whether linear adaptive loop filtering is
+ *  applied to chroma components.
+ * @chroma_num_alt_filters_minus1: specifies the number of alternative filters
+ *  for chroma components.
+ * @chroma_coeff_abs: specifies the absolute value of the j-th chroma filter
+ *  coefficient for the alternative chroma filter with index altIdx.
+ * @chroma_coeff_sign: specifies the sign of the j-th chroma filter coefficient
+ *  for the alternative chroma filter with index altIdx.
+ * @chroma_clip_idx: specifies the clipping index of the clipping value to use
+ *  before multiplying by the j-th coefficient of the alternative chroma filter
+ *  with index altIdx.
+ * @cc_cb_filters_signalled_minus1: specifies the number of cross-component
+ *  filters for the Cb colour component.
+ * @cc_cb_mapped_coeff_abs: specifies the absolute value of the j-th mapped
+ *  coefficient of the signalled k-th cross-component filter for the Cb colour
+ *  component.
+ * @cc_cb_coeff_sign: specifies the sign of the j-th coefficient of the
+ *  signalled k-th cross-component filter for the Cb colour component.
+ * @cc_cr_filters_signalled_minus1: specifies the number of cross-component
+ *  filters for the Cr colour component.
+ * @cc_cr_mapped_coeff_abs: specifies the absolute value of the j-th mapped
+ *  coefficient of the signalled k-th cross-component filter for the Cr colour
+ *  component.
+ * @cc_cr_coeff_sign: specifies the sign of the j-th coefficient of the
+ *  signalled k-th cross-component filter for the Cr colour component.
+ */
+struct _GstH266ALF
+{
+  guint8 luma_filter_signal_flag;
+  guint8 chroma_filter_signal_flag;
+  guint8 cc_cb_filter_signal_flag;
+  guint8 cc_cr_filter_signal_flag;
+  guint8 luma_clip_flag;
+  guint8 luma_num_filters_signalled_minus1;
+  guint8 luma_coeff_delta_idx[GST_H266_NUM_ALF_FILTERS];
+  guint8 luma_coeff_abs[GST_H266_NUM_ALF_FILTERS][12];
+  guint8 luma_coeff_sign[GST_H266_NUM_ALF_FILTERS][12];
+  guint8 luma_clip_idx[GST_H266_NUM_ALF_FILTERS][12];
+  guint8 chroma_clip_flag;
+  guint8 chroma_num_alt_filters_minus1;
+  guint8 chroma_coeff_abs[8][6];
+  guint8 chroma_coeff_sign[8][6];
+  guint8 chroma_clip_idx[8][6];
+  guint8 cc_cb_filters_signalled_minus1;
+  guint8 cc_cb_mapped_coeff_abs[4][7];
+  guint8 cc_cb_coeff_sign[4][7];
+  guint8 cc_cr_filters_signalled_minus1;
+  guint8 cc_cr_mapped_coeff_abs[4][7];
+  guint8 cc_cr_coeff_sign[4][7];
+};
+
+/**
+ * GstH266LMCS:
+ *
+ * Structure defining the H266 LMCS parameters.
+ *
+ * @min_bin_idx: minimum bin index used in the luma mapping with chroma scaling
+ *  construction process.
+ * @delta_max_bin_idx: specifies the delta value between 15 and the maximum bin
+ *  index LmcsMaxBinIdx used in the luma mapping with chroma scaling construction
+ *  process.
+ * @delta_cw_prec_minus1: specifies the number of bits used for the
+ *  representation of the syntax lmcs_delta_abs_cw[i].
+ * @delta_abs_cw: specifies the absolute delta codeword value for the ith bin.
+ * @delta_sign_cw_flag: specifies the sign of the variable lmcsDeltaCW[i].
+ * @delta_abs_crs: specifies the absolute codeword value of the variable
+ *  lmcsDeltaCrs.
+ * @delta_sign_crs_flag: specifies the sign of the variable lmcsDeltaCrs.
+ */
+struct _GstH266LMCS
+{
+  guint8 min_bin_idx;
+  guint8 delta_max_bin_idx;
+  guint8 delta_cw_prec_minus1;
+  guint8 delta_abs_cw[16];
+  guint8 delta_sign_cw_flag[16];
+  guint8 delta_abs_crs;
+  guint8 delta_sign_crs_flag;
+};
+
+/**
+ * GstH266ScalingList:
+ *
+ * Structure defining the H266 scaling list parameters.
+ *
+ * @copy_mode_flag: specifies whether the values of the scaling list are the
+ *  same as the values of a reference scaling list.
+ * @pred_mode_flag: specifies whether the values of the scaling list can be
+ *  predicted from a reference scaling list.
+ * @pred_id_delta: specifies the reference scaling list used to derive the
+ *  predicted scaling matrix scalingMatrixPred.
+ * @dc_coef: used to derive the value of the variable ScalingMatrixDcRec.
+ * @delta_coef: specifies the difference between the current matrix coefficient
+ *  ScalingList.
+ * @scaling_list_DC: the scaling list DC coef.
+ * @scaling_list: the calculated scaling list coefs.
+ */
+struct _GstH266ScalingList
+{
+  guint8 copy_mode_flag[28];
+  guint8 pred_mode_flag[28];
+  guint8 pred_id_delta[28];
+  gint8 dc_coef[14];
+  gint8 delta_coef[28][64];
+  guint8 scaling_list_DC[14];
+  guint8 scaling_list[28][64];
+};
+
+/**
+ * GstH266APS:
+ *
+ * Structure defining the H266 Adaptation Parameter Set.
+ *
+ * @params_type: specifies the type of APS parameters carried in the APS as
+ *  specified in Table 6.
+ * @aps_id: provides an identifier for the APS for reference by other syntax
+ *  elements.
+ * @chroma_present_flag: specifies whether the APS NAL unit could include
+ *  chroma related syntax elements.
+ * @alf: ALF parameters of #GstH266ALF when params_type is GST_H266_ALF_APS.
+ * @lmcs: LMCS parameters of #GstH266LMCS when params_type is GST_H266_LMCS_APS.
+ * @sl: scaling list parameters of #GstH266ScalingList when params_type is
+ *  GST_H266_SCALING_APS.
+ * @extension_flag: specifies whether aps_extension_data_flag syntax elements
+ *  are present.
+ * @extension_data_flag: could have any value and do not affect the decoding
+ *  process now.
+ * @valid: whether this APS is valid.
+ */
+struct _GstH266APS
+{
+  GstH266APSType params_type;
+  guint8 aps_id;
+  guint8 chroma_present_flag;
+
+  union {
+    GstH266ALF alf;
+    GstH266LMCS lmcs;
+    GstH266ScalingList sl;
+  };
+
+  guint8 extension_flag;
+  guint8 extension_data_flag;
+  gboolean valid;
+};
+
+/**
+ * GstH266PredWeightTable:
+ *
+ * Structure defining the H266 weight table parameters.
+ *
+ * @luma_log2_weight_denom: the base 2 logarithm of the denominator for all
+ *  luma weighting factors.
+ * @delta_chroma_log2_weight_denom: the difference of the base 2 logarithm of
+ *  the denominator for all chroma weighting factors.
+ * @num_l0_weights: specifies the number of weights signalled for entries in
+ *  RPL 0 when pps_wp_info_in_ph_flag is equal to 1.
+ * @luma_weight_l0_flag: specifies whether weighting factors for the luma
+ *  component of list 0 prediction using RefPicList[0][i] are present.
+ * @chroma_weight_l0_flag: specifies whether weighting factors for the chroma
+ *  prediction values of list 0 prediction using RefPicList[0][i] are present.
+ * @delta_luma_weight_l0: the difference of the weighting factor applied to the
+ *  luma prediction value for list 0 prediction using RefPicList[0][i].
+ * @luma_offset_l0: the additive offset applied to the luma prediction value
+ *  for list 0 prediction using RefPicList[0][i].
+ * @delta_chroma_weight_l0: the difference of the weighting factor applied to
+ *  the chroma prediction values for list 0 prediction.
+ * @delta_chroma_offset_l0: the difference of the additive offset applied to
+ *  the chroma prediction values for list 0 prediction.
+ * @num_l1_weights: specifies the number of weights signalled for entries in
+ *  RPL 1.
+ * @luma_weight_l1_flag: specifies whether weighting factors for the luma
+ *  component of list 1 prediction using RefPicList[1][i] are present.
+ * @chroma_weight_l1_flag: specifies whether weighting factors for the chroma
+ *  prediction values of list 1 prediction using RefPicList[1][i] are present.
+ * @delta_luma_weight_l1: the difference of the weighting factor applied to the
+ *  luma prediction value for list 1 prediction using RefPicList[1][i].
+ * @luma_offset_l1: the additive offset applied to the luma prediction value
+ *  for list 1 prediction using RefPicList[1][i].
+ * @delta_chroma_weight_l1: the difference of the weighting factor applied to
+ *  the chroma prediction values for list 1 prediction.
+ * @delta_chroma_offset_l1: the difference of the additive offset applied to
+ *  the chroma prediction values for list 1 prediction.
+ */
+struct _GstH266PredWeightTable
+{
+  guint8 luma_log2_weight_denom;
+  gint8 delta_chroma_log2_weight_denom;
+
+  guint8 num_l0_weights;
+  guint8 luma_weight_l0_flag[15];
+  guint8 chroma_weight_l0_flag[15];
+  gint8 delta_luma_weight_l0[15];
+  gint8 luma_offset_l0[15];
+  gint8 delta_chroma_weight_l0[15][2];
+  gint16 delta_chroma_offset_l0[15][2];
+
+  guint8 num_l1_weights;
+  guint8 luma_weight_l1_flag[15];
+  guint8 chroma_weight_l1_flag[15];
+  gint8 delta_luma_weight_l1[15];
+  gint8 luma_offset_l1[15];
+  gint8 delta_chroma_weight_l1[15][2];
+  gint16 delta_chroma_offset_l1[15][2];
+};
+
+/**
+ * GstH266PicHdr:
+ *
+ * Structure defining the H266 picture header.
+ *
+ * @gdr_or_irap_pic_flag: specifies whethers the current picture is a GDR or
+ *  IRAP picture.
+ * @non_ref_pic_flag: specifies whether the current picture is never used as
+ *  a reference picture.
+ * @gdr_pic_flag: specifies whether the current picture is a GDR picture.
+ * @inter_slice_allowed_flag: specifies whether all coded slices of the picture
+ *  have sh_slice_type equal to 2.
+ * @intra_slice_allowed_flag: specifies whether all coded slices of the picture
+ *  have sh_slice_type equal to 0 or 1.
+ * @pps_id: specifies the value of pps_pic_parameter_set_id for the PPS in use.
+ * @pic_order_cnt_lsb: specifies the picture order count modulo
+ *  MaxPicOrderCntLsb for the current picture.
+ * @recovery_poc_cnt: specifies the recovery point of decoded pictures in
+ *  output order.
+ * @extra_bit[16]: could have any value.
+ * @poc_msb_cycle_present_flag: specifies that the syntax element
+ *  ph_poc_msb_cycle_val is present in the PH.
+ * @poc_msb_cycle_val: specifies the value of the POC MSB cycle of the current
+ *  picture.
+ * @alf_enabled_flag: specifies whether the adaptive loop filter is enabled for
+ *  the current picture.
+ * @num_alf_aps_ids_luma: specifies the number of ALF APSs that the slices in
+ *  the current picture refers to.
+ * @alf_aps_id_luma: specifies the aps_adaptation_parameter_set_id of the i-th
+ *  ALF APS.
+ * @alf_cb_enabled_flag: specifies whether the adaptive loop filter is enabled
+ *  for the Cb colour component of the current picture.
+ * @alf_cr_enabled_flag: specifies whether the adaptive loop filter is enabled
+ *  for the Cr colour component of the current picture.
+ * @alf_aps_id_chroma;: specifies the aps_adaptation_parameter_set_id of the
+ *  ALF APS.
+ * @alf_cc_cb_enabled_flag: specifies whether the cross-component adaptive loop
+ *  filter for the Cb colour component is enabled for the current picture
+ * @alf_cc_cb_aps_id: specifies the aps_adaptation_parameter_set_id of the ALF APS
+ *  that the Cb colour component of the slices in the current picture refers to.
+ * @alf_cc_cr_enabled_flag: specifies that the cross-compoent adaptive loop
+ *  filter for the Cr colour component is enabled for the current picture.
+ * @alf_cc_cr_aps_id: specifies the aps_adaptation_parameter_set_id of the ALF APS
+ *  that the Cr colour component of the slices in the current picture refers to.
+ * @lmcs_enabled_flag: specifies whether LMCS is enabled for the current picture.
+ * @lmcs_aps_id: specifies the aps_adaptation_parameter_set_id of the LMCS APS.
+ * @chroma_residual_scale_flag: specifies whether chroma residual scaling is
+ *  enabled and could be used for the current picture.
+ * @explicit_scaling_list_enabled_flag: specifies that the explicit scaling list
+ *  is enabled for the current picture.
+ * @scaling_list_aps_id: specifies the aps_adaptation_parameter_set_id of the
+ *  scaling list APS.
+ * @virtual_boundaries_present_flag: specifies whether information of virtual
+ *  boundaries is signalled in the PH syntax structure.
+ * @num_ver_virtual_boundaries: specifies the number of
+ *  ph_virtual_boundary_pos_x_minus1[i] syntax elements.
+ * @virtual_boundary_pos_x_minus1: specifies the location of the i-th vertical
+ *  virtual boundary in units of luma samples divided by 8.
+ * @num_hor_virtual_boundaries: specifies the number of
+ *  ph_virtual_boundary_pos_y_minus1[i].
+ * @virtual_boundary_pos_y_minus1: specifies the location of the i-th horizontal
+ *  virtual boundary in units of luma samples divided by 8.
+ * @pic_output_flag: affects the decoded picture output and removal processes
+ *  as specified in Annex C.
+ * @ref_pic_lists: reference lists of #GstH266RefPicLists.
+ * @partition_constraints_override_flag: specifies that partition constraint
+ *  parameters are present.
+ * @log2_diff_min_qt_min_cb_intra_slice_luma: specifies the difference between
+ *  the base 2 logarithm of the minimum size in luma samples of a luma leaf
+ *  block resulting from quadtree splitting of a CTU and the base 2 logarithm
+ *  of the minimum coding block size in luma samples for luma CUs.
+ * @max_mtt_hierarchy_depth_intra_slice_luma: specifies the maximum hierarchy
+ *  depth for coding units resulting from multi-type tree splitting of a
+ *  quadtree leaf.
+ * @log2_diff_max_bt_min_qt_intra_slice_luma: specifies the difference between
+ *  the base 2 logarithm of the maximum size in luma samples of a luma coding
+ *  block that can be split using a binary split and the base 2 logarithm of
+ *  the minimum size in luma samples of a luma leaf block resulting from
+ *  quadtree splitting of a CTU.
+ * @log2_diff_max_tt_min_qt_intra_slice_luma: specifies the difference between
+ *  the base 2 logarithm of the maximum size in luma samples of a luma coding
+ *  block that can be split using a ternary split and the base 2 logarithm of
+ *  the minimum size in luma samples of a luma leaf block resulting from
+ *  quadtree splitting of a CTU.
+ * @log2_diff_min_qt_min_cb_intra_slice_chroma: specifies the difference between
+ *  the base 2 logarithm of the minimum size in luma samples of a chroma leaf
+ *  block resulting from quadtree splitting of a chroma CTU with treeType equal
+ *  to DUAL_TREE_CHROMA and the base 2 logarithm of the minimum coding block
+ *  size in luma samples for chroma CUs with treeType equal to DUAL_TREE_CHROMA.
+ * @max_mtt_hierarchy_depth_intra_slice_chroma: specifies the maximum hierarchy
+ *  depth for chroma coding units resulting from multi-type tree splitting of a
+ *  chroma quadtree leaf with treeType equal to DUAL_TREE_CHROMA.
+ * @log2_diff_max_bt_min_qt_intra_slice_chroma: specifies the difference between
+ *  the base 2 logarithm of the maximum size in luma samples of a chroma coding
+ *  block that can be split using a binary split and the base 2 logarithm of the
+ *  minimum size in luma samples of a chroma leaf block resulting from quadtree
+ *  splitting of a chroma CTU with treeType equal to DUAL_TREE_CHROMA.
+ * @log2_diff_max_tt_min_qt_intra_slice_chroma: specifies the difference between
+ *  the base 2 logarithm of the maximum size in luma samples of a chroma coding
+ *  block that can be split using a ternary split and the base 2 logarithm of
+ *  the minimum size in luma samples of a chroma leaf block resulting from
+ *  quadtree splitting of a chroma CTU with treeType equal to DUAL_TREE_CHROMA.
+ * @cu_qp_delta_subdiv_intra_slice: specifies the maximum cbSubdiv value of
+ *  coding units in intra slice that convey cu_qp_delta_abs and
+ *  cu_qp_delta_sign_flag.
+ * @cu_chroma_qp_offset_subdiv_intra_slice: specifies the maximum cbSubdiv value
+ *  of coding units in intra slice that convey cu_chroma_qp_offset_flag.
+ * @log2_diff_min_qt_min_cb_inter_slice: specifies the difference between the
+ *  base 2 logarithm of the minimum size in luma samples of a luma leaf block
+ *  resulting from quadtree splitting of a CTU and the base 2 logarithm of the
+ *  minimum luma coding block size in luma samples for luma CUs.
+ * @max_mtt_hierarchy_depth_inter_slice: specifies the maximum hierarchy depth
+ *  for coding units resulting from multi-type tree splitting of a quadtree leaf.
+ * @log2_diff_max_bt_min_qt_inter_slice: specifies the difference between the
+ *  base 2 logarithm of the maximum size in luma samples of a luma coding block
+ *  that can be split using a binary split and the base 2 logarithm of the
+ *  minimum size in luma samples of a luma leaf block resulting from quadtree
+ *  splitting of a CTU.
+ * @log2_diff_max_tt_min_qt_inter_slice: specifies the difference between the
+ *  base 2 logarithm of the maximum size in luma samples of a luma coding block
+ *  that can be split using a ternary split and the base 2 logarithm of the
+ *  minimum size in luma samples of a luma leaf block resulting from quadtree
+ *  splitting of a CTU.
+ * @cu_qp_delta_subdiv_inter_slice: specifies the maximum cbSubdiv value of
+ *  coding units that in inter slice convey cu_qp_delta_abs and
+ *  cu_qp_delta_sign_flag.
+ * @cu_chroma_qp_offset_subdiv_inter_slice: specifies the maximum cbSubdiv value
+ *  of coding units in inter slice that convey cu_chroma_qp_offset_flag.
+ * @temporal_mvp_enabled_flag: specifies whether temporal motion vector
+ *  predictor is enabled for the current picture.
+ * @collocated_from_l0_flag: specifies whether the collocated picture used for
+ *  temporal motion vector prediction is derived from RPL 0.
+ * @collocated_ref_idx: specifies the reference index of the collocated picture
+ *  used for temporal motion vector prediction.
+ * @mmvd_fullpel_only_flag: specifies whether the merge mode with motion vector
+ *  difference uses only integer sample precision for the current picture.
+ * @mvd_l1_zero_flag: specifies whether the mvd_coding syntax structure is parsed.
+ * @bdof_disabled_flag: specifies that the bi-directional optical flow inter
+ *  prediction based inter bi-prediction is disabled for the current picture.
+ * @dmvr_disabled_flag: specifies whether the decoder motion vector refinement
+ *  based inter bi-prediction is disabled for the current picture.
+ * @prof_disabled_flag: specifies whether prediction refinement with optical
+ *  flow is disabled for the current picture.
+ * @pred_weight_table: prediction weight table of #GstH266PredWeightTable.
+ * @qp_delta: specifies the initial value of QpY to be used for the coding
+ *  blocks in the picture.
+ * @joint_cbcr_sign_flag: specifies whether the collocated residual samples of
+ *  both chroma components have inverted signs.
+ * @sao_luma_enabled_flag: specifies whether SAO is enabled for the luma
+ *  component of the current picture.
+ * @sao_chroma_enabled_flag: specifies whether SAO is enabled for the chroma
+ *  component of the current picture.
+ * @deblocking_params_present_flag: specifies whether the deblocking parameters
+ *  could be present in the PH syntax structure.
+ * @deblocking_filter_disabled_flag: specifies whether the deblocking filter is
+ *  disabled for the current picture.
+ * @luma_beta_offset_div2: specify the deblocking parameter offsets for ß that
+ *  are applied to the luma component for the slices in the current picture.
+ * @luma_tc_offset_div2: specify the deblocking parameter offsets for tC that
+ *  are applied to the luma component for the slices in the current picture.
+ * @cb_beta_offset_div2: specify the deblocking parameter offsets for ß that
+ *  are applied to the Cb component for the slices in the current picture.
+ * @cb_tc_offset_div2: specify the deblocking parameter offsets for tC that
+ *  are applied to the Cb component for the slices in the current picture.
+ * @cr_beta_offset_div2: specify the deblocking parameter offsets for ß that
+ *  are applied to the Cr component for the slices in the current picture.
+ * @cr_tc_offset_div2: specify the deblocking parameter offsets for tC that
+ *  are applied to the Cr component for the slices in the current picture.
+ * @extension_length: specifies the length of the PH extension data in bytes.
+ * @extension_data_byte: could have any value.
+ * @valid: whether this picture header is valid.
+ */
+struct _GstH266PicHdr {
+  guint8 gdr_or_irap_pic_flag;
+  guint8 non_ref_pic_flag;
+  guint8 gdr_pic_flag;
+  guint8 inter_slice_allowed_flag;
+  guint8 intra_slice_allowed_flag;
+
+  guint8 pps_id;
+  GstH266PPS *pps;
+
+  guint16 pic_order_cnt_lsb;
+  guint8 recovery_poc_cnt;
+  guint8 extra_bit[16];
+  guint8 poc_msb_cycle_present_flag;
+  guint8 poc_msb_cycle_val;
+
+  guint8 alf_enabled_flag;
+  guint8 num_alf_aps_ids_luma;
+  guint8 alf_aps_id_luma[8];
+  guint8 alf_cb_enabled_flag;
+  guint8 alf_cr_enabled_flag;
+  guint8 alf_aps_id_chroma;
+  guint8 alf_cc_cb_enabled_flag;
+  guint8 alf_cc_cb_aps_id;
+  guint8 alf_cc_cr_enabled_flag;
+  guint8 alf_cc_cr_aps_id;
+
+  guint8 lmcs_enabled_flag;
+  guint8 lmcs_aps_id;
+  guint8 chroma_residual_scale_flag;
+  guint8 explicit_scaling_list_enabled_flag;
+  guint8 scaling_list_aps_id;
+
+  guint8 virtual_boundaries_present_flag;
+  guint8 num_ver_virtual_boundaries;
+  guint16 virtual_boundary_pos_x_minus1[3];
+  guint8 num_hor_virtual_boundaries;
+  guint16 virtual_boundary_pos_y_minus1[3];
+
+  guint8 pic_output_flag;
+  GstH266RefPicLists ref_pic_lists;
+
+  guint8 partition_constraints_override_flag;
+
+  guint8 log2_diff_min_qt_min_cb_intra_slice_luma;
+  guint8 max_mtt_hierarchy_depth_intra_slice_luma;
+  guint8 log2_diff_max_bt_min_qt_intra_slice_luma;
+  guint8 log2_diff_max_tt_min_qt_intra_slice_luma;
+  guint8 log2_diff_min_qt_min_cb_intra_slice_chroma;
+
+  guint8 max_mtt_hierarchy_depth_intra_slice_chroma;
+  guint8 log2_diff_max_bt_min_qt_intra_slice_chroma;
+  guint8 log2_diff_max_tt_min_qt_intra_slice_chroma;
+
+  guint8 cu_qp_delta_subdiv_intra_slice;
+  guint8 cu_chroma_qp_offset_subdiv_intra_slice;
+
+  guint8 log2_diff_min_qt_min_cb_inter_slice;
+  guint8 max_mtt_hierarchy_depth_inter_slice;
+  guint8 log2_diff_max_bt_min_qt_inter_slice;
+  guint8 log2_diff_max_tt_min_qt_inter_slice;
+  guint8 cu_qp_delta_subdiv_inter_slice;
+  guint8 cu_chroma_qp_offset_subdiv_inter_slice;
+
+  guint8 temporal_mvp_enabled_flag;
+  guint8 collocated_from_l0_flag;
+  guint8 collocated_ref_idx;
+  guint8 mmvd_fullpel_only_flag;
+  guint8 mvd_l1_zero_flag;
+  guint8 bdof_disabled_flag;
+  guint8 dmvr_disabled_flag;
+  guint8 prof_disabled_flag;
+
+  GstH266PredWeightTable pred_weight_table;
+
+  gint8 qp_delta;
+  guint8 joint_cbcr_sign_flag;
+  guint8 sao_luma_enabled_flag;
+  guint8 sao_chroma_enabled_flag;
+
+  guint8 deblocking_params_present_flag;
+  guint8 deblocking_filter_disabled_flag;
+  gint8 luma_beta_offset_div2;
+  gint8 luma_tc_offset_div2;
+  gint8 cb_beta_offset_div2;
+  gint8 cb_tc_offset_div2;
+  gint8 cr_beta_offset_div2;
+  gint8 cr_tc_offset_div2;
+
+  guint8 extension_length;
+  guint8 extension_data_byte[256];
+
+  gboolean valid;
+};
+
+/**
+ * GstH266SliceHdr:
+ *
+ * Structure defining the H266 slice header.
+ *
+ * @gdr_or_irap_pic_flag: specifies that the PH syntax structure is present in
+ *  the slice header.
+ * @picture_header: the picture header of #GstH266PicHdr.
+ * @subpic_id: specifies the subpicture ID of the subpicture.
+ * @slice_address: specifies the slice address of the slice.
+ * @extra_bit: could have any value.
+ * @num_tiles_in_slice_minus1: specifies the number of tiles in the slice.
+ * @slice_type: specifies the coding type of the slice.
+ * @no_output_of_prior_pics_flag: affects the output of previously-decoded
+ *  pictures in the DPB.
+ * @alf_enabled_flag: specifies whether ALF is enabled for the Y, Cb, or Cr
+ *  colour component of the current slice.
+ * @num_alf_aps_ids_luma: specifies the number of ALF APSs.
+ * @alf_aps_id_luma: specifies the aps_adaptation_parameter_set_id of the i-th
+ *  ALF APS that the luma component of the slice refers to.
+ * @alf_cb_enabled_flag: specifies whether ALF is enabled for the Cb colour
+ *  component of the current slice.
+ * @alf_cr_enabled_flag: specifies whether ALF is enabled for the Cr colour
+ *  component of the current slice.
+ * @alf_aps_id_chroma: specifies the aps_adaptation_parameter_set_id of the ALF
+ *  APS that the chroma component of the slice refers to.
+ * @alf_cc_cb_enabled_flag: specifies whether CCALF is enabled for the Cb
+ *  colour component.
+ * @alf_cc_cb_aps_id: specifies the aps_adaptation_parameter_set_id that the Cb
+ *  colour component of the slice refers to.
+ * @alf_cc_cr_enabled_flag: specifies whether CCALF is enabled for the Cr
+ *  colour component of the current slice.
+ * @alf_cc_cr_aps_id: specifies the aps_adaptation_parameter_set_id that the Cr
+ *  colour component of the slice refers to.
+ * @lmcs_used_flag: specifies that luma mapping is used for the current slice
+ *  and chroma scaling could be used for the current slice.
+ * @explicit_scaling_list_used_flag: specifies that the explicit scaling list
+ *  is used in the scaling process for transform coefficients.
+ * @ref_pic_lists: reference pictures lists of #GstH266RefPicLists.
+ * @num_ref_idx_active_override_flag: specifies whether the syntax element
+ *  sh_num_ref_idx_active_minus1[0] is present for P and B slices.
+ * @num_ref_idx_active_minus1: is used for the derivation of the variable
+ *  NumRefIdxActive[i].
+ * @num_ref_idx_active: the calculated NumRefIdxActive value.
+ * @cabac_init_flag: specifies the method for determining the initialization
+ *  table used in the initialization process for context variables.
+ * @collocated_from_l0_flag: specifies whether the collocated picture used for
+ *  temporal motion vector prediction is derived from RPL 0.
+ * @collocated_ref_idx: specifies the reference index of the collocated picture
+ *  used for temporal motion vector prediction.
+ * @pred_weight_table: prediction weight table of #GstH266PredWeightTable.
+ * @qp_base: the qp base of the current slice.
+ * @qp_delta: specifies the initial value of QpY to be used for the coding
+ *  blocks in the slice.
+ * @cb_qp_offset: specifies a difference to be added to the value of
+ *  pps_cb_qp_offset when determining the value of the Qp'Cb quantization.
+ * @cr_qp_offset: specifies a difference to be added to the value of
+ *  pps_cr_qp_offset when determining the value of the Qp' Cr quantization.
+ * @joint_cbcr_qp_offset: specifies a difference to be added to the value of
+ *  pps_joint_cbcr_qp_offset_value when determining the value of the Qp'CbCr.
+ * @cu_chroma_qp_offset_enabled_flag: specifies whether the
+ *  cu_chroma_qp_offset_flag could be present in the transform unit and palette
+ *  coding syntax of the current slice.
+ * @sao_luma_used_flag: specifies whether SAO is used for the luma component
+ *  in the current slice.
+ * @sao_chroma_used_flag: specifies whether SAO is used for the chroma component
+ *  in the current slice.
+ * @deblocking_params_present_flag: specifies whether the deblocking parameters
+ *  could be present in the slice header.
+ * @deblocking_filter_disabled_flag: specifies whether the deblocking filter is
+ *  disabled for the current slice.
+ * @luma_beta_offset_div2: specify the deblocking parameter offsets for ß that
+ *  are applied to the luma component for the current slice.
+ * @luma_tc_offset_div2: specify the deblocking parameter offsets for tC that
+ *  are applied to the luma component for the current slice.
+ * @cb_beta_offset_div2: specify the deblocking parameter offsets for ß that
+ *  are applied to the Cb component for the current slice.
+ * @cb_tc_offset_div2: specify the deblocking parameter offsets for tC that
+ *  are applied to the Cb component for the current slice.
+ * @cr_beta_offset_div2: specify the deblocking parameter offsets for ß that
+ *  are applied to the Cr component for the current slice.
+ * @cr_tc_offset_div2: specify the deblocking parameter offsets for tC that
+ *  are applied to the Cr component for the current slice.
+ * @dep_quant_used_flag: specifies whether dependent quantization is used.
+ * @sign_data_hiding_used_flag: specifies whether sign bit hiding is not used
+ *  for the current slice.
+ * @ts_residual_coding_disabled_flag: specifies whether the residual_coding()
+ *  syntax structure is used to parse the residual samples of a transform skip
+ *  block for the current slice.
+ * @ts_residual_coding_rice_idx_minus1: specifies whether Rice parameter used
+ *  for the residual_ts_coding() syntax structure in the current slice.
+ * @reverse_last_sig_coeff_flag: specifies whether the coordinates of the last
+ *  significant coefficient are coded relative to ( 0, 0 ) for each transform
+ *  block of the current slice.
+ * @slice_header_extension_length: specifies the length of the slice header
+ *  extension data in bytes.
+ * @slice_header_extension_data_byte: could have any value.
+ * @num_entry_points: NumEntryPoints specifies the number of entry points in
+ *  the current slice.
+ * @entry_offset_len_minus1: specifies the length, in bits, of the
+ *  sh_entry_point_offset_minus1[i] syntax elements.
+ * @entry_point_offset_minus1: specifies the i-th entry point offset in bytes.
+ * @header_size: size of the slice_header() in bits.
+ * @n_emulation_prevention_bytes: number of emulation prevention bytes (EPB) in
+ *  this slice_header().
+ */
+struct _GstH266SliceHdr
+{
+  guint8 picture_header_in_slice_header_flag;
+  GstH266PicHdr picture_header;
+
+  guint16 subpic_id;
+  guint16 slice_address;
+  guint8 extra_bit[16];
+  guint8 num_tiles_in_slice_minus1;
+  guint8 slice_type;
+  guint8 no_output_of_prior_pics_flag;
+
+  guint8 alf_enabled_flag;
+  guint8 num_alf_aps_ids_luma;
+  guint8 alf_aps_id_luma[8];
+  guint8 alf_cb_enabled_flag;
+  guint8 alf_cr_enabled_flag;
+  guint8 alf_aps_id_chroma;
+  guint8 alf_cc_cb_enabled_flag;
+  guint8 alf_cc_cb_aps_id;
+  guint8 alf_cc_cr_enabled_flag;
+  guint8 alf_cc_cr_aps_id;
+
+  guint8 lmcs_used_flag;
+  guint8 explicit_scaling_list_used_flag;
+
+  GstH266RefPicLists ref_pic_lists;
+
+  guint8 num_ref_idx_active_override_flag;
+  guint8 num_ref_idx_active_minus1[2];
+  guint8 num_ref_idx_active[2];
+  guint8 cabac_init_flag;
+  guint8 collocated_from_l0_flag;
+  guint8 collocated_ref_idx;
+
+  GstH266PredWeightTable pred_weight_table;
+
+  gint8 slice_qp_y;
+  gint8 qp_delta;
+  gint8 cb_qp_offset;
+  gint8 cr_qp_offset;
+  gint8 joint_cbcr_qp_offset;
+  guint8 cu_chroma_qp_offset_enabled_flag;
+
+  guint8 sao_luma_used_flag;
+  guint8 sao_chroma_used_flag;
+
+  guint8 deblocking_params_present_flag;
+  guint8 deblocking_filter_disabled_flag;
+  gint8 luma_beta_offset_div2;
+  gint8 luma_tc_offset_div2;
+  gint8 cb_beta_offset_div2;
+  gint8 cb_tc_offset_div2;
+  gint8 cr_beta_offset_div2;
+  gint8 cr_tc_offset_div2;
+  guint8 dep_quant_used_flag;
+
+  guint8 sign_data_hiding_used_flag;
+  guint8 ts_residual_coding_disabled_flag;
+  guint8 ts_residual_coding_rice_idx_minus1;
+  guint8 reverse_last_sig_coeff_flag;
+
+  guint16 slice_header_extension_length;
+  guint8 slice_header_extension_data_byte[256];
+
+  guint16 num_entry_points;
+  guint16 entry_point_start_ctu[GST_H266_MAX_ENTRY_POINTS];
+  guint8 entry_offset_len_minus1;
+  guint32 entry_point_offset_minus1[GST_H266_MAX_ENTRY_POINTS];
+
+  /* Size of the slice_header() in bits */
+  guint header_size;
+  /* Number of emulation prevention bytes (EPB) in this slice_header() */
+  guint n_emulation_prevention_bytes;
+};
+
+/**
+ * GstH266AUD:
+ *
+ * Structure defining the H266 AU delimiter.
+ *
+ * @irap_or_gdr_flag: specifies whether the AU containing the AU delimiter is
+ *  an IRAP or GDR AU.
+ * @pic_type: indicates sh_slice_type values that could be present in the AU.
+ */
+struct _GstH266AUD {
+  guint8 irap_or_gdr_flag;
+  guint8 pic_type;
+};
+
+/**
+ * GstH266OPI:
+ *
+ * Structure defining the H266 operating point information.
+ *
+ * @ols_info_present_flag: specifies whether opi_ols_idx is present in the OPI.
+ * @htid_info_present_flag: specifies whether opi_htid_plus1 is present.
+ * @ols_idx: specifies that the current CVS and the next CVSs in decoding order
+ *  up to and not including the next CVS for which opi_ols_idx is provided in
+ *  an OPI NAL unit do not contain any other layers than those included in the
+ *  OLS with OLS index equal to opi_ols_idx.
+ * @htid_plus1: specifies that all the pictures in the current CVS and the next
+ *  CVSs in decoding order up to and not including the next CVS for which
+ *  opi_htid_plus1 is provided in an OPI NAL unit are IRAP pictures or GDR
+ *  pictures with ph_recovery_poc_cnt equal to 0.
+ * @extension_flag: specifies whether opi_extension_data_flag syntax elements
+ *  are present.
+ * @extension_data_flag: could have any value.
+ */
+struct _GstH266OPI {
+  guint8 ols_info_present_flag;
+  guint8 htid_info_present_flag;
+  guint ols_idx;
+  guint8 htid_plus1;
+  guint8 extension_flag;
+  guint8 extension_data_flag;
+
+  /* extension_data */
+};
+
+/**
+ * GstH266DCI:
+ *
+ * Structure defining the H266 decoding capability information.
+ *
+ * @num_ptls_minus1: specifies the number of profile_tier_level() syntax
+ *  structures in the DCI NAL unit.
+ * @extension_flag: specifies whether dci_extension_data_flag syntax elements
+ *  are present.
+ * @extension_data_flag: could have any value.
+ */
+struct _GstH266DCI {
+  guint8 num_ptls_minus1;
+  GstH266ProfileTierLevel profile_tier_level[15];
+  guint8 extension_flag;
+  guint8 extension_data_flag;
+
+  /* extension_data */
+};
+
+/**
+ * GstH266RawPredWeightTable:
+ *
+ * Structure defining the H266 raw weight table parameters.
+ *
+ * @luma_log2_weight_denom: the base 2 logarithm of the denominator for all
+ *  luma weighting factors.
+ * @delta_chroma_log2_weight_denom: the difference of the base 2 logarithm
+ *  of the denominator for all chroma weighting factors.
+ * @num_l0_weights: the number of weights signalled for entries in RPL 0.
+ * @luma_weight_l0_flag: specifies that weighting factors for the luma component
+ *  of list 0 prediction.
+ * @chroma_weight_l0_flag: specifies whether weighting factors for the chroma
+ *  prediction values of list 0 prediction.
+ * @delta_luma_weight_l0: difference of the weighting factor applied to the luma
+ *  prediction value for list 0 prediction.
+ * @luma_offset_l0: additive offset applied to the luma prediction value for
+ *  list 0 prediction.
+ * @delta_chroma_weight_l0: difference of the weighting factor applied to the
+ *  chroma prediction values for list 0 prediction.
+ * @delta_chroma_offset_l0: difference of the additive offset applied to the
+ *  chroma prediction values for list 0 prediction.
+ * @num_l1_weights: specifies that weighting factors for the luma component of
+ *  list 1 prediction.
+ * @luma_weight_l1_flag: specifies that weighting factors for the luma component
+ *  of list 1 prediction.
+ * @chroma_weight_l1_flag: specifies whether weighting factors for the chroma
+ *  prediction values of list 1 prediction.
+ * @delta_luma_weight_l1: difference of the weighting factor applied to the luma
+ *  prediction value for list 1 prediction.
+ * @luma_offset_l1: additive offset applied to the luma prediction value for
+ *  list 1 prediction.
+ * @delta_chroma_weight_l1: difference of the weighting factor applied to the
+ *  chroma prediction values for list 1 prediction.
+ * @delta_chroma_offset_l1: difference of the additive offset applied to the
+ *  chroma prediction values for list 1 prediction.
+ */
+struct _GstH266RawPredWeightTable {
+  guint8 luma_log2_weight_denom;
+  gint8 delta_chroma_log2_weight_denom;
+
+  guint8 num_l0_weights;
+  guint8 luma_weight_l0_flag[15];
+  guint8 chroma_weight_l0_flag[15];
+  gint8 delta_luma_weight_l0[15];
+  gint8 luma_offset_l0[15];
+  gint8 delta_chroma_weight_l0[15][2];
+  gint16 delta_chroma_offset_l0[15][2];
+
+  guint8 num_l1_weights;
+  guint8 luma_weight_l1_flag[15];
+  guint8 chroma_weight_l1_flag[15];
+  gint8 delta_luma_weight_l1[15];
+  gint8 luma_offset_l1[15];
+  gint8 delta_chroma_weight_l1[15][2];
+  gint16 delta_chroma_offset_l1[15][2];
+};
+
+/**
+ * GstH266BufferingPeriod:
+ *
+ * Structure defining the H266 buffering period.
+ *
+ * @nal_hrd_params_present_flag: specifies whether a list of syntax element
+ *  pairs bp_nal_initial_cpb_removal_delay and bp_nal_initial_cpb_removal_offset
+ *  are present in the BP SEI message.
+ * @vcl_hrd_params_present_flag: specifies whether a list of syntax element
+ *  pairs bp_vcl_initial_cpb_removal_delay and bp_vcl_initial_cpb_removal_offset
+ *  are present in the BP SEI message.
+ * @cpb_initial_removal_delay_length_minus1: specifies the length, in bits, of
+ *  the initial cpb removal syntax elements.
+ * @cpb_removal_delay_length_minus1: specifies the length, in bits, of the
+ *  cpb removal syntax elements.
+ * @dpb_output_delay_length_minus1: specifies the length, in bits, of the
+ *  syntax dpb output syntax elements.
+ * @du_hrd_params_present_flag: specifies whether DU level HRD parameters are
+ *  present and the HRD can be operated at the AU level or DU level.
+ * @du_cpb_removal_delay_increment_length_minus1: specifies the length, in bits,
+ *  of the du cpb removal syntax elements.
+ * @dpb_output_delay_du_length_minus1: specifies the length, in bits, of the
+ *  dpb output syntax element.
+ * @du_cpb_params_in_pic_timing_sei_flag: specifies whether DU level CPB removal
+ *  delay parameters are present in PT SEI messages.
+ * @du_dpb_params_in_pic_timing_sei_flag: specifies whether DU level DPB output
+ *  delay parameters are present in PT SEI messages.
+ * @concatenation_flag: indicates whether the nominal CPB removal time of the
+ *  current AU is determined relative to the nominal CPB removal time of the
+ *  previous AU.
+ * @additional_concatenation_info_present_flag: specifies whether the syntax
+ *  element bp_max_initial_removal_delay_for_concatenation is present in the BP
+ *  SEI message and the syntax element pt_delay_for_concatenation_ensured_flag
+ *  is present in the PT SEI messages.
+ * @max_initial_removal_delay_for_concatenation: identify whether the nominal
+ *  removal time from the CPB of the first AU of a following BP computed with
+ *  bp_cpb_removal_delay_delta_minus1 applies.
+ * @cpb_removal_delay_delta_minus1: specifies a CPB removal delay increment
+ *  value relative to the nominal CPB removal time of the AU prevNonDiscardableAu.
+ * @max_sublayers_minus1: specifies whether maximum number of temporal sublayers
+ *  for which the initial CPB removal delay and the initial CPB removal offset
+ *  are indicated in the BP SEI message.
+ * @cpb_removal_delay_deltas_present_flag: specifies whether the BP SEI message
+ *  contains CPB removal delay deltas.
+ * @num_cpb_removal_delay_deltas_minus1: specifies the number of syntax elements
+ *  bp_cpb_removal_delay_delta_val[i] in the BP SEI message.
+ * @cpb_removal_delay_delta_val: specifies the i-th CPB removal delay delta.
+ * @cpb_cnt_minus1: specifies the number of syntax element pairs
+ *  bp_nal_initial_cpb_removal_delay and bp_nal_initial_cpb_removal_offset
+ *  of the i-th temporal sublayer.
+ * @sublayer_initial_cpb_removal_delay_present_flag: specifies that initial CPB
+ *  removal delay related syntax elements are present for sublayer representation.
+ * @nal_initial_cpb_removal_delay: specify the j-th default initial CPB removal
+ *  delay for the NAL HRD in units of a 90 kHz clock of the i-th temporal sublayer.
+ * @nal_initial_cpb_removal_offset: specify the j-th default initial CPB removal
+ *  offset of the i-th temporal sublayer for the NAL HRD in units of a 90 kHz
+ *  clock.
+ * @nal_initial_alt_cpb_removal_delay: specify the j-th alternative initial CPB
+ *  removal delay for the NAL HRD in units of a 90 kHz clock of the i-th
+ *  temporal sublayer.
+ * @nal_initial_alt_cpb_removal_offset: specify the j-th alternative initial CPB
+ *  removal offset of the i-th temporal sublayer for the NAL HRD in units of a
+ *  90 kHz clock.
+ * @vcl_initial_cpb_removal_delay: specify the j-th default initial CPB removal
+ *  delay of the i-th temporal sublayer for the VCL HRD in units of a 90 kHz clock.
+ * @vcl_initial_cpb_removal_offset: specify the j-th default initial CPB removal
+ *  offset of the i-th temporal sublayer for the VCL HRD in units of a 90 kHz clock.
+ * @vcl_initial_alt_cpb_removal_delay: specify the j-th alternative initial CPB
+ *  removal delay of the i-th temporal sublayer for the VCL HRD in units of a
+ *  90 kHz clock.
+ * @vcl_initial_alt_cpb_removal_offset: specify the j-th alternative initial CPB
+ *  removal offset of the i-th temporal sublayer for the VCL HRD in units of a
+ *  90 kHz clock.
+ * @sublayer_dpb_output_offsets_present_flag: specifies whether DPB output time
+ *  offsets are present for sublayer representation.
+ * @dpb_output_tid_offset: specifies the difference between the DPB output times
+ *  for the i-th sublayer representation.
+ * @alt_cpb_params_present_flag: specifies the presence of the syntax element
+ *  bp_use_alt_cpb_params_flag.
+ * @use_alt_cpb_params_flag: could be used to derive the value of
+ *  UseAltCpbParamsFlag.
+ */
+struct _GstH266BufferingPeriod {
+  guint8 nal_hrd_params_present_flag;
+  guint8 vcl_hrd_params_present_flag;
+  guint8 cpb_initial_removal_delay_length_minus1;
+  guint8 cpb_removal_delay_length_minus1;
+  guint8 dpb_output_delay_length_minus1;
+  guint8 du_hrd_params_present_flag;
+  guint8 du_cpb_removal_delay_increment_length_minus1;
+  guint8 dpb_output_delay_du_length_minus1;
+  guint8 du_cpb_params_in_pic_timing_sei_flag;
+  guint8 du_dpb_params_in_pic_timing_sei_flag;
+  guint8 concatenation_flag;
+  guint8 additional_concatenation_info_present_flag;
+  guint8 max_initial_removal_delay_for_concatenation;
+  guint8 cpb_removal_delay_delta_minus1;
+  guint8 max_sublayers_minus1;
+  guint8 cpb_removal_delay_deltas_present_flag;
+  guint8 num_cpb_removal_delay_deltas_minus1;
+  guint8 cpb_removal_delay_delta_val[16];
+  guint8 cpb_cnt_minus1;
+  guint8 sublayer_initial_cpb_removal_delay_present_flag;
+  guint8 nal_initial_cpb_removal_delay[8][32];
+  guint8 nal_initial_cpb_removal_offset[8][32];
+  guint8 nal_initial_alt_cpb_removal_delay[8][32];
+  guint8 nal_initial_alt_cpb_removal_offset[8][32];
+  guint8 vcl_initial_cpb_removal_delay[8][32];
+  guint8 vcl_initial_cpb_removal_offset[8][32];
+  guint8 vcl_initial_alt_cpb_removal_delay[8][32];
+  guint8 vcl_initial_alt_cpb_removal_offset[8][32];
+  guint8 sublayer_dpb_output_offsets_present_flag;
+  guint32 dpb_output_tid_offset[8];
+  guint8 alt_cpb_params_present_flag;
+  guint8 use_alt_cpb_params_flag;
+};
+
+/**
+ * GstH266PicTiming:
+ *
+ * Structure defining the H266 picture timing.
+ *
+ * @cpb_removal_delay_minus: calculate the number of clock ticks between the
+ *  nominal CPB removal times of the AU associated with the PT SEI message.
+ * @sublayer_delays_present_flag: specifies whether cpb removal values are
+ *  present for the sublayer with TemporalId equal to i.
+ * @cpb_removal_delay_delta_enabled_flag: specifies whether
+ *  pt_cpb_removal_delay_delta_idx[i] is present in the PT SEI message.
+ * @cpb_removal_delay_delta_idx: specifies the index of the CPB removal delta.
+ * @cpb_removal_delay_minus1: is used to calculate the number of clock ticks
+ *  between the nominal CPB removal times of the AU.
+ * @dpb_output_delay: is used to compute the DPB output time of the AU.
+ * @cpb_alt_timing_info_present_flag: specifies whether the cpb alt syntax
+ *  elements could be present in the PT SEI message.
+ * @nal_cpb_alt_initial_removal_delay_delta: specifies whether alternative
+ *  initial CPB removal delay delta for the i-th sublayer for the j-th CPB for
+ *  the NAL HRD in units of a 90 kHz clock.
+ * @nal_cpb_alt_initial_removal_offset_delta: specifies whether alternative
+ *  initial CPB removal offset delta for the i-th sublayer for the j-th CPB for
+ *  the NAL HRD in units of a 90 kHz clock.
+ * @nal_cpb_delay_offset: specifies an offset to be used in the derivation of
+ *  the nominal CPB removal times of the AU.
+ * @nal_dpb_delay_offset: specifies an offset to be used in the derivation of
+ *  the DPB output times of the IRAP AU.
+ * @vcl_cpb_alt_initial_removal_delay_delta: specifies the alternative initial
+ *  CPB removal delay delta for the i-th sublayer for the j-th CPB for the VCL
+ *  HRD in units of a 90 kHz clock.
+ * @vcl_cpb_alt_initial_removal_offset_delta: specifies the alternative initial
+ *  CPB removal offset delta for the i-th sublayer for the j-th CPB for the VCL
+ *  HRD in units of a 90 kHz clock.
+ * @vcl_cpb_delay_offset: specifies an offset to be used in the derivation of
+ *  the nominal CPB removal times of the AU.
+ * @vcl_dpb_delay_offset: specifies an offset to be used in the derivation of
+ *  the DPB output times of the IRAP AU.
+ * @dpb_output_du_delay: is used to compute the DPB output time of the AU when
+ *  DecodingUnitHrdFlag is equal to 1.
+ * @num_decoding_units_minus1: specifies the number of DUs in the AU the PT SEI
+ *  message is associated with.
+ * @du_common_cpb_removal_delay_flag: specifies whether the syntax elements
+ *  pt_du_common_cpb_removal_delay_increment_minus1[i] are present.
+ * @du_common_cpb_removal_delay_increment_minus1: specifies the duration between
+ *  the nominal CPB removal times of any two consecutive DUs in decoding order
+ *  in the AU.
+ * @num_nalus_in_du_minus1: specifies the number of NAL units in the i-th DU of
+ *  the AU the PT SEI message is associated with.
+ * @du_cpb_removal_delay_increment_minus1: specifies the duration between the
+ *  nominal CPB removal times of the (i + 1)-th DU and the i-th DU.
+ * @delay_for_concatenation_ensured_flag: specifies that the difference between
+ *  the final arrival time and the CPB removal time of the AU is present.
+ * @display_elemental_periods_minus1: indicates the number of elemental picture
+ *  period intervals.
+ */
+struct _GstH266PicTiming {
+  guint8 cpb_removal_delay_minus;
+  guint8 sublayer_delays_present_flag[8];
+  guint8 cpb_removal_delay_delta_enabled_flag[8];
+  guint8 cpb_removal_delay_delta_idx[8];
+  guint8 cpb_removal_delay_minus1[8];
+  guint8 dpb_output_delay;
+  guint8 cpb_alt_timing_info_present_flag;
+  guint8 nal_cpb_alt_initial_removal_delay_delta[8][32];
+  guint8 nal_cpb_alt_initial_removal_offset_delta[8][32];
+  guint8 nal_cpb_delay_offset[8];
+  guint8 nal_dpb_delay_offset[8];
+  guint8 vcl_cpb_alt_initial_removal_delay_delta[8][32];
+  guint8 vcl_cpb_alt_initial_removal_offset_delta[8][32];
+  guint8 vcl_cpb_delay_offset[8];
+  guint8 vcl_dpb_delay_offset[8];
+  guint8 dpb_output_du_delay;
+  guint32 num_decoding_units_minus1;
+  guint8 du_common_cpb_removal_delay_flag;
+  guint8 du_common_cpb_removal_delay_increment_minus1[8];
+  /* TODO: PicSizeInCtbsY could be very large */
+  guint32 num_nalus_in_du_minus1[600];
+  guint8 du_cpb_removal_delay_increment_minus1[600][8];
+  guint8 delay_for_concatenation_ensured_flag;
+  guint8 display_elemental_periods_minus1;
+};
+
+/**
+ * GstH266DUInfo:
+ *
+ * Structure defining the H266 decoding unit info.
+ *
+ * @decoding_unit_idx: specifies the index to the list of DUs in the current AU.
+ * @sublayer_delays_present_flag: specifies whether
+ *  dui_du_cpb_removal_delay_increment[i] is present for the sublayer.
+ * @du_cpb_removal_delay_increment: specifies the duration between the nominal
+ *  CPB times of the last DU in decoding order in the current AU.
+ * @dpb_output_du_delay_present_flag: specifies the presence of the
+ *  dui_dpb_output_du_delay syntax element in the DUI SEI message.
+ * @dpb_output_du_delay: is used to compute the DPB output time of the AU.
+ */
+struct _GstH266DUInfo {
+  guint32 decoding_unit_idx;
+  guint8 sublayer_delays_present_flag[8];
+  guint8 du_cpb_removal_delay_increment[8];
+  guint8 dpb_output_du_delay_present_flag;
+  guint8 dpb_output_du_delay;
+};
+
+/**
+ * GstH266ScalableNesting:
+ *
+ * Structure defining the H266 scalable nesting.
+ *
+ * @ols_flag: specifies whether the scalable-nested SEI messages apply to
+ *  specific OLSs.
+ * @subpic_flag: specifies whether the scalable-nested SEI messages that apply
+ *  to specified OLSs or layers apply only to specific subpictures of the
+ *  specified OLSs or layers.
+ * @num_olss_minus1: specifies the number of OLSs to which the scalable-nested
+ *  SEI messages apply.
+ * @ols_idx_delta_minus1: is used to derive the variable NestingOlsIdx[i].
+ * @all_layers_flag: specifies whether the scalable-nested SEI messages apply to
+ *  all layers that have nuh_layer_id greater than or equal to the nuh_layer_id
+ *  of the current SEI NAL unit.
+ * @num_layers_minus1: specifies the number of layers to which the
+ *  scalable-nested SEI messages apply.
+ * @layer_id: specifies the nuh_layer_id value of the i-th layer to which the
+ *  scalable-nested SEI messages apply.
+ * @num_subpics_minus1: specifies the number of subpictures in each picture in
+ *  the multiSubpicLayers.
+ * @subpic_id_len_minus1: specifies the number of bits used to represent the
+ *  syntax element sn_subpic_id[i].
+ * @subpic_id: indicates the subpicture ID of the i-th subpicture in each
+ *  picture in the multiSubpicLayers.
+ * @num_seis_minus1: specifies the number of scalable-nested SEI messages.
+ */
+struct _GstH266ScalableNesting {
+  guint8 ols_flag;
+  guint8 subpic_flag;
+  guint8 num_olss_minus1;
+  guint8 ols_idx_delta_minus1[GST_H266_MAX_TOTAL_NUM_OLSS];
+  guint8 all_layers_flag;
+  guint8 num_layers_minus1;
+  guint8 layer_id[GST_H266_MAX_LAYERS];
+  guint16 num_subpics_minus1;
+  guint8 subpic_id_len_minus1;
+  guint8 subpic_id[GST_H266_MAX_SLICES_PER_AU];
+  guint8 num_seis_minus1;
+};
+
+/**
+ * GstH266SubPicLevelInfo:
+ *
+ * Structure defining the H266 subpicture level information.
+ *
+ * @num_ref_levels_minus1: specifies the number of reference levels signalled
+ *  for each subpicture sequences.
+ * @cbr_constraint_flag: specifies whether to decode the sub-bitstreams
+ *  resulting from extraction of any subpicture sequence.
+ * @explicit_fraction_present_flag: specifies whether the syntax elements
+ *  sli_ref_level_fraction_minus1[ i ] are present.
+ * @num_subpics_minus1: specifies the number of subpictures in the pictures in
+ *  the multiSubpicLayers in targetCvss.
+ * @max_sublayers_minus1: specifies the maximum number of temporal sublayers in
+ *  the subpicture sequences.
+ * @sublayer_info_present_flag: specifies whether the level information for
+ *  subpicture sequences is present for sublayer representation.
+ * @non_subpic_layers_fraction: indicates the i-th fraction of the bitstream
+ *  level limits associated with layers in targetCvss.
+ * @ref_level_idc: indicates the i-th level to which each subpicture sequence
+ *  conforms as specified in Annex A.
+ * @ref_level_fraction_minus1: specifies the i-th fraction of the level limits
+ *  for the subpictures.
+ */
+struct _GstH266SubPicLevelInfo {
+  guint8 num_ref_levels_minus1;
+  guint8 cbr_constraint_flag;
+  guint8 explicit_fraction_present_flag;
+  guint16 num_subpics_minus1;
+  guint8 max_sublayers_minus1;
+  guint8 sublayer_info_present_flag;
+  guint8 non_subpic_layers_fraction[GST_H266_MAX_SUBLAYERS][GST_H266_MAX_SUBLAYERS];
+  guint8 ref_level_idc[GST_H266_MAX_SUBLAYERS][GST_H266_MAX_SUBLAYERS];
+  guint8 ref_level_fraction_minus1[GST_H266_MAX_SUBLAYERS][GST_H266_MAX_SLICES_PER_AU][GST_H266_MAX_SUBLAYERS];
+};
+
+/**
+ * GstH266FrameFieldInfo:
+ *
+ * Structure defining the H266 frame field information.
+ *
+ * @field_pic_flag: indicates whether the display model considers the current
+ *  picture as a field.
+ * @bottom_field_flag: indicates whether the current picture is a bottom field.
+ * @pairing_indicated_flag: indicates whether the current picture is considered
+ *  paired with the next picture in output order or with the previous picture
+ *  in output order as the two fields of a frame.
+ * @paired_with_next_field_flag: indicates whether the current picture is
+ *  considered paired with the next picture as the two fields of a frame.
+ * @display_fields_from_frame_flag: indicates whether the display model operates
+ *  by sequentially displaying the individual fields of the frame with
+ *  alternating parity.
+ * @top_field_first_flag: indicates that the first field of the frame that is
+ *  displayed by the display model is the top field.
+ * @display_elemental_periods_minus1: indicates the number of elemental picture
+ *  period intervals that the current coded picture or field occupies for the
+ *  display model.
+ * @source_scan_type; indicates whether the source scan type of the associated
+ *  picture should be interpreted as progressive.
+ * @duplicate_flag: indicates whether the current picture is indicated to be a
+ *  duplicate of a previous picture in output order.
+ * @valid: whether this frame field info is valid.
+ */
+struct _GstH266FrameFieldInfo {
+  guint8 field_pic_flag;
+  guint8 bottom_field_flag;
+  guint8 pairing_indicated_flag;
+  guint8 paired_with_next_field_flag;
+  guint8 display_fields_from_frame_flag;
+  guint8 top_field_first_flag;
+  guint8 display_elemental_periods_minus1;
+  guint8 source_scan_type;
+  guint8 duplicate_flag;
+  gboolean valid;
+};
+
+/**
+ * GstH266SEIMessage:
+ *
+ * Structure defining the H266 sei message.
+ *
+ * @payloadType: the payload type of #GstH266SEIPayloadType.
+ * @buffering_period: buffering period sei of #GstH266BufferingPeriod.
+ * @pic_timing: picture timing sei of #GstH266PicTiming.
+ * @du_info: decoding unit info sei of #GstH266DUInfo.
+ * @scalable_nesting: scalable nesting sei of #GstH266ScalableNesting.
+ * @subpic_level_info: subpicture level info sei of #GstH266SubPicLevelInfo.
+ * @frame_field_info: frame field info sei of #GstH266FrameFieldInfo.
+ */
+struct _GstH266SEIMessage
+{
+  GstH266SEIPayloadType payloadType;
+
+  union {
+    GstH266BufferingPeriod buffering_period;
+    GstH266PicTiming pic_timing;
+    GstH266DUInfo du_info;
+    GstH266ScalableNesting scalable_nesting;
+    GstH266SubPicLevelInfo subpic_level_info;
+    GstH266FrameFieldInfo frame_field_info;
+
+    /* ... could implement more */
+  } payload;
+};
+
+/**
+ * GstH266Parser:
+ *
+ * H266 NAL Parser (opaque structure).
+ */
+struct _GstH266Parser
+{
+  /*< private >*/
+  GstH266VPS vps[GST_H266_MAX_VPS_COUNT];
+  GstH266SPS sps[GST_H266_MAX_SPS_COUNT];
+  GstH266PPS pps[GST_H266_MAX_PPS_COUNT];
+  GstH266APS aps[GST_H266_APS_TYPE_MAX][GST_H266_MAX_APS_COUNT];
+  GstH266VPS *last_vps;
+  GstH266SPS *last_sps;
+  GstH266PPS *last_pps;
+  GstH266APS *last_aps[GST_H266_APS_TYPE_MAX];
+  GstH266PicHdr ph;
+  GstH266SEIMessage buffering_period;
+  GstH266SEIMessage *last_buffering_period;
+
+  GstH266VPS *active_vps;
+  GstH266SPS *active_sps;
+  GstH266PPS *active_pps;
+
+  guint16 ctb_addr_in_slice[GST_H266_MAX_CTUS_IN_PICTURE];
+  guint16 slice_start_offset[GST_H266_MAX_SLICES_PER_AU];
+  guint16 num_ctus_in_slice[GST_H266_MAX_SLICES_PER_AU];
+  guint16 ctb_to_tile_col_bd[GST_H266_MAX_CTUS_IN_PICTURE];
+  guint16 ctb_to_tile_row_bd[GST_H266_MAX_CTUS_IN_PICTURE];
+};
+
+GST_CODEC_PARSERS_API
+GstH266Parser *     gst_h266_parser_new                (void);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_identify_nalu      (GstH266Parser * parser,
+                                                        const guint8 * data,
+                                                        guint offset,
+                                                        gsize size,
+                                                        GstH266NalUnit * nalu);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_identify_nalu_unchecked (GstH266Parser * parser,
+                                                             const guint8 * data,
+                                                             guint offset,
+                                                             gsize size,
+                                                             GstH266NalUnit * nalu);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_identify_nalu_vvc  (GstH266Parser * parser,
+                                                        const guint8 * data,
+                                                        guint offset,
+                                                        gsize size,
+                                                        guint8 nal_length_size,
+                                                        GstH266NalUnit * nalu);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_nal          (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_aud          (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266AUD * aud);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_opi          (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266OPI * opi);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_dci          (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266DCI * dci);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_picture_hdr  (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266PicHdr * picture);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_slice_hdr    (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266SliceHdr * slice);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_vps          (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266VPS * vps);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_sps          (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266SPS * sps,
+                                                        gboolean  parse_vui_params);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_pps          (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266PPS * pps);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_aps          (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266APS * aps);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parser_parse_sei          (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GArray ** messages);
+GST_CODEC_PARSERS_API
+void                gst_h266_parser_free               (GstH266Parser * parser);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parse_vps                 (GstH266NalUnit * nalu,
+                                                        GstH266VPS * vps);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parse_sps                 (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266SPS * sps,
+                                                        gboolean parse_vui_params);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parse_pps                 (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266PPS * pps);
+GST_CODEC_PARSERS_API
+GstH266ParserResult gst_h266_parse_aps                 (GstH266Parser * parser,
+                                                        GstH266NalUnit * nalu,
+                                                        GstH266APS * aps);
+GST_CODEC_PARSERS_API
+void                gst_h266_sei_free                  (GstH266SEIMessage * sei);
+GST_CODEC_PARSERS_API
+const gchar *       gst_h266_profile_to_string         (GstH266Profile profile);
+GST_CODEC_PARSERS_API
+GstH266Profile      gst_h266_profile_from_string       (const gchar * string);
+
+G_END_DECLS
diff --git a/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/meson.build b/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/meson.build
index 5865b373ef..5991ef8cd4 100644
--- a/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/meson.build
+++ b/subprojects/gst-plugins-bad/gst-libs/gst/codecparsers/meson.build
@@ -16,6 +16,7 @@ codecparser_sources = files([
   'vp8utils.c',
   'gstmpegvideometa.c',
   'gstav1parser.c',
+  'gsth266parser.c',
   'gsth264bitwriter.c',
   'gsth265bitwriter.c',
   'gstav1bitwriter.c',
@@ -35,6 +36,7 @@ codecparser_headers = [
   'gstmpegvideometa.h',
   'gstvp9parser.h',
   'gstav1parser.h',
+  'gsth266parser.h',
   'gstlcevcmeta.h',
 ]
 install_headers(codecparser_headers, subdir : 'gstreamer-1.0/gst/codecparsers')
 
-- 
2.25.1

