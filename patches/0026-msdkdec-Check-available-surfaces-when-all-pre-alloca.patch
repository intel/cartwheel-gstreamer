From 447fcaee3689c5c42ab54e529c589b4560d02305 Mon Sep 17 00:00:00 2001
From: Mengkejiergeli Ba <mengkejiergeli.ba@intel.com>
Date: Tue, 23 Aug 2022 14:20:35 +0800
Subject: [PATCH 26/26] msdkdec: Check available surfaces when all
 pre-allocated surfaces are in use

---
 .../gst-plugins-bad/sys/msdk/gstmsdkdec.c     | 54 +++++++++++++++++--
 1 file changed, 51 insertions(+), 3 deletions(-)

diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkdec.c b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkdec.c
index 634525fa32..68bc1e57e8 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkdec.c
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkdec.c
@@ -152,7 +152,7 @@ free_surface (GstMsdkSurface * s)
   g_slice_free (GstMsdkSurface, s);
 }
 
-static void
+static gboolean
 gst_msdkdec_free_unlocked_msdk_surfaces (GstMsdkDec * thiz)
 {
   GList *l;
@@ -161,13 +161,43 @@ gst_msdkdec_free_unlocked_msdk_surfaces (GstMsdkDec * thiz)
   for (l = thiz->locked_msdk_surfaces; l;) {
     GList *next = l->next;
     surface = l->data;
-    if (surface->surface->Data.Locked == 0) {
+    if (surface->surface->Data.Locked == 0 &&
+        GST_MINI_OBJECT_REFCOUNT (surface->buf) == 1) {
       free_surface (surface);
       thiz->locked_msdk_surfaces =
           g_list_delete_link (thiz->locked_msdk_surfaces, l);
     }
     l = next;
   }
+  /* We need to check if all surfaces are in used */
+  if (g_list_length (thiz->locked_msdk_surfaces) ==
+      thiz->alloc_resp.NumFrameActual)
+    return FALSE;
+  else
+    return TRUE;
+}
+
+static gboolean
+check_surface_available (GstMsdkDec * thiz)
+{
+  GList *l;
+  GstMsdkSurface *surface = NULL;
+  gboolean ret = FALSE;
+
+  for (l = thiz->locked_msdk_surfaces; l;) {
+    GList *next = l->next;
+    surface = l->data;
+    if (surface->surface->Data.Locked == 0
+        && GST_MINI_OBJECT_REFCOUNT (surface->buf) == 1) {
+      free_surface (surface);
+      thiz->locked_msdk_surfaces =
+          g_list_delete_link (thiz->locked_msdk_surfaces, l);
+      return TRUE;
+    }
+    l = next;
+  }
+
+  return ret;
 }
 
 static GstMsdkSurface *
@@ -175,10 +205,28 @@ allocate_output_surface (GstMsdkDec * thiz)
 {
   GstMsdkSurface *msdk_surface = NULL;
   GstBuffer *out_buffer = NULL;
+  gint n = 0;
+  guint retry_times = gst_util_uint64_scale_ceil (GST_USECOND,
+      thiz->param.mfx.FrameInfo.FrameRateExtD,
+      thiz->param.mfx.FrameInfo.FrameRateExtN);
 
   /* Free un-unsed msdk surfaces firstly, hence the associated mfx
    * surfaces will be moved from used list to available list */
-  gst_msdkdec_free_unlocked_msdk_surfaces (thiz);
+  if (!gst_msdkdec_free_unlocked_msdk_surfaces (thiz)) {
+    while (n < retry_times) {
+      /* It is MediaSDK requirement that only the pre-allocated
+       * surfaces can be used during the whole decoding process.
+       * In the case of decoder plus multi-encdoers, it is possible
+       * that all surfaces are used by downstreams and no more surfaces
+       * available for decoder. So here we need to wait until there is at
+       * least one surface is free for decoder.
+       */
+      n++;
+      g_usleep (1000);
+      if (check_surface_available (thiz))
+        break;
+    }
+  }
 #ifndef _WIN32
   if ((gst_buffer_pool_acquire_buffer (thiz->alloc_pool, &out_buffer, 0))
       != GST_FLOW_OK) {
-- 
2.25.1

