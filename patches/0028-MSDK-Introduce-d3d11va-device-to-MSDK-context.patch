From b93cac9d80cf662fbc7a17d9bdf29dea6cd8618d Mon Sep 17 00:00:00 2001
From: Tong Wu <tong1.wu@intel.com>
Date: Sat, 7 May 2022 17:10:34 +0800
Subject: [PATCH 02/16] MSDK: Introduce d3d11va device to MSDK context

Currently MSDK context does not support d3d11va. Now introduce d3d11va
device to MSDK context, making it able to create msdk session with d3d11
device and to easily share with upstream and donwstream.
---
 .../gst-plugins-bad/sys/msdk/gstmsdkcontext.c | 177 +++++++++++++++++-
 .../gst-plugins-bad/sys/msdk/gstmsdkcontext.h |  11 ++
 .../sys/msdk/gstmsdkcontextutil.c             |  65 ++++++-
 .../sys/msdk/gstmsdkcontextutil.h             |   6 +
 .../gst-plugins-bad/sys/msdk/gstmsdkdec.c     |  13 +-
 .../gst-plugins-bad/sys/msdk/gstmsdkenc.c     |  13 +-
 .../gst-plugins-bad/sys/msdk/gstmsdkvpp.c     |  13 +-
 7 files changed, 289 insertions(+), 9 deletions(-)

diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontext.c b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontext.c
index 590afb52f1..3f08c3f581 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontext.c
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontext.c
@@ -38,6 +38,8 @@
 #include <va/va_drm.h>
 #include <gudev/gudev.h>
 #include <gst/va/gstvadisplay_drm.h>
+#else
+#include <gst/d3d11/gstd3d11.h>
 #endif
 
 GST_DEBUG_CATEGORY_STATIC (gst_debug_msdkcontext);
@@ -57,6 +59,8 @@ struct _GstMsdkContextPrivate
   GstMsdkContext *parent_context;
 #ifndef _WIN32
   GstVaDisplay *display;
+#else
+  GstD3D11Device *device;
 #endif
 };
 
@@ -202,6 +206,90 @@ failed:
 
   return FALSE;
 }
+#else
+static gboolean
+gst_msdk_context_use_d3d11 (GstMsdkContext * context)
+{
+  HRESULT hr;
+  IDXGIFactory1 *factory = NULL;
+  GstD3D11Device *device = NULL;
+  GstMsdkContextPrivate *priv = context->priv;
+  mfxStatus status;
+  guint idx = 0;
+
+  hr = CreateDXGIFactory1 (&IID_IDXGIFactory1, (void **) &factory);
+  if (FAILED (hr)) {
+    GST_ERROR ("Couldn't create DXGI factory");
+    return FALSE;
+  }
+
+
+  /* Pick the first available Intel device for now */
+  while (!device) {
+    IDXGIAdapter1 *adapter;
+    DXGI_ADAPTER_DESC desc;
+    gint64 luid;
+    ID3D10Multithread *multi_thread;
+    ID3D11Device *device_handle;
+
+    hr = IDXGIFactory1_EnumAdapters1 (factory, idx, &adapter);
+    if (FAILED (hr))
+      return FALSE;
+
+    hr = IDXGIAdapter1_GetDesc (adapter, &desc);
+    if (FAILED (hr)) {
+      IDXGIAdapter1_Release (adapter);
+      idx++;
+      continue;
+    }
+
+    if (desc.VendorId != 0x8086) {
+      IDXGIAdapter1_Release (adapter);
+      idx++;
+      continue;
+    }
+
+    luid = gst_d3d11_luid_to_int64 (&desc.AdapterLuid);
+    device = gst_d3d11_device_new_for_adapter_luid (luid,
+        D3D11_CREATE_DEVICE_BGRA_SUPPORT);
+    IDXGIAdapter1_Release (adapter);
+
+    if (!device) {
+      idx++;
+      continue;
+    }
+
+    device_handle = gst_d3d11_device_get_device_handle (device);
+    hr = ID3D11Device_QueryInterface (device_handle,
+        &IID_ID3D10Multithread, (void **) &multi_thread);
+    if (FAILED (hr)) {
+      gst_object_unref (device);
+      idx++;
+      continue;
+    }
+
+    hr = ID3D10Multithread_SetMultithreadProtected (multi_thread, TRUE);
+    ID3D10Multithread_Release (multi_thread);
+
+    idx++;
+  }
+
+  IDXGIFactory1_Release (factory);
+
+  status =
+      MFXVideoCORE_SetHandle (priv->session.session, MFX_HANDLE_D3D11_DEVICE,
+      gst_d3d11_device_get_device_handle (device));
+  if (status != MFX_ERR_NONE) {
+    GST_ERROR ("Setting D3D11VA handle failed (%s)",
+        msdk_status_to_string (status));
+    gst_object_unref (device);
+    return FALSE;
+  }
+
+  priv->device = device;
+
+  return TRUE;
+}
 #endif
 
 static gboolean
@@ -226,6 +314,11 @@ gst_msdk_context_open (GstMsdkContext * context, gboolean hardware,
     if (!gst_msdk_context_use_vaapi (context))
       goto failed;
   }
+#else
+  if (hardware) {
+    if (!gst_msdk_context_use_d3d11 (context))
+      goto failed;
+  }
 #endif
 
   codename = msdk_get_platform_codename (priv->session.session);
@@ -282,6 +375,9 @@ gst_msdk_context_finalize (GObject * obj)
 #ifndef _WIN32
   if (priv->display)
     gst_object_unref (priv->display);
+#else
+  if (priv->device)
+    gst_object_unref (priv->device);
 #endif
 
 done:
@@ -337,6 +433,8 @@ gst_msdk_context_new_with_parent (GstMsdkContext * parent)
 
   if (MFX_IMPL_VIA_VAAPI == (0x0f00 & (impl)))
     handle_type = MFX_HANDLE_VA_DISPLAY;
+  else if (MFX_IMPL_VIA_D3D11 == (0x0f00 & (impl)))
+    handle_type = MFX_HANDLE_D3D11_DEVICE;
 
   if (handle_type) {
     status =
@@ -397,19 +495,21 @@ gst_msdk_context_new_with_parent (GstMsdkContext * parent)
       g_list_prepend (parent_priv->child_session_list, priv->session.session);
 #ifndef _WIN32
   priv->display = parent_priv->display;
+#else
+  priv->device = parent_priv->device;
 #endif
   priv->parent_context = gst_object_ref (parent);
 
   return obj;
 }
 
+#ifndef _WIN32
 GstMsdkContext *
 gst_msdk_context_new_with_va_display (GstObject * display_obj,
     gboolean hardware, GstMsdkContextJobType job_type)
 {
   GstMsdkContext *obj = NULL;
 
-#ifndef _WIN32
   GstMsdkContextPrivate *priv;
   mfxU16 codename;
   mfxStatus status;
@@ -454,10 +554,71 @@ gst_msdk_context_new_with_va_display (GstObject * display_obj,
   else
     GST_WARNING ("Unknown MFX platform");
 
-#endif
+  return obj;
+}
+#else
+GstMsdkContext *
+gst_msdk_context_new_with_d3d11_device (GstD3D11Device * device,
+    gboolean hardware, GstMsdkContextJobType job_type)
+{
+  GstMsdkContext *obj = NULL;
+  GstMsdkContextPrivate *priv;
+  mfxU16 codename;
+  mfxStatus status;
+  ID3D10Multithread *multi_thread;
+  ID3D11Device *device_handle;
+  HRESULT hr;
+
+  obj = g_object_new (GST_TYPE_MSDK_CONTEXT, NULL);
+  if (!obj)
+    return NULL;
+
+  priv = obj->priv;
+  priv->device = g_object_ref (device);
+
+  priv->job_type = job_type;
+  priv->hardware = hardware;
+  priv->session =
+      msdk_open_session (hardware ? MFX_IMPL_HARDWARE_ANY : MFX_IMPL_SOFTWARE);
+  if (!priv->session.session) {
+    g_object_unref (obj);
+    return NULL;
+  }
+
+  device_handle = gst_d3d11_device_get_device_handle (device);
+  hr = ID3D11Device_QueryInterface (device_handle,
+      &IID_ID3D10Multithread, (void **) &multi_thread);
+  if (FAILED (hr)) {
+    gst_object_unref (device);
+    GST_ERROR ("ID3D10Multithread interface is unavailable");
+    return NULL;
+  }
+
+  hr = ID3D10Multithread_SetMultithreadProtected (multi_thread, TRUE);
+  ID3D10Multithread_Release (multi_thread);
+
+  if (hardware) {
+    status =
+        MFXVideoCORE_SetHandle (priv->session.session, MFX_HANDLE_D3D11_DEVICE,
+        device_handle);
+    if (status != MFX_ERR_NONE) {
+      GST_ERROR ("Setting D3D11VA handle failed (%s)",
+          msdk_status_to_string (status));
+      g_object_unref (obj);
+      return NULL;
+    }
+  }
+
+  codename = msdk_get_platform_codename (priv->session.session);
+
+  if (codename != MFX_PLATFORM_UNKNOWN)
+    GST_INFO ("Detected MFX platform with device code %d", codename);
+  else
+    GST_WARNING ("Unknown MFX platform");
 
   return obj;
 }
+#endif
 
 mfxSession
 gst_msdk_context_get_session (GstMsdkContext * context)
@@ -475,15 +636,23 @@ gst_msdk_context_get_handle (GstMsdkContext * context)
 #endif
 }
 
+#ifndef _WIN32
 GstObject *
 gst_msdk_context_get_display (GstMsdkContext * context)
 {
-#ifndef _WIN32
   if (context->priv->display)
     return gst_object_ref (GST_OBJECT_CAST (context->priv->display));
-#endif
   return NULL;
 }
+#else
+GstD3D11Device *
+gst_msdk_context_get_device (GstMsdkContext * context)
+{
+  if (context->priv->device)
+    return gst_object_ref (context->priv->device);
+  return NULL;
+}
+#endif
 
 static gint
 _find_response (gconstpointer resp, gconstpointer comp_resp)
diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontext.h b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontext.h
index 5c9bd0e849..ce16b47889 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontext.h
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontext.h
@@ -37,6 +37,8 @@
 #ifndef _WIN32
 #include <va/va.h>
 #include <va/va_drmcommon.h>
+#else
+#include <gst/d3d11/gstd3d11_fwd.h>
 #endif
 
 G_BEGIN_DECLS
@@ -87,12 +89,21 @@ GType gst_msdk_context_get_type (void);
 
 GstMsdkContext * gst_msdk_context_new (gboolean hardware, GstMsdkContextJobType job_type);
 GstMsdkContext * gst_msdk_context_new_with_parent (GstMsdkContext * parent);
+#ifndef _WIN32
 GstMsdkContext * gst_msdk_context_new_with_va_display (GstObject * display_obj,
     gboolean hardware, GstMsdkContextJobType job_type);
+#else
+GstMsdkContext * gst_msdk_context_new_with_d3d11_device (GstD3D11Device * device,
+    gboolean hardware, GstMsdkContextJobType job_type);
+#endif
 mfxSession gst_msdk_context_get_session (GstMsdkContext * context);
 
 gpointer gst_msdk_context_get_handle (GstMsdkContext * context);
+#ifndef _WIN32
 GstObject * gst_msdk_context_get_display (GstMsdkContext * context);
+#else
+GstD3D11Device * gst_msdk_context_get_device (GstMsdkContext * context);
+#endif
 
 /* GstMsdkContext contains mfxFrameAllocResponses,
  * if app calls MFXVideoCORE_SetFrameAllocator.
diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontextutil.c b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontextutil.c
index 6bbdebb935..2f5eb38180 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontextutil.c
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontextutil.c
@@ -34,6 +34,8 @@
 #ifndef _WIN32
 #include <gst/va/gstvadisplay.h>
 #include <gst/va/gstvautils.h>
+#else
+#include <gst/d3d11/gstd3d11device.h>
 #endif
 
 GST_DEBUG_CATEGORY_STATIC (GST_CAT_CONTEXT);
@@ -245,6 +247,17 @@ gst_msdk_ensure_new_context (GstElement * element, gboolean hardware,
     ret = TRUE;
     goto done;
   }
+#else
+  /* 2) Query the neighbour the D3D11 device. If already a valid D3D11 device,
+     using it by gst_msdk_context_from_external_device() in set_context(). */
+  _context_query (element, GST_D3D11_DEVICE_HANDLE_CONTEXT_TYPE);
+  msdk_context = g_atomic_pointer_get (context_ptr);
+  if (msdk_context) {
+    gst_object_ref (msdk_context);
+    propagate_display = FALSE;
+    ret = TRUE;
+    goto done;
+  }
 #endif
 
   /* 3) Create a MSDK context from scratch. */
@@ -276,11 +289,11 @@ done:
   return ret;
 }
 
+#ifndef _WIN32
 gboolean
 gst_msdk_context_from_external_display (GstContext * context, gboolean hardware,
     GstMsdkContextJobType job_type, GstMsdkContext ** msdk_context)
 {
-#ifndef _WIN32
   GstObject *va_display = NULL;
   const gchar *type;
   const GstStructure *s;
@@ -309,10 +322,42 @@ gst_msdk_context_from_external_display (GstContext * context, gboolean hardware,
   if (ctx)
     return TRUE;
 
-#endif
+  return FALSE;
+}
+#else
+gboolean
+gst_msdk_context_from_external_device (GstContext * context, gboolean hardware,
+    GstMsdkContextJobType job_type, GstMsdkContext ** msdk_context)
+{
+  GstD3D11Device *d3d11_device = NULL;
+  const gchar *type;
+  const GstStructure *s;
+  GstMsdkContext *ctx = NULL;
+
+  _init_context_debug ();
+
+  type = gst_context_get_context_type (context);
+  if (g_strcmp0 (type, GST_D3D11_DEVICE_HANDLE_CONTEXT_TYPE))
+    return FALSE;
+
+  s = gst_context_get_structure (context);
+  if (gst_structure_get (s, "device", GST_TYPE_D3D11_DEVICE, &d3d11_device,
+          NULL)) {
+    ctx =
+        gst_msdk_context_new_with_d3d11_device (d3d11_device, hardware,
+        job_type);
+    if (ctx)
+      *msdk_context = ctx;
+
+    gst_clear_object (&d3d11_device);
+  }
+
+  if (ctx)
+    return TRUE;
 
   return FALSE;
 }
+#endif
 
 gboolean
 gst_msdk_handle_context_query (GstElement * element, GstQuery * query,
@@ -360,6 +405,22 @@ gst_msdk_handle_context_query (GstElement * element, GstQuery * query,
       ret = TRUE;
     }
   } else
+#else
+  if (g_strcmp0 (context_type, GST_D3D11_DEVICE_HANDLE_CONTEXT_TYPE) == 0) {
+    GstStructure *s;
+    GstD3D11Device *device = gst_msdk_context_get_device (msdk_context);
+
+    if (device) {
+      GST_CAT_LOG (GST_CAT_CONTEXT,
+          "setting GstD3D11Device (%" GST_PTR_FORMAT ") on context (%"
+          GST_PTR_FORMAT ")", device, ctxt);
+
+      s = gst_context_writable_structure (ctxt);
+      gst_structure_set (s, "device", GST_TYPE_D3D11_DEVICE, device, NULL);
+      gst_object_unref (device);
+      ret = TRUE;
+    }
+  } else
 #endif
   if (g_strcmp0 (context_type, GST_MSDK_CONTEXT_TYPE_NAME) == 0) {
     GstStructure *s;
diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontextutil.h b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontextutil.h
index 0994dc0410..7ba57e6639 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontextutil.h
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkcontextutil.h
@@ -52,9 +52,15 @@ gst_msdk_ensure_new_context (GstElement * element, gboolean hardware, GstMsdkCon
 gboolean
 gst_msdk_context_get_context (GstContext * context, GstMsdkContext ** msdk_context);
 
+#ifndef _WIN32
 gboolean
 gst_msdk_context_from_external_display (GstContext * context, gboolean hardware,
     GstMsdkContextJobType job_type, GstMsdkContext ** msdk_context);
+#else
+gboolean
+gst_msdk_context_from_external_device (GstContext * context, gboolean hardware,
+    GstMsdkContextJobType job_type, GstMsdkContext ** msdk_context);
+#endif
 
 gboolean
 gst_msdk_handle_context_query (GstElement * element, GstQuery * query, GstMsdkContext * msdk_context);
diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkdec.c b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkdec.c
index e4abc69f2c..46195cdbb2 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkdec.c
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkdec.c
@@ -315,13 +315,24 @@ gst_msdkdec_set_context (GstElement * element, GstContext * context)
     gst_object_replace ((GstObject **) & thiz->context,
         (GstObject *) msdk_context);
     gst_object_unref (msdk_context);
-  } else if (gst_msdk_context_from_external_display (context,
+  } else
+#ifndef _WIN32
+    if (gst_msdk_context_from_external_display (context,
           thiz->hardware, 0 /* GST_MSDK_JOB_DECODER will be set later */ ,
           &msdk_context)) {
     gst_object_replace ((GstObject **) & thiz->context,
         (GstObject *) msdk_context);
     gst_object_unref (msdk_context);
   }
+#else
+    if (gst_msdk_context_from_external_device (context,
+          thiz->hardware, 0 /* GST_MSDK_JOB_DECODER will be set later */ ,
+          &msdk_context)) {
+    gst_object_replace ((GstObject **) & thiz->context,
+        (GstObject *) msdk_context);
+    gst_object_unref (msdk_context);
+  }
+#endif
 
   GST_ELEMENT_CLASS (parent_class)->set_context (element, context);
 }
diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkenc.c b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkenc.c
index 373d3424da..ef8dcde2ca 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkenc.c
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkenc.c
@@ -146,13 +146,24 @@ gst_msdkenc_set_context (GstElement * element, GstContext * context)
     gst_object_replace ((GstObject **) & thiz->context,
         (GstObject *) msdk_context);
     gst_object_unref (msdk_context);
-  } else if (gst_msdk_context_from_external_display (context,
+  } else
+#ifndef _WIN32
+    if (gst_msdk_context_from_external_display (context,
           thiz->hardware, 0 /* GST_MSDK_JOB_ENCODER will be set later */ ,
           &msdk_context)) {
     gst_object_replace ((GstObject **) & thiz->context,
         (GstObject *) msdk_context);
     gst_object_unref (msdk_context);
   }
+#else
+    if (gst_msdk_context_from_external_device (context,
+          thiz->hardware, 0 /* GST_MSDK_JOB_ENCODER will be set later */ ,
+          &msdk_context)) {
+    gst_object_replace ((GstObject **) & thiz->context,
+        (GstObject *) msdk_context);
+    gst_object_unref (msdk_context);
+  }
+#endif
 
   GST_ELEMENT_CLASS (parent_class)->set_context (element, context);
 }
diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkvpp.c b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkvpp.c
index 71162987e6..1b4037a4f9 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkvpp.c
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkvpp.c
@@ -1659,13 +1659,24 @@ gst_msdkvpp_set_context (GstElement * element, GstContext * context)
     gst_object_replace ((GstObject **) & thiz->context,
         (GstObject *) msdk_context);
     gst_object_unref (msdk_context);
-  } else if (gst_msdk_context_from_external_display (context,
+  } else
+#ifndef _WIN32
+    if (gst_msdk_context_from_external_display (context,
           thiz->hardware, 0 /* GST_MSDK_JOB_VPP will be set later */ ,
           &msdk_context)) {
     gst_object_replace ((GstObject **) & thiz->context,
         (GstObject *) msdk_context);
     gst_object_unref (msdk_context);
   }
+#else
+    if (gst_msdk_context_from_external_device (context,
+          thiz->hardware, 0 /* GST_MSDK_JOB_VPP will be set later */ ,
+          &msdk_context)) {
+    gst_object_replace ((GstObject **) & thiz->context,
+        (GstObject *) msdk_context);
+    gst_object_unref (msdk_context);
+  }
+#endif
 
   GST_ELEMENT_CLASS (parent_class)->set_context (element, context);
 }
-- 
2.35.1.windows.2

