From fdf6a86a261e7bdf22d2f09c16af1eda0b8049c3 Mon Sep 17 00:00:00 2001
From: Mengkejiergeli Ba <mengkejiergeli.ba@intel.com>
Date: Fri, 27 May 2022 17:56:33 +0800
Subject: [PATCH 16/21] msdk: Add help functions to get mfxFrameSurface1 from
 GstBuffer and wrap it as GstMsdkSurface

---
 .../sys/msdk/gstmsdkallocator.h               |   7 ++
 .../sys/msdk/gstmsdkallocator_libva.c         | 115 ++++++++++++++++++
 .../sys/msdk/gstmsdkallocator_libva.h         |   4 +
 subprojects/gst-plugins-bad/sys/msdk/msdk.h   |   1 +
 4 files changed, 127 insertions(+)

diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator.h b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator.h
index e0d5616205..0a42299b33 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator.h
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator.h
@@ -39,6 +39,7 @@
 G_BEGIN_DECLS
 
 typedef struct _GstMsdkMemoryID GstMsdkMemoryID;
+typedef struct _GstMsdkSurface GstMsdkSurface;
 
 struct _GstMsdkMemoryID {
   mfxU32 fourcc;
@@ -56,6 +57,12 @@ struct _GstMsdkMemoryID {
 #endif
 };
 
+struct _GstMsdkSurface
+{
+  mfxFrameSurface1 *surface;
+  GstBuffer *buf;
+};
+
 mfxStatus gst_msdk_frame_alloc(mfxHDL pthis, mfxFrameAllocRequest *req, mfxFrameAllocResponse *resp);
 mfxStatus gst_msdk_frame_free(mfxHDL pthis, mfxFrameAllocResponse *resp);
 mfxStatus gst_msdk_frame_lock(mfxHDL pthis, mfxMemId mid, mfxFrameData *ptr);
diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator_libva.c b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator_libva.c
index 9f711b008f..eda5463643 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator_libva.c
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator_libva.c
@@ -37,6 +37,21 @@
 #include "gstmsdkallocator_libva.h"
 #include "msdk_libva.h"
 
+#include <gst/va/gstvaallocator.h>
+
+#define GST_MSDK_FRAME_SURFACE gst_msdk_frame_surface_quark_get ()
+static GQuark
+gst_msdk_frame_surface_quark_get (void)
+{
+  static gsize g_quark;
+
+  if (g_once_init_enter (&g_quark)) {
+    gsize quark = (gsize) g_quark_from_static_string ("GstMsdkFrameSurface");
+    g_once_init_leave (&g_quark, quark);
+  }
+  return g_quark;
+}
+
 mfxStatus
 gst_msdk_frame_alloc (mfxHDL pthis, mfxFrameAllocRequest * req,
     mfxFrameAllocResponse * resp)
@@ -704,6 +719,106 @@ error_create_surface:
   }
 }
 
+static VASurfaceID
+_get_va_surface (GstBuffer * buf, GstVideoInfo * info,
+    GstMsdkContext * msdk_context)
+{
+  VASurfaceID va_surface = VA_INVALID_ID;
+
+  if (!info) {
+    va_surface = gst_va_buffer_get_surface (buf);
+  } else {
+    /* Update offset/stride/size if there is VideoMeta attached to
+     * the dma buffer, which is then used to get vasurface */
+    GstMemory *mem;
+    guint i, fd;
+    GstVideoMeta *vmeta;
+
+    vmeta = gst_buffer_get_video_meta (buf);
+    if (vmeta) {
+      if (GST_VIDEO_INFO_FORMAT (info) != vmeta->format ||
+          GST_VIDEO_INFO_WIDTH (info) != vmeta->width ||
+          GST_VIDEO_INFO_HEIGHT (info) != vmeta->height ||
+          GST_VIDEO_INFO_N_PLANES (info) != vmeta->n_planes) {
+        GST_ERROR ("VideoMeta attached to buffer is not matching"
+            "the negotiated width/height/format");
+        return va_surface;
+      }
+      for (i = 0; i < GST_VIDEO_INFO_N_PLANES (info); ++i) {
+        GST_VIDEO_INFO_PLANE_OFFSET (info, i) = vmeta->offset[i];
+        GST_VIDEO_INFO_PLANE_STRIDE (info, i) = vmeta->stride[i];
+      }
+      GST_VIDEO_INFO_SIZE (info) = gst_buffer_get_size (buf);
+    }
+
+    mem = gst_buffer_peek_memory (buf, 0);
+    fd = gst_dmabuf_memory_get_fd (mem);
+    if (fd < 0)
+      return va_surface;
+    /* export dmabuf to vasurface */
+    if (!gst_msdk_export_dmabuf_to_vasurface (msdk_context, info, fd,
+            &va_surface))
+      return VA_INVALID_ID;
+  }
+
+  return va_surface;
+}
+
+GstMsdkSurface *
+gst_msdk_import_to_msdk_surface (GstBuffer * buf, GstMsdkContext * msdk_context,
+    GstVideoInfo * vinfo)
+{
+  VASurfaceID va_surface = VA_INVALID_ID;
+  GstMemory *mem = NULL;
+  mfxFrameInfo frame_info = { 0, };
+  GstMsdkSurface *msdk_surface = NULL;
+  mfxFrameSurface1 *mfx_surface = NULL;
+  GstMsdkMemoryID *msdk_mid = NULL;
+  mfxMemId *mfx_mid = NULL;
+
+  mem = gst_buffer_peek_memory (buf, 0);
+  msdk_surface = g_slice_new0 (GstMsdkSurface);
+
+  /* If buffer has qdata pointing to mfxFrameSurface1, directly extract it */
+  if ((mfx_surface = gst_mini_object_get_qdata (GST_MINI_OBJECT_CAST (mem),
+              GST_MSDK_FRAME_SURFACE))) {
+    msdk_surface->surface = mfx_surface;
+    return msdk_surface;
+  }
+
+  if (gst_msdk_is_va_mem (mem)) {
+    va_surface = _get_va_surface (buf, NULL, NULL);
+  } else if (gst_is_dmabuf_memory (mem)) {
+    /* For dma memory, videoinfo is used with dma fd to create va surface. */
+    GstVideoInfo info = *vinfo;
+    va_surface = _get_va_surface (buf, &info, msdk_context);
+  }
+
+  if (va_surface == VA_INVALID_ID)
+    return NULL;
+
+  mfx_surface = g_slice_new0 (mfxFrameSurface1);
+  msdk_mid = g_slice_new0 (GstMsdkMemoryID);
+  mfx_mid = g_slice_new0 (mfxMemId);
+
+  msdk_mid->surface = g_slice_new0 (VASurfaceID);
+  *msdk_mid->surface = va_surface;
+
+  mfx_mid = (mfxMemId *) msdk_mid;
+  mfx_surface->Data.MemId = mfx_mid;
+
+  gst_msdk_set_mfx_frame_info_from_video_info (&frame_info, vinfo);
+  mfx_surface->Info = frame_info;
+
+  /* Set mfxFrameSurface1 as qdata in buffer */
+  gst_mini_object_set_qdata (GST_MINI_OBJECT_CAST (mem),
+      GST_MSDK_FRAME_SURFACE, mfx_surface, NULL);
+
+  msdk_surface->surface = mfx_surface;
+
+  return msdk_surface;
+}
+
 /**
  * gst_msdk_replace_mfx_memid:
  * This method replace the internal VA Suface in mfxSurface with a new one
diff --git a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator_libva.h b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator_libva.h
index da2f4d3bfe..fa25821fd8 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator_libva.h
+++ b/subprojects/gst-plugins-bad/sys/msdk/gstmsdkallocator_libva.h
@@ -45,6 +45,10 @@ gboolean
 gst_msdk_export_dmabuf_to_vasurface (GstMsdkContext *context,
     GstVideoInfo *vinfo, gint fd, VASurfaceID *surface_id);
 
+GstMsdkSurface *
+gst_msdk_import_to_msdk_surface (GstBuffer * buf, GstMsdkContext * msdk_context,
+    GstVideoInfo * vinfo);
+
 gboolean
 gst_msdk_replace_mfx_memid (GstMsdkContext *context,
     mfxFrameSurface1 *mfx_surface, VASurfaceID surface_id);
diff --git a/subprojects/gst-plugins-bad/sys/msdk/msdk.h b/subprojects/gst-plugins-bad/sys/msdk/msdk.h
index cb76fd516d..2b197ccce8 100644
--- a/subprojects/gst-plugins-bad/sys/msdk/msdk.h
+++ b/subprojects/gst-plugins-bad/sys/msdk/msdk.h
@@ -99,6 +99,7 @@ void GstMFXUnload (mfxLoader loader);
 #endif
 
 typedef struct _MsdkSession MsdkSession;
+typedef struct _GstMsdkSurface GstMsdkSurface;
 
 struct _MsdkSession
 {
-- 
2.25.1

